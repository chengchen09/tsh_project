/**
 * Autogenerated by Thrift Compiler (0.7.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#include "arraydb_types.h"

namespace arraydb {

int _kDataTypeValues[] = {
  DataType::UNKNOWN,
  DataType::INT16,
  DataType::UINT16,
  DataType::INT32,
  DataType::UINT32,
  DataType::INT64,
  DataType::UINT64,
  DataType::FLOAT,
  DataType::DOUBLE
};
const char* _kDataTypeNames[] = {
  "UNKNOWN",
  "INT16",
  "UINT16",
  "INT32",
  "UINT32",
  "INT64",
  "UINT64",
  "FLOAT",
  "DOUBLE"
};
const std::map<int, const char*> _DataType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kDataTypeValues, _kDataTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCompressTypeValues[] = {
  CompressType::NO_COMPRESSION,
  CompressType::ZLIB,
  CompressType::LZMA
};
const char* _kCompressTypeNames[] = {
  "NO_COMPRESSION",
  "ZLIB",
  "LZMA"
};
const std::map<int, const char*> _CompressType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kCompressTypeValues, _kCompressTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kStorageStrategyValues[] = {
  StorageStrategy::ROUND_ROBIN
};
const char* _kStorageStrategyNames[] = {
  "ROUND_ROBIN"
};
const std::map<int, const char*> _StorageStrategy_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kStorageStrategyValues, _kStorageStrategyNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kIndexTypeValues[] = {
  IndexType::CHUNK_INDEX,
  IndexType::BITMAP_INDEX,
  IndexType::TILE_INDEX,
  IndexType::CHUNK_BITMAP,
  IndexType::CHUNK_TILE,
  IndexType::NO_INDEX
};
const char* _kIndexTypeNames[] = {
  "CHUNK_INDEX",
  "BITMAP_INDEX",
  "TILE_INDEX",
  "CHUNK_BITMAP",
  "CHUNK_TILE",
  "NO_INDEX"
};
const std::map<int, const char*> _IndexType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kIndexTypeValues, _kIndexTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* Array::ascii_fingerprint = "D9F4CFE2F293A8B1052FD3031DD2C847";
const uint8_t Array::binary_fingerprint[16] = {0xD9,0xF4,0xCF,0xE2,0xF2,0x93,0xA8,0xB1,0x05,0x2F,0xD3,0x03,0x1D,0xD2,0xC8,0x47};

uint32_t Array::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->compress_type = (CompressType::type)ecast0;
          this->__isset.compress_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Array::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Array");
  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("compress_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->compress_type);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->data);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ChunkInfo::ascii_fingerprint = "0BA9E334BF062067E5D057B6236809F4";
const uint8_t ChunkInfo::binary_fingerprint[16] = {0x0B,0xA9,0xE3,0x34,0xBF,0x06,0x20,0x67,0xE5,0xD0,0x57,0xB6,0x23,0x68,0x09,0xF4};

uint32_t ChunkInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->chunk_id);
          this->__isset.chunk_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ndims);
          this->__isset.ndims = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->chunk_size);
          this->__isset.chunk_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->compressed_size);
          this->__isset.compressed_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->chunk_name);
          this->__isset.chunk_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->first.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _etype4;
            iprot->readListBegin(_etype4, _size1);
            this->first.resize(_size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              xfer += iprot->readI64(this->first[_i5]);
            }
            iprot->readListEnd();
          }
          this->__isset.first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->last.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            iprot->readListBegin(_etype9, _size6);
            this->last.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += iprot->readI64(this->last[_i10]);
            }
            iprot->readListEnd();
          }
          this->__isset.last = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ChunkInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ChunkInfo");
  xfer += oprot->writeFieldBegin("chunk_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->chunk_id);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("ndims", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ndims);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("chunk_size", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->chunk_size);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("compressed_size", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->compressed_size);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("chunk_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->chunk_name);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("first", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->first.size()));
    std::vector<int64_t> ::const_iterator _iter11;
    for (_iter11 = this->first.begin(); _iter11 != this->first.end(); ++_iter11)
    {
      xfer += oprot->writeI64((*_iter11));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("last", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->last.size()));
    std::vector<int64_t> ::const_iterator _iter12;
    for (_iter12 = this->last.begin(); _iter12 != this->last.end(); ++_iter12)
    {
      xfer += oprot->writeI64((*_iter12));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* DimInfo::ascii_fingerprint = "01233FF45FD1A48AF6DDBF39A5D0547E";
const uint8_t DimInfo::binary_fingerprint[16] = {0x01,0x23,0x3F,0xF4,0x5F,0xD1,0xA4,0x8A,0xF6,0xDD,0xBF,0x39,0xA5,0xD0,0x54,0x7E};

uint32_t DimInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->length);
          this->__isset.length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->chunk_length);
          this->__isset.chunk_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->overlap_length);
          this->__isset.overlap_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DimInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DimInfo");
  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("length", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->length);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("chunk_length", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->chunk_length);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("overlap_length", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->overlap_length);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ArrayInfo::ascii_fingerprint = "A4E5F6466381688A198DE522114D1F49";
const uint8_t ArrayInfo::binary_fingerprint[16] = {0xA4,0xE5,0xF6,0x46,0x63,0x81,0x68,0x8A,0x19,0x8D,0xE5,0x22,0x11,0x4D,0x1F,0x49};

uint32_t ArrayInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->array_id);
          this->__isset.array_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->var_name);
          this->__isset.var_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast13;
          xfer += iprot->readI32(ecast13);
          this->var_type = (DataType::type)ecast13;
          this->__isset.var_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dtype_size);
          this->__isset.dtype_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nelmts);
          this->__isset.nelmts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ndims);
          this->__isset.ndims = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast14;
          xfer += iprot->readI32(ecast14);
          this->ss = (StorageStrategy::type)ecast14;
          this->__isset.ss = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nchunks);
          this->__isset.nchunks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dims.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _etype18;
            iprot->readListBegin(_etype18, _size15);
            this->dims.resize(_size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              xfer += this->dims[_i19].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.dims = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->chunk_dims.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            iprot->readListBegin(_etype23, _size20);
            this->chunk_dims.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += iprot->readI64(this->chunk_dims[_i24]);
            }
            iprot->readListEnd();
          }
          this->__isset.chunk_dims = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->chunks.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _etype28;
            iprot->readListBegin(_etype28, _size25);
            this->chunks.resize(_size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              xfer += this->chunks[_i29].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.chunks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fill_value);
          this->__isset.fill_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast30;
          xfer += iprot->readI32(ecast30);
          this->compress_type = (CompressType::type)ecast30;
          this->__isset.compress_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ArrayInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ArrayInfo");
  xfer += oprot->writeFieldBegin("array_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->array_id);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("var_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->var_name);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("var_type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->var_type);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("dtype_size", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->dtype_size);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("nelmts", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->nelmts);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("ndims", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->ndims);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("ss", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32((int32_t)this->ss);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("nchunks", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->nchunks);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("dims", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dims.size()));
    std::vector<DimInfo> ::const_iterator _iter31;
    for (_iter31 = this->dims.begin(); _iter31 != this->dims.end(); ++_iter31)
    {
      xfer += (*_iter31).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("chunk_dims", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->chunk_dims.size()));
    std::vector<int64_t> ::const_iterator _iter32;
    for (_iter32 = this->chunk_dims.begin(); _iter32 != this->chunk_dims.end(); ++_iter32)
    {
      xfer += oprot->writeI64((*_iter32));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("chunks", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->chunks.size()));
    std::vector<ChunkInfo> ::const_iterator _iter33;
    for (_iter33 = this->chunks.begin(); _iter33 != this->chunks.end(); ++_iter33)
    {
      xfer += (*_iter33).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fill_value", ::apache::thrift::protocol::T_STRING, 13);
  xfer += oprot->writeString(this->fill_value);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("compress_type", ::apache::thrift::protocol::T_I32, 14);
  xfer += oprot->writeI32((int32_t)this->compress_type);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ChunkIndex::ascii_fingerprint = "06343684351EE9E5FC9AF57369AE1D80";
const uint8_t ChunkIndex::binary_fingerprint[16] = {0x06,0x34,0x36,0x84,0x35,0x1E,0xE9,0xE5,0xFC,0x9A,0xF5,0x73,0x69,0xAE,0x1D,0x80};

uint32_t ChunkIndex::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->chunk_id);
          this->__isset.chunk_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ChunkIndex::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ChunkIndex");
  xfer += oprot->writeFieldBegin("chunk_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->chunk_id);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->max);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->min);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* IndexInfo::ascii_fingerprint = "D20F1D7ED770A539F37613EC41131EA6";
const uint8_t IndexInfo::binary_fingerprint[16] = {0xD2,0x0F,0x1D,0x7E,0xD7,0x70,0xA5,0x39,0xF3,0x76,0x13,0xEC,0x41,0x13,0x1E,0xA6};

uint32_t IndexInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->array_name);
          this->__isset.array_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->index_name);
          this->__isset.index_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast34;
          xfer += iprot->readI32(ecast34);
          this->index_type = (IndexType::type)ecast34;
          this->__isset.index_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->chunk_indexs.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _etype38;
            iprot->readListBegin(_etype38, _size35);
            this->chunk_indexs.resize(_size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              xfer += this->chunk_indexs[_i39].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.chunk_indexs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IndexInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("IndexInfo");
  xfer += oprot->writeFieldBegin("array_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->array_name);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("index_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->index_name);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("index_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->index_type);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("chunk_indexs", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->chunk_indexs.size()));
    std::vector<ChunkIndex> ::const_iterator _iter40;
    for (_iter40 = this->chunk_indexs.begin(); _iter40 != this->chunk_indexs.end(); ++_iter40)
    {
      xfer += (*_iter40).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

} // namespace
