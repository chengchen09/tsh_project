/**
 * Autogenerated by Thrift Compiler (0.7.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#ifndef arraydb_TYPES_H
#define arraydb_TYPES_H

#include <Thrift.h>
#include <TApplicationException.h>
#include <protocol/TProtocol.h>
#include <transport/TTransport.h>



namespace arraydb {

struct DataType {
  enum type {
    UNKNOWN = 0,
    INT16 = 1,
    UINT16 = 2,
    INT32 = 3,
    UINT32 = 4,
    INT64 = 5,
    UINT64 = 6,
    FLOAT = 7,
    DOUBLE = 8
  };
};

extern const std::map<int, const char*> _DataType_VALUES_TO_NAMES;

struct CompressType {
  enum type {
    NO_COMPRESSION = 0,
    ZLIB = 1,
    LZMA = 2
  };
};

extern const std::map<int, const char*> _CompressType_VALUES_TO_NAMES;

struct StorageStrategy {
  enum type {
    ROUND_ROBIN = 1
  };
};

extern const std::map<int, const char*> _StorageStrategy_VALUES_TO_NAMES;

struct IndexType {
  enum type {
    CHUNK_INDEX = 0,
    BITMAP_INDEX = 1,
    TILE_INDEX = 2,
    CHUNK_BITMAP = 3,
    CHUNK_TILE = 4,
    NO_INDEX = 5
  };
};

extern const std::map<int, const char*> _IndexType_VALUES_TO_NAMES;

typedef struct _Array__isset {
  _Array__isset() : name(false), compress_type(false), data(false) {}
  bool name;
  bool compress_type;
  bool data;
} _Array__isset;

class Array {
 public:

  static const char* ascii_fingerprint; // = "D9F4CFE2F293A8B1052FD3031DD2C847";
  static const uint8_t binary_fingerprint[16]; // = {0xD9,0xF4,0xCF,0xE2,0xF2,0x93,0xA8,0xB1,0x05,0x2F,0xD3,0x03,0x1D,0xD2,0xC8,0x47};

  Array() : name(""), data("") {
  }

  virtual ~Array() throw() {}

  std::string name;
  CompressType::type compress_type;
  std::string data;

  _Array__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_compress_type(const CompressType::type val) {
    compress_type = val;
  }

  void __set_data(const std::string& val) {
    data = val;
  }

  bool operator == (const Array & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(compress_type == rhs.compress_type))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const Array &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Array & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ChunkInfo__isset {
  _ChunkInfo__isset() : chunk_id(false), node_id(false), ndims(false), chunk_size(false), compressed_size(false), chunk_name(false), first(false), last(false) {}
  bool chunk_id;
  bool node_id;
  bool ndims;
  bool chunk_size;
  bool compressed_size;
  bool chunk_name;
  bool first;
  bool last;
} _ChunkInfo__isset;

class ChunkInfo {
 public:

  static const char* ascii_fingerprint; // = "0BA9E334BF062067E5D057B6236809F4";
  static const uint8_t binary_fingerprint[16]; // = {0x0B,0xA9,0xE3,0x34,0xBF,0x06,0x20,0x67,0xE5,0xD0,0x57,0xB6,0x23,0x68,0x09,0xF4};

  ChunkInfo() : chunk_id(0), node_id(0), ndims(0), chunk_size(0), compressed_size(0), chunk_name("") {
  }

  virtual ~ChunkInfo() throw() {}

  int32_t chunk_id;
  int32_t node_id;
  int64_t ndims;
  int64_t chunk_size;
  int64_t compressed_size;
  std::string chunk_name;
  std::vector<int64_t>  first;
  std::vector<int64_t>  last;

  _ChunkInfo__isset __isset;

  void __set_chunk_id(const int32_t val) {
    chunk_id = val;
  }

  void __set_node_id(const int32_t val) {
    node_id = val;
  }

  void __set_ndims(const int64_t val) {
    ndims = val;
  }

  void __set_chunk_size(const int64_t val) {
    chunk_size = val;
  }

  void __set_compressed_size(const int64_t val) {
    compressed_size = val;
  }

  void __set_chunk_name(const std::string& val) {
    chunk_name = val;
  }

  void __set_first(const std::vector<int64_t> & val) {
    first = val;
  }

  void __set_last(const std::vector<int64_t> & val) {
    last = val;
  }

  bool operator == (const ChunkInfo & rhs) const
  {
    if (!(chunk_id == rhs.chunk_id))
      return false;
    if (!(node_id == rhs.node_id))
      return false;
    if (!(ndims == rhs.ndims))
      return false;
    if (!(chunk_size == rhs.chunk_size))
      return false;
    if (!(compressed_size == rhs.compressed_size))
      return false;
    if (!(chunk_name == rhs.chunk_name))
      return false;
    if (!(first == rhs.first))
      return false;
    if (!(last == rhs.last))
      return false;
    return true;
  }
  bool operator != (const ChunkInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ChunkInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DimInfo__isset {
  _DimInfo__isset() : name(false), length(false), chunk_length(false), overlap_length(false) {}
  bool name;
  bool length;
  bool chunk_length;
  bool overlap_length;
} _DimInfo__isset;

class DimInfo {
 public:

  static const char* ascii_fingerprint; // = "01233FF45FD1A48AF6DDBF39A5D0547E";
  static const uint8_t binary_fingerprint[16]; // = {0x01,0x23,0x3F,0xF4,0x5F,0xD1,0xA4,0x8A,0xF6,0xDD,0xBF,0x39,0xA5,0xD0,0x54,0x7E};

  DimInfo() : name(""), length(0), chunk_length(0), overlap_length(0) {
  }

  virtual ~DimInfo() throw() {}

  std::string name;
  int64_t length;
  int64_t chunk_length;
  int64_t overlap_length;

  _DimInfo__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_length(const int64_t val) {
    length = val;
  }

  void __set_chunk_length(const int64_t val) {
    chunk_length = val;
  }

  void __set_overlap_length(const int64_t val) {
    overlap_length = val;
  }

  bool operator == (const DimInfo & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(length == rhs.length))
      return false;
    if (!(chunk_length == rhs.chunk_length))
      return false;
    if (!(overlap_length == rhs.overlap_length))
      return false;
    return true;
  }
  bool operator != (const DimInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DimInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ArrayInfo__isset {
  _ArrayInfo__isset() : array_id(false), name(false), var_name(false), var_type(false), dtype_size(false), nelmts(false), ndims(false), ss(false), nchunks(false), dims(false), chunk_dims(false), chunks(false), fill_value(false), compress_type(false) {}
  bool array_id;
  bool name;
  bool var_name;
  bool var_type;
  bool dtype_size;
  bool nelmts;
  bool ndims;
  bool ss;
  bool nchunks;
  bool dims;
  bool chunk_dims;
  bool chunks;
  bool fill_value;
  bool compress_type;
} _ArrayInfo__isset;

class ArrayInfo {
 public:

  static const char* ascii_fingerprint; // = "A4E5F6466381688A198DE522114D1F49";
  static const uint8_t binary_fingerprint[16]; // = {0xA4,0xE5,0xF6,0x46,0x63,0x81,0x68,0x8A,0x19,0x8D,0xE5,0x22,0x11,0x4D,0x1F,0x49};

  ArrayInfo() : array_id(0), name(""), var_name(""), dtype_size(0), nelmts(0), ndims(0), nchunks(0), fill_value("") {
  }

  virtual ~ArrayInfo() throw() {}

  int64_t array_id;
  std::string name;
  std::string var_name;
  DataType::type var_type;
  int64_t dtype_size;
  int64_t nelmts;
  int64_t ndims;
  StorageStrategy::type ss;
  int64_t nchunks;
  std::vector<DimInfo>  dims;
  std::vector<int64_t>  chunk_dims;
  std::vector<ChunkInfo>  chunks;
  std::string fill_value;
  CompressType::type compress_type;

  _ArrayInfo__isset __isset;

  void __set_array_id(const int64_t val) {
    array_id = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_var_name(const std::string& val) {
    var_name = val;
  }

  void __set_var_type(const DataType::type val) {
    var_type = val;
  }

  void __set_dtype_size(const int64_t val) {
    dtype_size = val;
  }

  void __set_nelmts(const int64_t val) {
    nelmts = val;
  }

  void __set_ndims(const int64_t val) {
    ndims = val;
  }

  void __set_ss(const StorageStrategy::type val) {
    ss = val;
  }

  void __set_nchunks(const int64_t val) {
    nchunks = val;
  }

  void __set_dims(const std::vector<DimInfo> & val) {
    dims = val;
  }

  void __set_chunk_dims(const std::vector<int64_t> & val) {
    chunk_dims = val;
  }

  void __set_chunks(const std::vector<ChunkInfo> & val) {
    chunks = val;
  }

  void __set_fill_value(const std::string& val) {
    fill_value = val;
  }

  void __set_compress_type(const CompressType::type val) {
    compress_type = val;
  }

  bool operator == (const ArrayInfo & rhs) const
  {
    if (!(array_id == rhs.array_id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(var_name == rhs.var_name))
      return false;
    if (!(var_type == rhs.var_type))
      return false;
    if (!(dtype_size == rhs.dtype_size))
      return false;
    if (!(nelmts == rhs.nelmts))
      return false;
    if (!(ndims == rhs.ndims))
      return false;
    if (!(ss == rhs.ss))
      return false;
    if (!(nchunks == rhs.nchunks))
      return false;
    if (!(dims == rhs.dims))
      return false;
    if (!(chunk_dims == rhs.chunk_dims))
      return false;
    if (!(chunks == rhs.chunks))
      return false;
    if (!(fill_value == rhs.fill_value))
      return false;
    if (!(compress_type == rhs.compress_type))
      return false;
    return true;
  }
  bool operator != (const ArrayInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ArrayInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ChunkIndex__isset {
  _ChunkIndex__isset() : chunk_id(false), max(false), min(false) {}
  bool chunk_id;
  bool max;
  bool min;
} _ChunkIndex__isset;

class ChunkIndex {
 public:

  static const char* ascii_fingerprint; // = "06343684351EE9E5FC9AF57369AE1D80";
  static const uint8_t binary_fingerprint[16]; // = {0x06,0x34,0x36,0x84,0x35,0x1E,0xE9,0xE5,0xFC,0x9A,0xF5,0x73,0x69,0xAE,0x1D,0x80};

  ChunkIndex() : chunk_id(0), max(0), min(0) {
  }

  virtual ~ChunkIndex() throw() {}

  int32_t chunk_id;
  double max;
  double min;

  _ChunkIndex__isset __isset;

  void __set_chunk_id(const int32_t val) {
    chunk_id = val;
  }

  void __set_max(const double val) {
    max = val;
  }

  void __set_min(const double val) {
    min = val;
  }

  bool operator == (const ChunkIndex & rhs) const
  {
    if (!(chunk_id == rhs.chunk_id))
      return false;
    if (!(max == rhs.max))
      return false;
    if (!(min == rhs.min))
      return false;
    return true;
  }
  bool operator != (const ChunkIndex &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ChunkIndex & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _IndexInfo__isset {
  _IndexInfo__isset() : array_name(false), index_name(false), index_type(false), chunk_indexs(false) {}
  bool array_name;
  bool index_name;
  bool index_type;
  bool chunk_indexs;
} _IndexInfo__isset;

class IndexInfo {
 public:

  static const char* ascii_fingerprint; // = "D20F1D7ED770A539F37613EC41131EA6";
  static const uint8_t binary_fingerprint[16]; // = {0xD2,0x0F,0x1D,0x7E,0xD7,0x70,0xA5,0x39,0xF3,0x76,0x13,0xEC,0x41,0x13,0x1E,0xA6};

  IndexInfo() : array_name(""), index_name("") {
  }

  virtual ~IndexInfo() throw() {}

  std::string array_name;
  std::string index_name;
  IndexType::type index_type;
  std::vector<ChunkIndex>  chunk_indexs;

  _IndexInfo__isset __isset;

  void __set_array_name(const std::string& val) {
    array_name = val;
  }

  void __set_index_name(const std::string& val) {
    index_name = val;
  }

  void __set_index_type(const IndexType::type val) {
    index_type = val;
  }

  void __set_chunk_indexs(const std::vector<ChunkIndex> & val) {
    chunk_indexs = val;
  }

  bool operator == (const IndexInfo & rhs) const
  {
    if (!(array_name == rhs.array_name))
      return false;
    if (!(index_name == rhs.index_name))
      return false;
    if (!(index_type == rhs.index_type))
      return false;
    if (!(chunk_indexs == rhs.chunk_indexs))
      return false;
    return true;
  }
  bool operator != (const IndexInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IndexInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

} // namespace

#endif
