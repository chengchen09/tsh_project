*** File /home/chen/Downloads/pGrib2nc/grib2nc/ieee2flt.c:
                #include <stdio.h>
                #include <math.h>
                #include "wgrib2.h"
                
                /* wesley ebisuzaki v0.2
                 *
                 * takes 4 byte character string (single precision ieee big-endian)
                 * and returns a float
                 *
                 * doesn't handle NAN, infinity and any other funny stuff in ieee
                 *
                 * ansi C
                 */
                
          17 -> float ieee2flt(unsigned char *ieee) {
                	double fmant;
                	int exp;
                
                        if ((ieee[0] & 127) == 0 && ieee[1] == 0 && ieee[2] == 0 && ieee[3] == 0)
                	   return (float) 0.0;
                
                	exp = ((ieee[0] & 127) << 1) + (ieee[1] >> 7);
                	fmant = (double) ((int) ieee[3] + (int) (ieee[2] << 8) + 
                              (int) ((ieee[1] | 128) << 16));
                	if (ieee[0] & 128) fmant = -fmant;
                	return (float) (ldexp(fmant, (int) (exp - 128 - 22)));
                }


Top 10 Lines:

     Line      Count

       15         17

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       17   Total number of line executions
    17.00   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/g2clib-1.1.8/g2_unpack4.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include "grib2.h"
                
                
                g2int g2_unpack4(unsigned char *cgrib,g2int *iofst,g2int *ipdsnum,g2int **ipdstmpl,
                               g2int *mappdslen,g2float **coordlist,g2int *numcoord)
                ////$$$  SUBPROGRAM DOCUMENTATION BLOCK
                //                .      .    .                                       .
                // SUBPROGRAM:    g2_unpack4 
                //   PRGMMR: Gilbert         ORG: W/NP11    DATE: 2002-10-31
                //
                // ABSTRACT: This subroutine unpacks Section 4 (Product Definition Section)
                //           as defined in GRIB Edition 2.
                //
                // PROGRAM HISTORY LOG:
                // 2002-10-31  Gilbert
                // 2009-01-14  Vuong     Changed structure name template to gtemplate
                //
                // USAGE:    int g2_unpack4(unsigned char *cgrib,g2int *iofst,g2int *ipdsnum,
                //                          g2int **ipdstmpl,g2int *mappdslen,
                //                          g2float **coordlist,g2int *numcoord)
                //   INPUT ARGUMENTS:
                //     cgrib    - Char array containing Section 4 of the GRIB2 message
                //     iofst    - Bit offset of the beginning of Section 4 in cgrib.
                //
                //   OUTPUT ARGUMENTS:      
                //     iofst    - Bit offset of the end of Section 4, returned.
                //     ipdsnum  - Product Definition Template Number ( see Code Table 4.0)
                //     ipdstmpl - Pointer to integer array containing the data values for 
                //                the specified Product Definition
                //                Template ( N=ipdsnum ).  Each element of this integer
                //                array contains an entry (in the order specified) of Product
                //                Defintion Template 4.N
                //     mappdslen- Number of elements in ipdstmpl[].  i.e. number of entries
                //                in Product Defintion Template 4.N  ( N=ipdsnum ).
                //     coordlist- Pointer to real array containing floating point values 
                //                intended to document
                //                the vertical discretisation associated to model data
                //                on hybrid coordinate vertical levels.  (part of Section 4)
                //     numcoord - number of values in array coordlist.
                //
                //   RETURN VALUES:
                //     ierr     - Error return code.
                //                0 = no error
                //                2 = Not section 4
                //                5 = "GRIB" message contains an undefined Product Definition
                //                    Template.
                //                6 = memory allocation error
                //
                // REMARKS: 
                //
                // ATTRIBUTES:
                //   LANGUAGE: C
                //   MACHINE:  
                //
                //$$$//
          17 -> {
                
                      g2int ierr,needext,i,j,nbits,isecnum;
                      g2int lensec,isign,newlen;
                      g2int *coordieee;
                      g2int *lipdstmpl=0;
                      g2float *lcoordlist;
                      gtemplate *mappds;
                
                      ierr=0;
                      *ipdstmpl=0;    // NULL
                      *coordlist=0;    // NULL
                
                      gbit(cgrib,&lensec,*iofst,32);        // Get Length of Section
                      *iofst=*iofst+32;
                      gbit(cgrib,&isecnum,*iofst,8);         // Get Section Number
                      *iofst=*iofst+8;
                
                      if ( isecnum != 4 ) {
                         ierr=2;
                         *numcoord=0;
                         *mappdslen=0;
                        // fprintf(stderr,"g2_unpack4: Not Section 4 data.\n");
                         return(ierr);
                      }
                
                      gbit(cgrib,numcoord,*iofst,16);    // Get num of coordinate values
                      *iofst=*iofst+16;
                      gbit(cgrib,ipdsnum,*iofst,16);    // Get Prod. Def Template num.
                      *iofst=*iofst+16;
                
                      //   Get Product Definition Template
                      mappds=getpdstemplate(*ipdsnum);
                      if (mappds == 0) {       // undefine template
                        ierr=5;
                        *mappdslen=0;
                        return(ierr);
                      }
                      *mappdslen=mappds->maplen;
                      needext=mappds->needext;
                      //
                      //   Unpack each value into array ipdstmpl from the
                      //   the appropriate number of octets, which are specified in
                      //   corresponding entries in array mappds.
                      //
                      if (*mappdslen > 0) lipdstmpl=(g2int *)calloc(*mappdslen,sizeof(g2int));
                      if (lipdstmpl == 0) {
                         ierr=6;
                         *mappdslen=0;
                         *ipdstmpl=0;     //NULL
                         if ( mappds != 0 ) free(mappds);
                         return(ierr);
                      }
                      else {
                         *ipdstmpl=lipdstmpl;
                      }
                      for (i=0;i<mappds->maplen;i++) {
                        nbits=abs(mappds->map[i])*8;
                        if ( mappds->map[i] >= 0 ) {
                          gbit(cgrib,lipdstmpl+i,*iofst,nbits);
                        }
                        else {
                          gbit(cgrib,&isign,*iofst,1);
                          gbit(cgrib,lipdstmpl+i,*iofst+1,nbits-1);
                          if (isign == 1) lipdstmpl[i]=-1*lipdstmpl[i];
                        }
                        *iofst=*iofst+nbits;
                      }
                      //
                      //   Check to see if the Product Definition Template needs to be
                      //   extended.
                      //   The number of values in a specific template may vary
                      //   depending on data specified in the "static" part of the
                      //   gtemplate.
                      //
                      if ( needext ==1 ) {
                        free(mappds);
                        mappds=extpdstemplate(*ipdsnum,lipdstmpl);
                        newlen=mappds->maplen+mappds->extlen;
                        lipdstmpl=(g2int *)realloc(lipdstmpl,newlen*sizeof(g2int));
                        *ipdstmpl=lipdstmpl;
                        //   Unpack the rest of the Product Definition Template
                        j=0;
                        for (i=*mappdslen;i<newlen;i++) {
                          nbits=abs(mappds->ext[j])*8;
                          if ( mappds->ext[j] >= 0 ) {
                            gbit(cgrib,lipdstmpl+i,*iofst,nbits);
                          }
                          else {
                            gbit(cgrib,&isign,*iofst,1);
                            gbit(cgrib,lipdstmpl+i,*iofst+1,nbits-1);
                            if (isign == 1) lipdstmpl[i]=-1*lipdstmpl[i];
                          }
                          *iofst=*iofst+nbits;
                          j++;
                        }
                        *mappdslen=newlen;
                      }
                      if( mappds->ext != 0 ) free(mappds->ext);
                      if( mappds != 0 ) free(mappds);
                      //
                      //   Get Optional list of vertical coordinate values
                      //   after the Product Definition Template, if necessary.
                      //
                      *coordlist=0;    // NULL
                      if ( *numcoord != 0 ) {
                         coordieee=(g2int *)calloc(*numcoord,sizeof(g2int));
                         lcoordlist=(g2float *)calloc(*numcoord,sizeof(g2float));
                         if (coordieee == 0 || lcoordlist == 0) {
                            ierr=6;
                            *numcoord=0;
                            *coordlist=0;    // NULL
                            if( coordieee != 0 ) free(coordieee);
                            if( lcoordlist != 0 ) free(lcoordlist);
                            return(ierr);
                         }
                         else {
                            *coordlist=lcoordlist;
                         }
                        gbits(cgrib,coordieee,*iofst,32,0,*numcoord);
                        rdieee(coordieee,*coordlist,*numcoord);
                        free(coordieee);
                        *iofst=*iofst+(32*(*numcoord));
                      }
                      
                      return(ierr);    // End of Section 4 processing
                
                }


Top 10 Lines:

     Line      Count

       58         17

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       17   Total number of line executions
    17.00   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/g2clib-1.1.8/rdieee.c:
                #include "grib2.h"
                
                void rdieee(g2int *rieee,g2float *a,g2int num)
                //$$$  SUBPROGRAM DOCUMENTATION BLOCK
                //                .      .    .                                       .
                // SUBPROGRAM:    rdieee 
                //   PRGMMR: Gilbert         ORG: W/NP11    DATE: 2002-10-25
                //
                // ABSTRACT: This subroutine reads a list of real values in 
                //   32-bit IEEE floating point format.
                //
                // PROGRAM HISTORY LOG:
                // 2002-10-25  Gilbert
                //
                // USAGE:    void rdieee(g2int *rieee,g2float *a,g2int num)
                //   INPUT ARGUMENT LIST:
                //     rieee    - g2int array of floating point values in 32-bit IEEE format.
                //     num      - Number of floating point values to convert.
                //
                //   OUTPUT ARGUMENT LIST:      
                //     a        - float array of real values.  a must be allocated with at
                //                least 4*num bytes of memory before calling this function.
                //
                // REMARKS: None
                //
                // ATTRIBUTES:
                //   LANGUAGE: C
                //   MACHINE:  IBM SP
                //
                //$$$
          17 -> {
                
                      g2int  j;
                      g2int  isign,iexp,imant;
                
                      g2float  sign,temp;
                      static g2float  two23,two126;
                      static g2int test=0;
                      g2intu msk1=0x80000000;        // 10000000000000000000000000000000 binary
                      g2int msk2=0x7F800000;         // 01111111100000000000000000000000 binary
                      g2int msk3=0x007FFFFF;         // 00000000011111111111111111111111 binary
                
                      if ( test == 0 ) {
                         two23=(g2float)int_power(2.0,-23);
                         two126=(g2float)int_power(2.0,-126);
                         test=1;
                      }
                
                      for (j=0;j<num;j++) {
                //
                //  Extract sign bit, exponent, and mantissa
                //
                        isign=(rieee[j]&msk1)>>31;
                        iexp=(rieee[j]&msk2)>>23;
                        imant=(rieee[j]&msk3);
                        //printf("SAGieee= %ld %ld %ld\n",isign,iexp,imant);
                
                        sign=1.0;
                        if (isign == 1) sign=-1.0;
                        
                        if ( (iexp > 0) && (iexp < 255) ) {
                          temp=(g2float)int_power(2.0,(iexp-127));
                          a[j]=sign*temp*(1.0+(two23*(g2float)imant));
                        }
                        else if ( iexp == 0 ) {
                          if ( imant != 0 )
                            a[j]=sign*two126*two23*(g2float)imant;
                          else
                            a[j]=sign*0.0;
                          
                        }
                        else if ( iexp == 255 )
                           a[j]=sign*(1E+37);
                
                
                      }
                
                }


Top 10 Lines:

     Line      Count

       31         17

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       17   Total number of line executions
    17.00   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/earth.c:
                #include <stdio.h>
                #include "grb2.h"
                #include "wgrib2.h"
                #include "fnlist.h"
                
                /* function to return the size of the earth */
                
           1 -> double radius_earth(unsigned char **sec) {
                    int table_3_2;
                    double radius;
                    unsigned char *p;
                    int factor, value;
                
                    p = code_table_3_2_location(sec);
                    table_3_2 = (int) *p;
                
                    /* set a default value .. not sure what to do with most values */
                    radius = 6367.47 *1000.0;
                    if (table_3_2 == 0) radius = 6367.47 * 1000.0;
                    else if (table_3_2 == 1)  {
                	factor = p[1];
                	value = uint4(p+2);
                	radius = scaled2dbl(factor, value);
                	if (radius < 6300000.0 || radius > 6400000.0) 
                	   fatal_error_i("radius of earth is %d m", (int) radius);
                    }
                    else if (table_3_2 == 2)  radius = (6378.160 + 6356.775)*0.5 * 1000.0;
                    else if (table_3_2 == 3) {
                	/* get major axis */
                	factor = p[6];
                	value = uint4(p+7);
                	radius = scaled2dbl(factor, value);
                	/* get minor axis */
                	factor = p[11];
                	value = uint4(p+12);
                	radius = (radius + scaled2dbl(factor, value)) * 0.5;
                        if (radius < 6300000.0 || radius > 6400000.0) 
                	   fatal_error_i("radius of earth is %d m", (int) radius);
                    }
                    else if (table_3_2 == 4)  radius = (6378.137 + 6356.772)*0.5 * 1000.0;
                    else if (table_3_2 == 6)  radius = 6371.2290 * 1000.0;
                    else if (table_3_2 == 8)  radius = 6371.200 * 1000.0;
                    return radius;
                }
                


Top 10 Lines:

     Line      Count

        8          1

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     1.00   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/g2clib-1.1.8/g2_unpack7.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include <memory.h>
                #include <string.h>
                #include "grib2.h"
                
                g2int simunpack(unsigned char *,g2int *, g2int,g2float *);
                int comunpack(unsigned char *,g2int,g2int,g2int *,g2int,g2float *);
                g2int specunpack(unsigned char *,g2int *,g2int,g2int,g2int, g2int, g2float *);
                #ifdef USE_PNG
                  g2int pngunpack(unsigned char *,g2int,g2int *,g2int, g2float *);
                #endif  /* USE_PNG */
                #ifdef USE_JPEG2000
                  g2int jpcunpack(unsigned char *,g2int,g2int *,g2int, g2float *);
                #endif  /* USE_JPEG2000 */
                
                g2int g2_unpack7(unsigned char *cgrib,g2int *iofst,g2int igdsnum,g2int *igdstmpl,
                               g2int idrsnum,g2int *idrstmpl,g2int ndpts,g2float **fld)
                //$$$  SUBPROGRAM DOCUMENTATION BLOCK
                //                .      .    .                                       .
                // SUBPROGRAM:    g2_unpack7 
                //   PRGMMR: Gilbert         ORG: W/NP11    DATE: 2002-10-31
                //
                // ABSTRACT: This subroutine unpacks Section 7 (Data Section)
                //           as defined in GRIB Edition 2.
                //
                // PROGRAM HISTORY LOG:
                // 2002-10-31  Gilbert
                // 2002-12-20  Gilbert - Added GDT info to arguments
                //                       and added 5.51 processing.
                // 2003-08-29  Gilbert  - Added support for new templates using
                //                        PNG and JPEG2000 algorithms/templates.
                // 2004-11-29  Gilbert  - JPEG2000 now allowed to use WMO Template no. 5.40
                //                        PNG now allowed to use WMO Template no. 5.41
                // 2004-12-16  Taylor   - Added check on comunpack return code.
                // 2008-12-23  Wesley   - Initialize Number of data points unpacked
                //
                // USAGE:    int g2_unpack7(unsigned char *cgrib,g2int *iofst,g2int igdsnum,
                //                          g2int *igdstmpl, g2int idrsnum,
                //                          g2int *idrstmpl, g2int ndpts,g2float **fld)
                //   INPUT ARGUMENTS:
                //     cgrib    - char array containing Section 7 of the GRIB2 message
                //     iofst    - Bit offset of the beginning of Section 7 in cgrib.
                //     igdsnum  - Grid Definition Template Number ( see Code Table 3.0)
                //                ( Only used for DRS Template 5.51 )
                //     igdstmpl - Pointer to an integer array containing the data values for
                //                the specified Grid Definition
                //                Template ( N=igdsnum ).  Each element of this integer
                //                array contains an entry (in the order specified) of Grid
                //                Definition Template 3.N
                //                ( Only used for DRS Template 5.51 )
                //     idrsnum  - Data Representation Template Number ( see Code Table 5.0)
                //     idrstmpl - Pointer to an integer array containing the data values for
                //                the specified Data Representation
                //                Template ( N=idrsnum ).  Each element of this integer
                //                array contains an entry (in the order specified) of Data
                //                Representation Template 5.N
                //     ndpts    - Number of data points unpacked and returned.
                //
                //   OUTPUT ARGUMENTS:      
                //     iofst    - Bit offset at the end of Section 7, returned.
                //     fld      - Pointer to a float array containing the unpacked data field.
                //
                //   RETURN VALUES:
                //     ierr     - Error return code.
                //                0 = no error
                //                2 = Not section 7
                //                4 = Unrecognized Data Representation Template
                //                5 = need one of GDT 3.50 through 3.53 to decode DRT 5.51
                //                6 = memory allocation error
                //                7 = corrupt section 7.
                //
                // REMARKS: None
                //
                // ATTRIBUTES:
                //   LANGUAGE: C
                //   MACHINE:
                //
                //$$$//
          17 -> {
                      g2int ierr,isecnum;
                      g2int ipos,lensec;
                      g2float *lfld;
                
                      ierr=0;
                      *fld=0;     //NULL
                
                      gbit(cgrib,&lensec,*iofst,32);        // Get Length of Section
                      *iofst=*iofst+32;    
                      gbit(cgrib,&isecnum,*iofst,8);         // Get Section Number
                      *iofst=*iofst+8;
                
                      if ( isecnum != 7 ) {
                         ierr=2;
                         //fprintf(stderr,"g2_unpack7: Not Section 7 data.\n");
                         return(ierr);
                      }
                
                      ipos=(*iofst/8);
                      lfld=(g2float *)calloc(ndpts ? ndpts : 1,sizeof(g2float));
                      if (lfld == 0) {
                         ierr=6;
                         return(ierr);
                      }
                      else {
                         *fld=lfld;
                      }
                
                      if (idrsnum == 0) 
                        simunpack(cgrib+ipos,idrstmpl,ndpts,lfld);
                      else if (idrsnum == 2 || idrsnum == 3) {
                        if (comunpack(cgrib+ipos,lensec,idrsnum,idrstmpl,ndpts,lfld) != 0) {
                          return 7;
                        }
                      }
                      else if (idrsnum == 50) {            // Spectral Simple
                        simunpack(cgrib+ipos,idrstmpl,ndpts-1,lfld+1);
                        rdieee(idrstmpl+4,lfld+0,1);
                      }
                      else if (idrsnum == 51)              //  Spectral complex
                        if ( igdsnum>=50 && igdsnum <=53 ) 
                          specunpack(cgrib+ipos,idrstmpl,ndpts,igdstmpl[0],igdstmpl[2],igdstmpl[2],lfld);
                        else {
                          fprintf(stderr,"g2_unpack7: Cannot use GDT 3.%d to unpack Data Section 5.51.\n",(int)igdsnum);
                          ierr=5;
                          if ( lfld != 0 ) free(lfld);
                          *fld=0;     //NULL
                          return(ierr);
                        }
                #ifdef USE_JPEG2000
                      else if (idrsnum == 40 || idrsnum == 40000) {
                        jpcunpack(cgrib+ipos,lensec-5,idrstmpl,ndpts,lfld);
                        }
                #endif  /* USE_JPEG2000 */
                #ifdef USE_PNG
                      else if (idrsnum == 41 || idrsnum == 40010) {
                        pngunpack(cgrib+ipos,lensec-5,idrstmpl,ndpts,lfld);
                        }
                #endif  /* USE_PNG */
                      else {
                        fprintf(stderr,"g2_unpack7: Data Representation Template 5.%d not yet implemented.\n",(int)idrsnum);
                        ierr=4;
                        if ( lfld != 0 ) free(lfld);
                        *fld=0;     //NULL
                        return(ierr);
                      }
                
                      *iofst=*iofst+(8*lensec);
                      
                      return(ierr);    // End of Section 7 processing
                
                }


Top 10 Lines:

     Line      Count

       80         17

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       17   Total number of line executions
    17.00   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/g2clib-1.1.8/g2_unpack3.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include "grib2.h"
                
                
                g2int g2_unpack3(unsigned char *cgrib,g2int *iofst,g2int **igds,g2int **igdstmpl,
                                         g2int *mapgridlen,g2int **ideflist,g2int *idefnum)
                ////$$$  SUBPROGRAM DOCUMENTATION BLOCK
                //                .      .    .                                       .
                // SUBPROGRAM:    g2_unpack3 
                //   PRGMMR: Gilbert         ORG: W/NP11    DATE: 2002-10-31
                //
                // ABSTRACT: This routine unpacks Section 3 (Grid Definition Section)
                //           as defined in GRIB Edition 2.
                //
                // PROGRAM HISTORY LOG:
                // 2002-10-31  Gilbert
                // 2009-01-14  Vuong     Changed structure name template to gtemplate
                //
                // USAGE:    int g2_unpack3(unsigned char *cgrib,g2int *iofst,g2int **igds,
                //                          g2int **igdstmpl,g2int *mapgridlen,
                //                          g2int **ideflist,g2int *idefnum)
                //   INPUT ARGUMENTS:
                //     cgrib    - Char array ontaining Section 3 of the GRIB2 message
                //     iofst    - Bit offset for the beginning of Section 3 in cgrib.
                //
                //   OUTPUT ARGUMENTS:      
                //     iofst    - Bit offset at the end of Section 3, returned.
                //     igds     - Contains information read from the appropriate GRIB Grid 
                //                Definition Section 3 for the field being returned.
                //                igds[0]=Source of grid definition (see Code Table 3.0)
                //                igds[1]=Number of grid points in the defined grid.
                //                igds[2]=Number of octets needed for each 
                //                            additional grid points definition.  
                //                            Used to define number of
                //                            points in each row ( or column ) for
                //                            non-regular grids.  
                //                            = 0, if using regular grid.
                //                igds[3]=Interpretation of list for optional points 
                //                            definition.  (Code Table 3.11)
                //                igds[4]=Grid Definition Template Number (Code Table 3.1)
                //     igdstmpl - Pointer to integer array containing the data values for 
                //                the specified Grid Definition
                //                Template ( NN=igds[4] ).  Each element of this integer 
                //                array contains an entry (in the order specified) of Grid
                //                Defintion Template 3.NN
                //     mapgridlen- Number of elements in igdstmpl[].  i.e. number of entries
                //                in Grid Defintion Template 3.NN  ( NN=igds[4] ).
                //     ideflist - (Used if igds[2] .ne. 0)  Pointer to integer array containing
                //                the number of grid points contained in each row ( or column ).
                //                (part of Section 3)
                //     idefnum  - (Used if igds[2] .ne. 0)  The number of entries
                //                in array ideflist.  i.e. number of rows ( or columns )
                //                for which optional grid points are defined.
                //     ierr     - Error return code.
                //                0 = no error
                //                2 = Not Section 3
                //                5 = "GRIB" message contains an undefined Grid Definition
                //                    Template.
                //                6 = memory allocation error
                //
                // REMARKS: 
                //
                // ATTRIBUTES:
                //   LANGUAGE: C
                //   MACHINE:
                //
                //$$$
                
          17 -> {
                      g2int ierr,i,j,nbits,isecnum;
                      g2int lensec,ibyttem=0,isign,newlen;
                      g2int *ligds,*ligdstmpl=0,*lideflist=0;
                      gtemplate *mapgrid;
                
                      ierr=0;
                      *igds=0;       // NULL
                      *igdstmpl=0;       // NULL
                      *ideflist=0;       // NULL
                
                      gbit(cgrib,&lensec,*iofst,32);        // Get Length of Section
                      *iofst=*iofst+32;
                      gbit(cgrib,&isecnum,*iofst,8);         // Get Section Number
                      *iofst=*iofst+8;
                
                      if ( isecnum != 3 ) {
                         ierr=2;
                         *idefnum=0;
                         *mapgridlen=0;
                        // fprintf(stderr,"g2_unpack3: Not Section 3 data.\n");
                         return(ierr);
                      }
                
                      ligds=(g2int *)calloc(5,sizeof(g2int));
                      *igds=ligds;
                
                      gbit(cgrib,ligds+0,*iofst,8);     // Get source of Grid def.
                      *iofst=*iofst+8;
                      gbit(cgrib,ligds+1,*iofst,32);    // Get number of grid pts.
                      *iofst=*iofst+32;
                      gbit(cgrib,ligds+2,*iofst,8);     // Get num octets for opt. list
                      *iofst=*iofst+8;
                      gbit(cgrib,ligds+3,*iofst,8);     // Get interpret. for opt. list
                      *iofst=*iofst+8;
                      gbit(cgrib,ligds+4,*iofst,16);    // Get Grid Def Template num.
                      *iofst=*iofst+16;
                
                      if (ligds[4] != 65535) {
                        //   Get Grid Definition Template
                        mapgrid=getgridtemplate(ligds[4]);
                        if (mapgrid == 0) {         // undefined template
                          ierr=5;
                          return(ierr);
                        }
                        *mapgridlen=mapgrid->maplen;
                        //
                        //   Unpack each value into array igdstmpl from the
                        //   the appropriate number of octets, which are specified in
                        //   corresponding entries in array mapgrid.
                        //
                        if (*mapgridlen > 0) {
                           ligdstmpl=0;
                           ligdstmpl=(g2int *)calloc(*mapgridlen,sizeof(g2int));
                           if (ligdstmpl == 0) {
                              ierr=6;
                              *mapgridlen=0;
                              *igdstmpl=0;    //NULL
                              if( mapgrid != 0 ) free(mapgrid);
                              return(ierr);
                           }
                           else {
                              *igdstmpl=ligdstmpl;
                           }
                        }
                        ibyttem=0;
                        for (i=0;i<*mapgridlen;i++) {
                          nbits=abs(mapgrid->map[i])*8;
                          if ( mapgrid->map[i] >= 0 ) {
                            gbit(cgrib,ligdstmpl+i,*iofst,nbits);
                          }
                          else {
                            gbit(cgrib,&isign,*iofst,1);
                            gbit(cgrib,ligdstmpl+i,*iofst+1,nbits-1);
                            if (isign == 1) ligdstmpl[i]=-1*ligdstmpl[i];
                          }
                          *iofst=*iofst+nbits;
                          ibyttem=ibyttem+abs(mapgrid->map[i]);
                        }
                        //
                        //   Check to see if the Grid Definition Template needs to be
                        //   extended.
                        //   The number of values in a specific template may vary
                        //   depending on data specified in the "static" part of the
                        //   gtemplate.
                        //
                        if ( mapgrid->needext == 1 ) {
                          free(mapgrid);
                          mapgrid=extgridtemplate(ligds[4],ligdstmpl);
                          //   Unpack the rest of the Grid Definition Template
                          newlen=mapgrid->maplen+mapgrid->extlen;
                          ligdstmpl=(g2int *)realloc(ligdstmpl,newlen*sizeof(g2int));
                          *igdstmpl=ligdstmpl;
                          j=0;
                          for (i=*mapgridlen;i<newlen;i++) {
                            nbits=abs(mapgrid->ext[j])*8;
                            if ( mapgrid->ext[j] >= 0 ) {
                              gbit(cgrib,ligdstmpl+i,*iofst,nbits);
                            }
                            else {
                              gbit(cgrib,&isign,*iofst,1);
                              gbit(cgrib,ligdstmpl+i,*iofst+1,nbits-1);
                              if (isign == 1) ligdstmpl[i]=-1*ligdstmpl[i];
                            }
                            *iofst=*iofst+nbits;
                            ibyttem=ibyttem+abs(mapgrid->ext[j]);
                            j++;
                          }
                          *mapgridlen=newlen;
                        }
                        if( mapgrid->ext != 0 ) free(mapgrid->ext);
                        if( mapgrid != 0 ) free(mapgrid);
                      }
                      else {              // No Grid Definition Template
                        *mapgridlen=0;
                        *igdstmpl=0;
                      }
                      //
                      //   Unpack optional list of numbers defining number of points
                      //   in each row or column, if included.  This is used for non regular
                      //   grids.
                      //
                      if ( ligds[2] != 0 ) {
                         nbits=ligds[2]*8;
                         *idefnum=(lensec-14-ibyttem)/ligds[2];
                         if (*idefnum > 0) lideflist=(g2int *)calloc(*idefnum,sizeof(g2int));
                         if (lideflist == 0) {
                            ierr=6;
                            *idefnum=0;
                            *ideflist=0;   //NULL
                            return(ierr);
                         }
                         else {
                            *ideflist=lideflist;
                         }
                         gbits(cgrib,lideflist,*iofst,nbits,0,*idefnum);
                         *iofst=*iofst+(nbits*(*idefnum));
                      }
                      else {
                         *idefnum=0;
                         *ideflist=0;    // NULL
                      }
                      
                      return(ierr);    // End of Section 3 processing
                }


Top 10 Lines:

     Line      Count

       70         17

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       17   Total number of line executions
    17.00   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/my_parallel.c:
                #include <stdio.h>
                #include <mpi.h>
                
                #include "my_parallel.h"
                
                void set_hyperslab(size_t *count, size_t *offset, size_t *dimlens, int ndims)
                
          20 -> {
                
                	int size, rank;
                
                	int i, cnt;
                
                
                
                	MPI_Comm_size(MPI_COMM_WORLD, &size);
                
                	MPI_Comm_rank(MPI_COMM_WORLD, &rank);
                
                
                
                	/* the dimlen is not the multiples of size of processes */
                
                	if((dimlens[0] % size) != 0){
                
                		cnt = dimlens[0] / size;
                
                		if(cnt == 0){
                
                			count[0] = 1;
                
                			offset[0] = (rank * count[0]) % dimlens[0];
                
                		}
                
                		else{
                
                			cnt += 1;
                
                			if(((size - 1) * cnt) < dimlens[0]){
                
                				if((cnt * (rank + 1)) <= dimlens[0] )
                
                					count[0] = cnt;
                
                				else
                
                					count[0] = dimlens[0] - cnt * rank;
                
                				offset[0] = rank * cnt;
                
                			}
                
                			else{
                
                				if(rank != (size - 1)){
                
                					count[0] = cnt - 1;
                
                				}
                
                				else{ 
                
                					count[0] = dimlens[0] - rank * (cnt - 1);
                
                				}
                
                				offset[0] = rank * (cnt - 1);
                
                			}
                
                		}
                
                	
                
                	}
                
                	else {
                
                		count[0] = dimlens[0] / size;
                
                		offset[0] = rank * count[0];
                
                	}
                
                	printf("process %d, offset[0] = %d, count[0] = %d\n",
                
                				rank, offset[0], count[0]);
                
                	for(i = 1; i < ndims; i++){
                
                		count[i] = dimlens[i];
                
                		offset[i] = 0;
                
                		printf("process %d, offset[%d] = %d, count[%d] = %d\n",
                
                				rank, i, offset[i], i, count[i]);
                
                	}
                
                
                
                }


Top 10 Lines:

     Line      Count

        8         20

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       20   Total number of line executions
    20.00   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/g2clib-1.1.8/simunpack.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include "grib2.h"
                
                
                g2int simunpack(unsigned char *cpack,g2int *idrstmpl,g2int ndpts,g2float *fld)
                ////$$$  SUBPROGRAM DOCUMENTATION BLOCK
                //                .      .    .                                       .
                // SUBPROGRAM:    simunpack
                //   PRGMMR: Gilbert          ORG: W/NP11    DATE: 2002-10-29
                //
                // ABSTRACT: This subroutine unpacks a data field that was packed using a 
                //   simple packing algorithm as defined in the GRIB2 documention,
                //   using info from the GRIB2 Data Representation Template 5.0.
                //
                // PROGRAM HISTORY LOG:
                // 2002-10-29  Gilbert
                //
                // USAGE:    int simunpack(unsigned char *cpack,g2int *idrstmpl,g2int ndpts,
                //                         g2float *fld)
                //   INPUT ARGUMENT LIST:
                //     cpack    - pointer to the packed data field.
                //     idrstmpl - pointer to the array of values for Data Representation
                //                Template 5.0
                //     ndpts    - The number of data values to unpack
                //
                //   OUTPUT ARGUMENT LIST:
                //     fld      - Contains the unpacked data values.  fld must be allocated
                //                with at least ndpts*sizeof(g2float) bytes before
                //                calling this routine.
                //
                // REMARKS: None
                //
                // ATTRIBUTES:
                //   LANGUAGE: C
                //   MACHINE:  
                //
                //$$$//
          17 -> {
                
                      g2int  *ifld;
                      g2int  j,nbits,itype;
                      g2float ref,bscale,dscale;
                
                      
                      rdieee(idrstmpl+0,&ref,1);
                      bscale = int_power(2.0,idrstmpl[1]);
                      dscale = int_power(10.0,-idrstmpl[2]);
                      nbits = idrstmpl[3];
                      itype = idrstmpl[4];
                
                      ifld=(g2int *)calloc(ndpts,sizeof(g2int));
                      if ( ifld == 0 ) {
                         fprintf(stderr,"Could not allocate space in simunpack.\n  Data field NOT upacked.\n");
                         return(1);
                      }
                      
                //
                //  if nbits equals 0, we have a constant field where the reference value
                //  is the data value at each gridpoint
                //
                      if (nbits != 0) {
                         gbits(cpack,ifld,0,nbits,0,ndpts);
                         for (j=0;j<ndpts;j++) {
                           fld[j]=(((g2float)ifld[j]*bscale)+ref)*dscale;
                         }
                      }
                      else {
                         for (j=0;j<ndpts;j++) {
                           fld[j]=ref;
                         }
                      }
                
                      free(ifld);
                      return(0);
                }


Top 10 Lines:

     Line      Count

       39         17

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       17   Total number of line executions
    17.00   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/g2clib-1.1.8/g2_getfld.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include "grib2.h"
                
                g2int g2_unpack1(unsigned char *,g2int *,g2int **,g2int *);
                g2int g2_unpack2(unsigned char *,g2int *,g2int *,unsigned char **);
                g2int g2_unpack3(unsigned char *,g2int *,g2int **,g2int **,
                                         g2int *,g2int **,g2int *);
                g2int g2_unpack4(unsigned char *,g2int *,g2int *,g2int **,
                                         g2int *,g2float **,g2int *);
                g2int g2_unpack5(unsigned char *,g2int *,g2int *,g2int *, g2int **,g2int *);
                g2int g2_unpack6(unsigned char *,g2int *,g2int ,g2int *, g2int **);
                g2int g2_unpack7(unsigned char *,g2int *,g2int ,g2int *,
                                         g2int ,g2int *,g2int ,g2float **);
                
                g2int g2_getfld(unsigned char *cgrib,g2int ifldnum,g2int unpack,g2int expand,
                                gribfield **gfld)
                //$$$  SUBPROGRAM DOCUMENTATION BLOCK
                //                .      .    .                                       .
                // SUBPROGRAM:    g2_getfld 
                //   PRGMMR: Gilbert         ORG: W/NP11    DATE: 2002-10-28
                //
                // ABSTRACT: This subroutine returns all the metadata, template values, 
                //   Bit-map ( if applicable ), and the unpacked data for a given data
                //   field.  All of the information returned is stored in a gribfield
                //   structure, which is defined in file grib2.h.
                //   Users of this routine will need to include "grib2.h" in their source
                //   code that calls this routine.  Each component of the gribfield
                //   struct is also described in the OUTPUT ARGUMENTS section below.
                //
                //   Since there can be multiple data fields packed into a GRIB2
                //   message, the calling routine indicates which field is being requested
                //   with the ifldnum argument.
                //
                // PROGRAM HISTORY LOG:
                // 2002-10-28  Gilbert
                //
                // USAGE:    #include "grib2.h"
                //           int g2_getfld(unsigned char *cgrib,g2int ifldnum,g2int unpack,
                //                         g2int expand,gribfield **gfld)
                //   INPUT ARGUMENTS:
                //     cgrib    - Character pointer to the GRIB2 message
                //     ifldnum  - Specifies which field in the GRIB2 message to return.
                //     unpack   - Boolean value indicating whether to unpack bitmap/data field
                //                1 = unpack bitmap (if present) and data values
                //                0 = do not unpack bitmap and data values
                //     expand   - Boolean value indicating whether the data points should be 
                //                expanded to the correspond grid, if a bit-map is present.
                //                1 = if possible, expand data field to grid, inserting zero 
                //                    values at gridpoints that are bitmapped out. 
                //                    (SEE REMARKS2)
                //                0 = do not expand data field, leaving it an array of
                //                    consecutive data points for each "1" in the bitmap.
                //                This argument is ignored if unpack == 0 OR if the
                //                returned field does not contain a bit-map.
                //
                //   OUTPUT ARGUMENT:      
                //     gribfield gfld; - pointer to structure gribfield containing
                //                       all decoded data for the data field.
                // 
                //        gfld->version = GRIB edition number ( currently 2 )
                //        gfld->discipline = Message Discipline ( see Code Table 0.0 )
                //        gfld->idsect = Contains the entries in the Identification
                //                        Section ( Section 1 )
                //                        This element is a pointer to an array
                //                        that holds the data.
                //            gfld->idsect[0]  = Identification of originating Centre
                //                                    ( see Common Code Table C-1 )
                //                             7 - US National Weather Service
                //            gfld->idsect[1]  = Identification of originating Sub-centre
                //            gfld->idsect[2]  = GRIB Master Tables Version Number
                //                                    ( see Code Table 1.0 )
                //                             0 - Experimental
                //                             1 - Initial operational version number
                //            gfld->idsect[3]  = GRIB Local Tables Version Number
                //                                    ( see Code Table 1.1 )
                //                             0     - Local tables not used
                //                             1-254 - Number of local tables version used
                //            gfld->idsect[4]  = Significance of Reference Time (Code Table 1.2)
                //                             0 - Analysis
                //                             1 - Start of forecast
                //                             2 - Verifying time of forecast
                //                             3 - Observation time
                //            gfld->idsect[5]  = Year ( 4 digits )
                //            gfld->idsect[6]  = Month
                //            gfld->idsect[7)  = Day
                //            gfld->idsect[8]  = Hour
                //            gfld->idsect[9]  = Minute
                //            gfld->idsect[10]  = Second
                //            gfld->idsect[11]  = Production status of processed data
                //                                    ( see Code Table 1.3 )
                //                              0 - Operational products
                //                              1 - Operational test products
                //                              2 - Research products
                //                              3 - Re-analysis products
                //            gfld->idsect[12]  = Type of processed data ( see Code Table 1.4 )
                //                              0  - Analysis products
                //                              1  - Forecast products
                //                              2  - Analysis and forecast products
                //                              3  - Control forecast products
                //                              4  - Perturbed forecast products
                //                              5  - Control and perturbed forecast products
                //                              6  - Processed satellite observations
                //                              7  - Processed radar observations
                //        gfld->idsectlen = Number of elements in gfld->idsect[].
                //        gfld->local   = Pointer to character array containing contents
                //                       of Local Section 2, if included
                //        gfld->locallen = length of array gfld->local[]
                //        gfld->ifldnum = field number within GRIB message
                //        gfld->griddef = Source of grid definition (see Code Table 3.0)
                //                      0 - Specified in Code table 3.1
                //                      1 - Predetermined grid Defined by originating centre
                //        gfld->ngrdpts = Number of grid points in the defined grid.
                //        gfld->numoct_opt = Number of octets needed for each
                //                          additional grid points definition.
                //                          Used to define number of
                //                          points in each row ( or column ) for
                //                          non-regular grids.
                //                          = 0, if using regular grid.
                //        gfld->interp_opt = Interpretation of list for optional points
                //                          definition.  (Code Table 3.11)
                //        gfld->igdtnum = Grid Definition Template Number (Code Table 3.1)
                //        gfld->igdtmpl  = Contains the data values for the specified Grid
                //                         Definition Template ( NN=gfld->igdtnum ).  Each
                //                         element of this integer array contains an entry (in
                //                         the order specified) of Grid Defintion Template 3.NN
                //                         This element is a pointer to an array
                //                         that holds the data.
                //        gfld->igdtlen = Number of elements in gfld->igdtmpl[].  i.e. number of
                //                       entries in Grid Defintion Template 3.NN
                //                       ( NN=gfld->igdtnum ).
                //        gfld->list_opt  = (Used if gfld->numoct_opt .ne. 0)  This array
                //                          contains the number of grid points contained in
                //                          each row ( or column ).  (part of Section 3)
                //                          This element is a pointer to an array
                //                          that holds the data.  This pointer is nullified
                //                          if gfld->numoct_opt=0.
                //        gfld->num_opt = (Used if gfld->numoct_opt .ne. 0) 
                //                        The number of entries
                //                       in array ideflist.  i.e. number of rows ( or columns )
                //                       for which optional grid points are defined.  This value
                //                       is set to zero, if gfld->numoct_opt=0.
                //        gfdl->ipdtnum = Product Definition Template Number(see Code Table 4.0)
                //        gfld->ipdtmpl  = Contains the data values for the specified Product
                //                         Definition Template ( N=gfdl->ipdtnum ). Each element
                //                         of this integer array contains an entry (in the
                //                         order specified) of Product Defintion Template 4.N.
                //                         This element is a pointer to an array
                //                         that holds the data.
                //        gfld->ipdtlen = Number of elements in gfld->ipdtmpl[].  i.e. number of
                //                       entries in Product Defintion Template 4.N
                //                       ( N=gfdl->ipdtnum ).
                //        gfld->coord_list  = Real array containing floating point values
                //                            intended to document the vertical discretisation
                //                            associated to model data on hybrid coordinate
                //                            vertical levels.  (part of Section 4)
                //                            This element is a pointer to an array
                //                            that holds the data.
                //        gfld->num_coord = number of values in array gfld->coord_list[].
                //        gfld->ndpts = Number of data points unpacked and returned.
                //        gfld->idrtnum = Data Representation Template Number
                //                       ( see Code Table 5.0)
                //        gfld->idrtmpl  = Contains the data values for the specified Data
                //                         Representation Template ( N=gfld->idrtnum ).  Each
                //                         element of this integer array contains an entry
                //                         (in the order specified) of Product Defintion
                //                         Template 5.N.
                //                         This element is a pointer to an array
                //                         that holds the data.
                //        gfld->idrtlen = Number of elements in gfld->idrtmpl[].  i.e. number
                //                       of entries in Data Representation Template 5.N
                //                       ( N=gfld->idrtnum ).
                //        gfld->unpacked = logical value indicating whether the bitmap and
                //                        data values were unpacked.  If false,
                //                        gfld->bmap and gfld->fld pointers are nullified.
                //        gfld->expanded = Logical value indicating whether the data field 
                //                         was expanded to the grid in the case where a 
                //                         bit-map is present.  If true, the data points in
                //                         gfld->fld match the grid points and zeros were 
                //                         inserted at grid points where data was bit-mapped
                //                         out.  If false, the data values in gfld->fld were
                //                         not expanded to the grid and are just a consecutive
                //                         array of data points corresponding to each value of
                //                         "1" in gfld->bmap.
                //        gfld->ibmap = Bitmap indicator ( see Code Table 6.0 )
                //                     0 = bitmap applies and is included in Section 6.
                //                     1-253 = Predefined bitmap applies
                //                     254 = Previously defined bitmap applies to this field
                //                     255 = Bit map does not apply to this product.
                //        gfld->bmap  = integer array containing decoded bitmap,
                //                      if gfld->ibmap=0 or gfld->ibap=254.  Otherwise nullified
                //                      This element is a pointer to an array
                //                      that holds the data.
                //        gfld->fld  = Array of gfld->ndpts unpacked data points.
                //                     This element is a pointer to an array
                //                     that holds the data.
                //
                // 
                //   RETURN VALUES:
                //     ierr     - Error return code.
                //                0 = no error
                //                1 = Beginning characters "GRIB" not found.
                //                2 = GRIB message is not Edition 2.
                //                3 = The data field request number was not positive.
                //                4 = End string "7777" found, but not where expected.
                //                6 = GRIB message did not contain the requested number of
                //                    data fields.
                //                7 = End string "7777" not found at end of message.
                //                8 = Unrecognized Section encountered.
                //                9 = Data Representation Template 5.NN not yet implemented.
                //               15 = Error unpacking Section 1.
                //               16 = Error unpacking Section 2.
                //               10 = Error unpacking Section 3.
                //               11 = Error unpacking Section 4.
                //               12 = Error unpacking Section 5.
                //               13 = Error unpacking Section 6.
                //               14 = Error unpacking Section 7.
                //               17 = Previous bitmap specified, yet none exists.
                //
                // REMARKS: Note that struct gribfield is allocated by this routine and it
                //          also contains pointers to many arrays of data that were allocated
                //          during decoding.  Users are encouraged to free up this memory, 
                //          when it is no longer needed, by an explicit call to routine g2_free.
                //          EXAMPLE:
                //              #include "grib2.h"
                //              gribfield *gfld;
                //              ret=g2_getfld(cgrib,1,1,1,&gfld);
                //                ...
                //              g2_free(gfld);
                //
                //          Routine g2_info can be used to first determine
                //          how many data fields exist in a given GRIB message.
                //
                // REMARKS2: It may not always be possible to expand a bit-mapped data field.
                //           If a pre-defined bit-map is used and not included in the GRIB2
                //           message itself, this routine would not have the necessary 
                //           information to expand the data.  In this case, gfld->expanded would
                //           would be set to 0 (false), regardless of the value of input 
                //           argument expand.
                //
                // ATTRIBUTES:
                //   LANGUAGE: C
                //   MACHINE:  
                //
                //$$$
          17 -> {
                    
                      g2int have3,have4,have5,have6,have7,ierr,jerr;
                      g2int numfld,j,n,istart,iofst,ipos;
                      g2int disc,ver,lensec0,lengrib,lensec,isecnum;
                      g2int  *igds;
                      g2int *bmpsave;
                      g2float *newfld;
                      gribfield  *lgfld;
                
                      have3=0;
                      have4=0;
                      have5=0;
                      have6=0;
                      have7=0;
                      ierr=0;
                      numfld=0;
                
                      lgfld=(gribfield *)malloc(sizeof(gribfield));
                      *gfld=lgfld;
                
                      lgfld->locallen=0;
                      lgfld->idsect=0;
                      lgfld->local=0;
                      lgfld->list_opt=0;
                      lgfld->igdtmpl=0;
                      lgfld->ipdtmpl=0;
                      lgfld->idrtmpl=0;
                      lgfld->coord_list=0;
                      lgfld->bmap=0;
                      lgfld->fld=0;
                //
                //  Check for valid request number
                //  
                      if (ifldnum <= 0) {
                        printf("g2_getfld: Request for field number must be positive.\n");
                        ierr=3;
                        return(ierr);
                      }
                //
                //  Check for beginning of GRIB message in the first 100 bytes
                //
                      istart=-1;
                      for (j=0;j<100;j++) {
                        if (cgrib[j]=='G' && cgrib[j+1]=='R' &&cgrib[j+2]=='I' && 
                            cgrib[j+3]=='B') {
                          istart=j;
                          break;
                        }
                      }
                      if (istart == -1) {
                        printf("g2_getfld:  Beginning characters GRIB not found.\n");
                        ierr=1;
                        return(ierr);
                      }
                //
                //  Unpack Section 0 - Indicator Section 
                //
                      iofst=8*(istart+6);
                      gbit(cgrib,&disc,iofst,8);     // Discipline
                      iofst=iofst+8;
                      gbit(cgrib,&ver,iofst,8);     // GRIB edition number
                      iofst=iofst+8;
                      iofst=iofst+32;
                      gbit(cgrib,&lengrib,iofst,32);        // Length of GRIB message
                      iofst=iofst+32;
                      lensec0=16;
                      ipos=istart+lensec0;
                //
                //  Currently handles only GRIB Edition 2.
                //  
                      if (ver != 2) {
                        printf("g2_getfld: can only decode GRIB edition 2.\n");
                        ierr=2;
                        return(ierr);
                      }
                //
                //  Loop through the remaining sections keeping track of the 
                //  length of each.  Also keep the latest Grid Definition Section info.
                //  Unpack the requested field number.
                //
                      for (;;) {
                        //    Check to see if we are at end of GRIB message
                        if (cgrib[ipos]=='7' && cgrib[ipos+1]=='7' && cgrib[ipos+2]=='7' && 
                            cgrib[ipos+3]=='7') {
                          ipos=ipos+4;
                          //    If end of GRIB message not where expected, issue error
                          if (ipos != (istart+lengrib)) {
                            printf("g2_getfld: '7777' found, but not where expected.\n");
                            ierr=4;
                            return(ierr);
                          }
                          break;
                        }
                        //     Get length of Section and Section number
                        iofst=(ipos-1)*8;
                        iofst=ipos*8;
                        gbit(cgrib,&lensec,iofst,32);        // Get Length of Section
                        iofst=iofst+32;
                        gbit(cgrib,&isecnum,iofst,8);         // Get Section number
                        iofst=iofst+8;
                        //printf(" lensec= %ld    secnum= %ld \n",lensec,isecnum);
                        //
                        //  Check to see if section number is valid
                        //
                        if ( isecnum<1 || isecnum>7 ) {
                          printf("g2_getfld: Unrecognized Section Encountered=%ld\n",isecnum);
                          ierr=8;
                          return(ierr);
                        }
                        //
                        //   If found Section 1, decode elements in Identification Section
                        //
                        if (isecnum == 1) {
                          iofst=iofst-40;       // reset offset to beginning of section
                          jerr=g2_unpack1(cgrib,&iofst,&lgfld->idsect,&lgfld->idsectlen);
                          if (jerr !=0 ) {
                            ierr=15;
                            return(ierr);
                          }
                        }
                        //
                        //   If found Section 2, Grab local section
                        //   Save in case this is the latest one before the requested field.
                        //
                        if (isecnum == 2) {
                          iofst=iofst-40;       // reset offset to beginning of section
                          if (lgfld->local!=0) free(lgfld->local);
                          jerr=g2_unpack2(cgrib,&iofst,&lgfld->locallen,&lgfld->local);
                          if (jerr != 0) {
                            ierr=16;
                            return(ierr);
                          }
                        }
                        //
                        //   If found Section 3, unpack the GDS info using the 
                        //   appropriate template.  Save in case this is the latest
                        //   grid before the requested field.
                        //
                        if (isecnum == 3) {
                          iofst=iofst-40;       // reset offset to beginning of section
                          if (lgfld->igdtmpl!=0) free(lgfld->igdtmpl);
                          if (lgfld->list_opt!=0) free(lgfld->list_opt);
                          jerr=g2_unpack3(cgrib,&iofst,&igds,&lgfld->igdtmpl,
                                          &lgfld->igdtlen,&lgfld->list_opt,&lgfld->num_opt);
                          if (jerr == 0) {
                            have3=1;
                            lgfld->griddef=igds[0];
                            lgfld->ngrdpts=igds[1];
                            lgfld->numoct_opt=igds[2];
                            lgfld->interp_opt=igds[3];
                            lgfld->igdtnum=igds[4];
                          }
                          else {
                            ierr=10;
                            return(ierr);
                          }
                        }
                        //
                        //   If found Section 4, check to see if this field is the
                        //   one requested.
                        //
                        if (isecnum == 4) {
                          numfld=numfld+1;
                          if (numfld == ifldnum) {
                            lgfld->discipline=disc;
                            lgfld->version=ver;
                            lgfld->ifldnum=ifldnum;
                            lgfld->unpacked=unpack;
                            lgfld->expanded=0;
                            iofst=iofst-40;       // reset offset to beginning of section
                            jerr=g2_unpack4(cgrib,&iofst,&lgfld->ipdtnum,
                                            &lgfld->ipdtmpl,&lgfld->ipdtlen,&lgfld->coord_list,
                                            &lgfld->num_coord);
                            if (jerr == 0)
                              have4=1;
                            else {
                              ierr=11;
                              return(ierr);
                            }
                          }
                        }
                        //
                        //   If found Section 5, check to see if this field is the
                        //   one requested.
                        //
                        if (isecnum == 5 && numfld == ifldnum) {
                          iofst=iofst-40;       // reset offset to beginning of section
                          jerr=g2_unpack5(cgrib,&iofst,&lgfld->ndpts,&lgfld->idrtnum,
                                          &lgfld->idrtmpl,&lgfld->idrtlen);
                          if (jerr == 0)
                            have5=1;
                          else {
                            ierr=12;
                            return(ierr);
                          }
                        }
                        //
                        //   If found Section 6, Unpack bitmap.
                        //   Save in case this is the latest
                        //   bitmap before the requested field.
                        //
                        if (isecnum == 6) {
                          if (unpack) {   // unpack bitmap
                            iofst=iofst-40;           // reset offset to beginning of section
                            bmpsave=lgfld->bmap;      // save pointer to previous bitmap
                            jerr=g2_unpack6(cgrib,&iofst,lgfld->ngrdpts,&lgfld->ibmap,
                                         &lgfld->bmap);
                            if (jerr == 0) {
                              have6=1;
                              if (lgfld->ibmap == 254)     // use previously specified bitmap
                                 if( bmpsave!=0 ) 
                                    lgfld->bmap=bmpsave;
                                 else {
                                    printf("g2_getfld: Prev bit-map specified, but none exist.\n");
                                    ierr=17;
                                    return(ierr);
                                 }
                              else                         // get rid of it
                                 if( bmpsave!=0 ) free(bmpsave);
                            }
                            else {
                              ierr=13;
                              return(ierr);
                            }
                          }
                          else {    // do not unpack bitmap
                            gbit(cgrib,&lgfld->ibmap,iofst,8);      // Get BitMap Indicator
                            have6=1;
                          }
                        }
                        //
                        //   If found Section 7, check to see if this field is the
                        //   one requested.
                        //
                        if (isecnum==7 && numfld==ifldnum && unpack) {
                          iofst=iofst-40;       // reset offset to beginning of section
                          jerr=g2_unpack7(cgrib,&iofst,lgfld->igdtnum,lgfld->igdtmpl,
                                          lgfld->idrtnum,lgfld->idrtmpl,lgfld->ndpts,
                                          &lgfld->fld);
                          if (jerr == 0) {
                            have7=1;
                            //  If bitmap is used with this field, expand data field 
                            //  to grid, if possible.
                            if ( lgfld->ibmap != 255 && lgfld->bmap != 0 ) {
                               if ( expand == 1 ) {
                                  n=0;
                                  newfld=(g2float *)calloc(lgfld->ngrdpts,sizeof(g2float));
                                  for (j=0;j<lgfld->ngrdpts;j++) {
                                      if (lgfld->bmap[j]==1) newfld[j]=lgfld->fld[n++];
                                  }
                                  free(lgfld->fld);
                                  lgfld->fld=newfld;
                                  lgfld->expanded=1;
                               }
                               else {
                                  lgfld->expanded=0;
                               }
                            }
                            else {
                               lgfld->expanded=1;
                            }
                          }
                          else {
                            printf("g2_getfld: return from g2_unpack7 = %d \n",(int)jerr);
                            ierr=14;
                            return(ierr);
                          }
                        }
                        //
                        //   Check to see if we read pass the end of the GRIB
                        //   message and missed the terminator string '7777'.
                        //
                        ipos=ipos+lensec;                // Update beginning of section pointer
                        if (ipos > (istart+lengrib)) {
                          printf("g2_getfld: '7777'  not found at end of GRIB message.\n");
                          ierr=7;
                          return(ierr);
                        }
                        //
                        //  If unpacking requested, return when all sections have been
                        //  processed
                        //
                        if (unpack && have3 && have4 && have5 && have6 && have7)
                            return(ierr);
                        //
                        //  If unpacking is not requested, return when sections 
                        //  3 through 6 have been processed
                        //
                        if ((! unpack) && have3 && have4 && have5 && have6)
                            return(ierr);
                        
                      }
                
                //
                //  If exited from above loop, the end of the GRIB message was reached
                //  before the requested field was found.
                //
                      printf("g2_getfld: GRIB message contained %ld different fields.\n",numfld);
                      printf("g2_getfld: The request was for field %ld.\n",ifldnum);
                      ierr=6;
                
                      return(ierr);
                
                }


Top 10 Lines:

     Line      Count

      246         17

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       17   Total number of line executions
    17.00   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/g2clib-1.1.8/g2_free.c:
                #include <stdlib.h>
                #include  "grib2.h"
                
                void g2_free(gribfield *gfld)
                //$$$  SUBPROGRAM DOCUMENTATION BLOCK
                //                .      .    .                                       .
                // SUBPROGRAM:    g2_free 
                //   PRGMMR: Gilbert         ORG: W/NP11    DATE: 2002-10-28
                //
                // ABSTRACT: This routine frees up memory that was allocated for
                //   struct gribfield.
                //
                // PROGRAM HISTORY LOG:
                // 2002-10-28  Gilbert
                //
                // USAGE:    g2_free(gribfield *gfld)
                //   ARGUMENT:
                //     gfld - pointer to gribfield structure (defined in include file grib2.h)
                //            returned from routine g2_getfld.
                //
                // REMARKS:  This routine must be called to free up memory used by
                //           the decode routine, g2_getfld, when user no longer needs to
                //           reference this data.
                //
                // ATTRIBUTES:
                //   LANGUAGE: C
                //   MACHINE:  
                //
                //$$$
          17 -> { 
                
                      if (gfld->idsect != 0 ) free(gfld->idsect);
                      if (gfld->local != 0 ) free(gfld->local);
                      if (gfld->list_opt != 0 ) free(gfld->list_opt);
                      if (gfld->igdtmpl != 0 ) free(gfld->igdtmpl);
                      if (gfld->ipdtmpl != 0 ) free(gfld->ipdtmpl);
                      if (gfld->coord_list != 0 ) free(gfld->coord_list);
                      if (gfld->idrtmpl != 0 ) free(gfld->idrtmpl);
                      if (gfld->bmap != 0 ) free(gfld->bmap);
                      if (gfld->fld != 0 ) free(gfld->fld);
                      free(gfld);
                
                      return;
                }


Top 10 Lines:

     Line      Count

       30         17

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       17   Total number of line executions
    17.00   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/g2clib-1.1.8/g2_unpack6.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include "grib2.h"
                
                g2int g2_unpack6(unsigned char *cgrib,g2int *iofst,g2int ngpts,g2int *ibmap,
                               g2int **bmap)
                //$$$  SUBPROGRAM DOCUMENTATION BLOCK
                //                .      .    .                                       .
                // SUBPROGRAM:    g2_unpack6 
                //   PRGMMR: Gilbert         ORG: W/NP11    DATE: 2002-10-31
                //
                // ABSTRACT: This subroutine unpacks Section 6 (Bit-Map Section)
                //           as defined in GRIB Edition 2.
                //
                // PROGRAM HISTORY LOG:
                // 2002-10-31  Gilbert
                //
                // USAGE:    int g2_unpack6(unsigned char *cgrib,g2int *iofst,g2int ngpts,
                //                          g2int *ibmap,g2int **bmap)
                //   INPUT ARGUMENTS:
                //     cgrib    - char array containing Section 6 of the GRIB2 message
                //     iofst    - Bit offset of the beginning of Section 6 in cgrib.
                //     ngpts    - Number of grid points specified in the bit-map
                //
                //   OUTPUT ARGUMENTS:      
                //     iofst    - Bit offset at the end of Section 6, returned.
                //     ibmap    - Bitmap indicator ( see Code Table 6.0 )
                //                0 = bitmap applies and is included in Section 6.
                //                1-253 = Predefined bitmap applies
                //                254 = Previously defined bitmap applies to this field
                //                255 = Bit map does not apply to this product.
                //     bmap     - Pointer to an integer array containing decoded bitmap. 
                //                ( if ibmap=0 )
                //
                //   RETURN VALUES:
                //     ierr     - Error return code.
                //                0 = no error
                //                2 = Not Section 6
                //                4 = Unrecognized pre-defined bit-map.
                //                6 = memory allocation error
                //
                // REMARKS: None
                //
                // ATTRIBUTES:
                //   LANGUAGE: C
                //   MACHINE:
                //
                //$$$//
          17 -> {
                      g2int j,ierr,isecnum;
                      g2int *lbmap=0;
                      g2int *intbmap;
                
                      ierr=0;
                      *bmap=0;    //NULL
                
                      *iofst=*iofst+32;    // skip Length of Section
                      gbit(cgrib,&isecnum,*iofst,8);         // Get Section Number
                      *iofst=*iofst+8; 
                
                      if ( isecnum != 6 ) {
                         ierr=2;
                         fprintf(stderr,"g2_unpack6: Not Section 6 data.\n");
                         return(ierr);
                      }
                
                      gbit(cgrib,ibmap,*iofst,8);    // Get bit-map indicator
                      *iofst=*iofst+8;
                
                      if (*ibmap == 0) {               // Unpack bitmap
                         if (ngpts > 0) lbmap=(g2int *)calloc(ngpts,sizeof(g2int));
                         if (lbmap == 0) {
                            ierr=6;
                            return(ierr);
                         }
                         else {
                            *bmap=lbmap;
                         }
                         intbmap=(g2int *)calloc(ngpts,sizeof(g2int));  
                         gbits(cgrib,intbmap,*iofst,1,0,ngpts);
                         *iofst=*iofst+ngpts;
                         for (j=0;j<ngpts;j++) {
                           lbmap[j]=(g2int)intbmap[j];
                         }
                         free(intbmap);
                //      else if (*ibmap.eq.254)               ! Use previous bitmap
                //        return(ierr);
                //      else if (*ibmap.eq.255)               ! No bitmap in message
                //        bmap(1:ngpts)=.true.
                //      else {
                //        print *,'gf_unpack6: Predefined bitmap ',*ibmap,' not recognized.'
                //        ierr=4;
                      }
                      
                      return(ierr);    // End of Section 6 processing
                
                }


Top 10 Lines:

     Line      Count

       49         17

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       17   Total number of line executions
    17.00   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/my_netcdf.c:
                #include <stdio.h>
                #include <netcdf.h>
                #include <string.h>
                #include <math.h>
                #include <time.h>
                #include <stdlib.h>
                
                #include "my_netcdf.h"
                #include "my_parallel.h"
                //#include "wgrib2nc.h"
                //#include "netcdf_sup
                
                char * my_get_unixdate(double utime, char * date_str)
           1 -> {
                  struct tm *gmt;
                  time_t gmt_t;
                
                  gmt_t=(time_t)utime;
                  gmt = gmtime(&gmt_t);
                  sprintf(date_str,"%.4d.%.2d.%.2d %.2d:%.2d:%.2d UTC",
                  gmt->tm_year+1900,gmt->tm_mon+1,gmt->tm_mday,gmt->tm_hour,gmt->tm_min,gmt->tm_sec);
                  return date_str;
                }
                
                void print_error(const char *fmt, const char *string)
       ##### -> {
                    fprintf(stderr, "\n*** FATAL ERROR: ");
                    fprintf(stderr, fmt, string);
                    fprintf(stderr," ***\n\n");
                    exit(8);
                    return;
                }
                
                void netcdf_func(int status)
         257 -> {
                  if (status != NC_NOERR) print_error("netcdf error %s", nc_strerror(status));
                }
                
                int finalize_nc_info(nc_info_t *save)
           1 -> {
                
                #ifdef DEBUG_NC
                	fprintf(stderr,"netcdf: were added/updated %d fields, file %s\n",save->nid,save->ncfile);
                #endif
                   
                    if (save->ncid >=0)  
                	  nc_close(save->ncid);
                    free(save->ncfile);
                
                    free(save);
                    return 0;
                }
                
                
                int put_nc_global_attr(int ncid, int dim_latlon, int grid_template)
           1 -> {
                    char *str;
                    str="";
                      if (dim_latlon == 1)
                        str = "COARDS";
                      else if (dim_latlon == 2)
                        str = "CF-1.0";
                      else
                        fatal_error("netcdf:create_nc_dims: %s","unsupported lat-lon dimension");
                
                      netcdf_func( nc_put_att_text(ncid, NC_GLOBAL, "Conventions", strlen(str), str) );
                
                      netcdf_func( nc_put_att_int (ncid, NC_GLOBAL, "GRIB2_grid_template",
                                                NC_INT, 1, &grid_template) );
                }
                
                
                void define_nc_dims(int ncid, int dim_latlon, int *time_dim, int *x_dim, size_t x_len,
                                    int *y_dim, size_t y_len)
           1 -> {
                    char *name;
                // create coordinate variables...
                  if (dim_latlon == 1)
                  {
                    netcdf_func( nc_def_dim (ncid, "latitude", y_len, y_dim) );
                    netcdf_func( nc_def_dim (ncid, "longitude", x_len, x_dim) );
                  }
                  else if(dim_latlon == 2)
                  {
                    netcdf_func( nc_def_dim (ncid, "y", y_len, y_dim) );
                    netcdf_func( nc_def_dim (ncid, "x", x_len, x_dim) );
                  }
                  else
                    print_error("netcdf:create_nc_dims: %s","unsupported lat-lon dimension");
                
                   netcdf_func( nc_def_dim (ncid, "time", NC_UNLIMITED, time_dim) );
                   
                }
                
                void define_nc_dim_var(int ncid, int dim_latlon, int *time_dim, int *time_var, int *x_dim, 
                						int *y_dim, double dx, double dy,
                                        double verf_utime, double ref_utime, double time_step, int time_step_type,
                			    double date0, int time_ind, double *lat_data, double *lon_data)
           1 -> {
                     char *name, *str, *lname, *units;
                     char ref_date[50];
                     int dimids[2];
                     int lat_var, lon_var, y_var, x_var;
                     int ref_time_type;
                     double fill_value = FILL_VALUE_DOUBLE;
                     float  f_fill_value = FILL_VALUE_FLOAT;
                
                     /* the variable need by put_nc_dim_var */
                     double ttime;
                     int i, j;
                     double *test_ll;
                     size_t start[2], count[2];
                     size_t x_len, y_len;
                     size_t dimlens[2];
                     
                // create coordinate variables...
                     if (dim_latlon == 1)
                    {
                
                    dimids[0] = *y_dim;
                    netcdf_func( nc_def_var (ncid, "latitude", NC_DOUBLE, 1, dimids, &lat_var) );
                    dimids[0] = *x_dim;
                    netcdf_func( nc_def_var (ncid, "longitude", NC_DOUBLE, 1, dimids, &lon_var) );
                /*#ifdef DEBUG_NC
                fprintf(stderr,"netcdf:create_nc_dims: latitude(dim,var,ny)=%d %d %d\n",*y_dim,lat_var,ny);
                fprintf(stderr,"netcdf:create_nc_dims: longitude(dim,var,nx)=%d %d %d\n",*x_dim,lon_var,nx);
                #endif*/
                  }
                  else if(dim_latlon == 2)
                  {
                
                    dimids[0] = *y_dim;
                    netcdf_func( nc_def_var (ncid, "y", NC_DOUBLE, 1, dimids, &y_var) );
                    str = "y coordinate of projection";
                //    str = "projection_y_coordinate";    //it is standard_name,
                                                        //but could require grid_mapping definition that is
                                                        //projection-dependant; could do it later;
                                                        //do not need lat-lon values in this case as these would be
                                                        //computed in processing software (CF convention)
                    netcdf_func( nc_put_att_text(ncid, y_var, "long_name", strlen(str), str) );
                    str = "projection_y_coordinate";
                    netcdf_func( nc_put_att_text(ncid, y_var, "standard_name", strlen(str), str) );
                    dimids[0] = *x_dim;
                    netcdf_func( nc_def_var (ncid, "x", NC_DOUBLE, 1, dimids, &x_var) );
                    str = "x coordinate of projection";
                    netcdf_func( nc_put_att_text(ncid, x_var, "long_name", strlen(str), str) );
                    str = "projection_x_coordinate";
                    netcdf_func( nc_put_att_text(ncid, x_var, "standard_name", strlen(str), str) );
                    str = "m";
                    netcdf_func( nc_put_att_text(ncid, y_var, "units", strlen(str), str) );
                    netcdf_func( nc_put_att_text(ncid, x_var, "units", strlen(str), str) );
                    netcdf_func( nc_put_att_double(ncid, x_var, "grid_spacing", NC_DOUBLE, 1, &dx) );
                    netcdf_func( nc_put_att_double(ncid, y_var, "grid_spacing", NC_DOUBLE, 1, &dy) );
                    dimids[0] = *y_dim;
                    dimids[1] = *x_dim;
                    netcdf_func( nc_def_var (ncid, "latitude", NC_DOUBLE, 2, dimids, &lat_var) );
                    netcdf_func( nc_def_var (ncid, "longitude", NC_DOUBLE, 2, dimids, &lon_var) );
                /*#ifdef DEBUG_NC
                fprintf(stderr,"netcdf:create_nc_dims: y(dim,var,ny)=%d %d %d\n",*y_dim,y_var,ny);
                fprintf(stderr,"netcdf:create_nc_dims: x(dim,var,nx)=%d %d %d\n",*x_dim,x_var,nx);
                fprintf(stderr,"netcdf:create_nc_var (2D): latitude(xdim,ydim,var)=%d %d %d\n",*y_dim,*x_dim,lat_var);
                fprintf(stderr,"netcdf:create_nc_var (2D): longitude(xdim,ydim,var)=%d %d %d\n",*y_dim,*x_dim,lon_var);
                #endif*/
                  }
                  else
                    print_error("netcdf:create_nc_dims: %s","unsupported lat-lon dimension");
                
                  str = "degrees_north";
                  netcdf_func( nc_put_att_text(ncid, lat_var, "units", strlen(str), str) );
                  str = "degrees_east";
                  netcdf_func( nc_put_att_text(ncid, lon_var, "units", strlen(str), str) );
                  str = "latitude";
                  netcdf_func( nc_put_att_text(ncid, lat_var, "long_name", strlen(str), str) );
                  str = "longitude";
                  netcdf_func( nc_put_att_text(ncid, lon_var, "long_name", strlen(str), str) );
                
                  /* time settings */
                  dimids[0] = *time_dim;
                  netcdf_func(nc_def_var (ncid, "time", NC_DOUBLE, 1, dimids, time_var));
                  netcdf_func(nc_put_att_double(ncid, *time_var, "_FillValue", NC_DOUBLE, 1, &fill_value));
                  str = "seconds since 1970-01-01 00:00:00.0 0:00";
                  netcdf_func( nc_put_att_text(ncid, *time_var, "units", strlen(str), str) );
                  //str = "verification time generated by wgrib2 function verftime()";
                  //netcdf_func( nc_put_att_text(ncid, *time_var, "long_name", strlen(str), str) );
                
                  /* nc_ref_time is reference time value,
                     nc_ref_time_type is the reference time type:
                     0 - undefined
                     1 - analyses, all for the same reference date, could be succeded by forecasts
                     2 - analyses, but for different reference date/time (time serie)
                     3 - forecasts from the same reference date/time
                     For the type 0 or 2 nc_ref_time keeps first field reference date/time
                  */
                  if (fabs(ref_utime - verf_utime) < TM_TOLERANCE )
                  {
                    ref_time_type = 1;
                    str = "analyses, reference date is fixed";
                  }
                  else
                  {
                    ref_time_type = 3;
                    str = "forecast or accumulated, reference date is fixed";
                  }
                  netcdf_func( nc_put_att_double(ncid, *time_var, "reference_time", NC_DOUBLE, 1, &ref_utime) );
                  netcdf_func( nc_put_att_int(ncid, *time_var,    "reference_time_type", NC_INT, 1, &ref_time_type) );
                  my_get_unixdate(ref_utime, ref_date);
                  netcdf_func( nc_put_att_text(ncid, *time_var,   "reference_date", strlen(ref_date), ref_date) );
                  netcdf_func( nc_put_att_text(ncid, *time_var,   "reference_time_description", strlen(str), str) );
                  /* write time step attributes, could be -1 (undefined) for first or single time step, then update */
                  if ( time_step_type )
                  {
                    str="user";
                  }
                  else
                  {
                    str="auto";
                  }
                  netcdf_func( nc_put_att_text(ncid, *time_var, "time_step_setting", strlen(str), str) );
                  netcdf_func( nc_put_att_double(ncid, *time_var,  "time_step", NC_DOUBLE, 1, &time_step) );
                
                #ifdef DEBUG_NC
                fprintf(stderr,"netcdf:create_nc_dims: time(dim,var)=%d %d, size unlimited\n",*time_dim,*time_var);
                fprintf(stderr,"netcdf:create_nc_dims: time_step=%.1lf time_step_type=%d (%s)\n",
                time_step,time_step_type,str);
                #endif
                  
                     netcdf_func( nc_enddef(ncid) );
                
                
                /*
                  * put var
                  */
                     // populate coordinate variables...
                  start[0] = 0;
                  netcdf_func( nc_put_var1_double(ncid, *time_var, start, &date0) );
                
                  if ( time_ind == 1 )
                  {
                    start[0] = 1;
                    netcdf_func( nc_put_var1_double(ncid, *time_var, start, &verf_utime) );
                  }
                  else if (time_ind > 1)
                  {
                    for (j=1; j <= time_ind; j++)
                    {
                      start[0] = j;
                      ttime = date0 + (time_step)*j;
                      netcdf_func( nc_put_var1_double(ncid, *time_var, start, &ttime) );
                    }
                  }
                  else if (time_ind < 0)
                  {
                   fatal_error("netcdf:create_nc_dims: %s","negative time index");
                  }
                
                    netcdf_func(nc_inq_dimlen(ncid, *x_dim, &x_len));
                    netcdf_func(nc_inq_dimlen(ncid, *y_dim, &y_len));
                    
                  i = MAX(x_len, y_len);
                  test_ll = (double*) malloc(i*sizeof(double));
                  if (!test_ll) fatal_error("netcdf:create_nc_dims: %s",
                    "error doing malloc of test_ll");
                  
                  if (dim_latlon == 1)
                  {
                        set_hyperslab(count, start, &y_len, 1);
                        for (i=0; i < count[0] ; i++) 
                            test_ll[i] = lat_data[(i+start[0])*x_len];
                        //start[0] = 0; count[0] = y_len;
                        netcdf_func( nc_put_vara_double(ncid, lat_var, start, count, test_ll) );
                
                        set_hyperslab(count, start, &x_len, 1);
                        for (i=0; i<count[0]; i++) 
                            test_ll[i] = lon_data[i+start[0]];
                        //start[0] = 0; count[0] = x_len;
                        netcdf_func( nc_put_vara_double(ncid, lon_var, start, count, test_ll) );
                  }
                  else
                  {
                        set_hyperslab(count, start, &y_len, 1);
                        for (i=0; i<count[0] ; i++) 
                            test_ll[i] = dy*(i+start[0]);
                        //start[0] = 0; count[0] = y_len;
                        netcdf_func( nc_put_vara_double(ncid, y_var, start, count, test_ll) );
                
                        set_hyperslab(count, start, &x_len, 1);
                        for (i=0; i<count[0]; i++) 
                            test_ll[i] = dx*(i+start[0]);
                        //start[0] = 0; count[0] = x_len;
                        netcdf_func( nc_put_vara_double(ncid, x_var, start, count, test_ll) );
                
                        //start[0] = 0;  count[0] = y_len;
                        //start[1] = 0;  count[1] = x_len;
                
                        dimlens[0] = y_len;
                        dimlens[1] = x_len;
                        set_hyperslab(count, start, dimlens, 2);
                        netcdf_func( nc_put_vara_double(ncid, lat_var, start, count, &(lat_data[start[0] * x_len + start[1]])) );
                        netcdf_func( nc_put_vara_double(ncid, lon_var, start, count, &(lon_data[start[0] * x_len + start[1]])) );
                  }
                  free(test_ll);
                }


Top 10 Lines:

     Line      Count

       35        257
       14          1
       40          1
       56          1
       75          1
       99          1

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

      262   Total number of line executions
    37.43   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/VerfTime.c:
                /******************************************************************************************
                
                 This file is part of wgrib2 and is distributed under terms of the GNU General Public License
                 For details see, Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
                 Boston, MA  02110-1301  USA
                
                 Edition 2008.02.18
                
                 Sergey Varlamov
                 Kristian Nilssen
                 Wesley Ebisuzaki
                */
                
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include "grb2.h"
                #include "wgrib2.h"
                #include "fnlist.h"
                
                static char *months = "janfebmaraprmayjunjulaugsepoctnovdec";
                
                /*
                 * HEADER:400:vt:inv:0:verf time = reference_time + forecast_time, -v2 for alt format
                 * 9/2006  w.ebisuzaki
                 * 1/2007  check error code on verftime
                 * 2/2008  wne for product definition template 8 (ave/acc/etc), return end of averaging interval -- like grads
                 * 3/2008  wne add verf time for ensemble products, add vt=
                 */
       ##### -> int f_vt(ARG0) {
                
                    int year, month, day, hour, minute, second;
                
                    if (mode >= 0) {
                        if (verftime(sec, &year, &month, &day, &hour, &minute, &second) == 0) {
                	    if (mode != 2) {
                	        sprintf(inv_out,"vt=%4.4d%2.2d%2.2d%2.2d", year,month,day,hour);
                	    }
                	    else {
                               sprintf(inv_out,"%2.2dZ%2.2d%c%c%c%4.4d", hour,day,months[month*3-3],
                		months[month*3-2], months[month*3-1], year);
                	    }
                        }
                        else {
                           sprintf(inv_out,"vt=?");
                        }
                    }
                    return 0;
                }
                
                /*
                 * HEADER:400:VT:inv:0:verf time = reference_time + forecast_time (YYYYMMDDHHMMSS)
                 */
       ##### -> int f_VT(ARG0) {
                
                    int year, month, day, hour, minute, second;
                
                    if (mode >= 0) {
                        if (verftime(sec, &year, &month, &day, &hour, &minute, &second) == 0) {
                	    if (mode != 2) {
                                sprintf(inv_out,"vt=%4.4d%2.2d%2.2d%2.2d%2.2d%2.2d", year,month,day,hour,minute,second);
                	    }
                	    else {
                               sprintf(inv_out,"%2.2d_%2.2dZ%2.2d%c%c%c%4.4d", hour,minute,day,months[month*3-3],
                		months[month*3-2], months[month*3-1], year);
                	    }
                        }
                        else {
                            sprintf(inv_out,"vt=?");
                       }
                    }
                    return 0;
                }
                
                
                /*
                 * Returns the verification time: reference_time + forecast_time + statistical processing time (if any)
                 * 9/2006  w. ebisuzaki
                 * 1/2007  w. ebisuzaki return error code
                 * 11/2007  w. ebisuzaki fixed code for non forecasts
                 * 3/2008 w. ebisuzaki added code for ensemble processing
                 * 4/2009 w. ebisuzaki test table 1.2 sign of reference time
                 */
                
          17 -> int verftime(unsigned char **sec, int *year, int *month, int *day, int *hour, int *minute, int *second) {
                
                    int units, i, j;
                    unsigned int dtime;
                    static int error_count = 0;
                    static int warning_count = 0;
                
                    i = code_table_4_0(sec);
                
                    // if statistically processed field, verftime is in header
                    j = stat_proc_verf_time(sec, year, month, day, hour, minute, second);
                    if (j == 0) return 0;
                
                    get_time(sec[1]+12, year, month, day, hour, minute, second);
                
                    // some products have no forecast time
                
                    if (i == 20  || i == 30 || i == 31)
                	return 0;
                
                    // check the significance of the refernce time
                    i = code_table_1_2(sec);
                
                    if (i == 2) {
                	// rt=verifying time of forecast
                	// unclear what it means for time averages/accumulations
                	if (warning_count == 0) {
                	    fprintf(stderr,"Warning: rt == vt (CodeTable 1.2)\n");
                	    warning_count++;
                	}
                	return 0;
                    }
                
                    if (i != 0 && i != 1) {
                	if (error_count == 0) {
                	    fprintf(stderr,"verifyingtime: Table 1.2=%d not supported "
                		" using RT=analysis/start of forecast\n", i);
                	    error_count++;
                	}
                    }
                
                    units = code_table_4_4(sec);
                    dtime = forecast_time_in_units(sec);
                    return add_time(year, month, day, hour, minute, second, dtime, units);
                }
                
                /*
                 * HEADER:400:start_ft:inv:0:verf time = reference_time + forecast_time (YYYYMMDDHH) - no stat. proc time
                 */
       ##### -> int f_start_ft(ARG0) {
                
                    int year, month, day, hour, minute, second;
                
                    if (mode >= 0) {
                        if (start_ft(sec, &year, &month, &day, &hour, &minute, &second) == 0) {
                            if (mode != 2) {
                                sprintf(inv_out,"start_ft=%4.4d%2.2d%2.2d%2.2d", year,month,day,hour);
                            }
                            else {
                               sprintf(inv_out,"%2.2dZ%2.2d%c%c%c%4.4d", hour,day,months[month*3-3],
                                months[month*3-2], months[month*3-1], year);
                            }
                        }
                        else {
                            sprintf(inv_out,"start_ft=?");
                       }
                    }
                    return 0;
                }
                
                /*
                 * HEADER:400:start_FT:inv:0:verf time = reference_time + forecast_time (YYYYMMDDHHMMSS) - no stat. proc time
                 */
       ##### -> int f_start_FT(ARG0) {
                
                    int year, month, day, hour, minute, second;
                
                    if (mode >= 0) {
                        if (start_ft(sec, &year, &month, &day, &hour, &minute, &second) == 0) {
                            if (mode != 2) {
                                sprintf(inv_out,"start_FT=%4.4d%2.2d%2.2d%2.2d%2.2d%2.2d", year,month,day,hour,minute,second);
                            }
                            else {
                               sprintf(inv_out,"%2.2d_%2.2dZ%2.2d%c%c%c%4.4d", hour,minute,day,months[month*3-3],
                                months[month*3-2], months[month*3-1], year);
                            }
                        }
                        else {
                            sprintf(inv_out,"start_FT=?");
                       }
                    }
                    return 0;
                }
                
                
       ##### -> int start_ft(unsigned char **sec, int *year, int *month, int *day, int *hour, int *minute, int *second) {
                
                    int units, i;
                    unsigned int dtime;
                    static int error_count = 0;
                    static int warning_count = 0;
                
                    i = code_table_4_0(sec);
                
                    // get reference time
                    get_time(sec[1]+12, year, month, day, hour, minute, second);
                
                    // some products have no forecast time
                
                    if (i == 20  || i == 30 || i == 31)
                        return 0;
                
                    // check the significance of the refernce time
                    i = code_table_1_2(sec);
                
                    if (i == 2) {
                        // rt=verifying time of forecast
                        // unclear what it means for time averages/accumulations
                        if (warning_count == 0) {
                            fprintf(stderr,"Warning: rt == vt (CodeTable 1.2)\n");
                            warning_count++;
                        }
                        return 0;
                    }
                
                    if (i != 0 && i != 1) {
                        if (error_count == 0) {
                            fprintf(stderr,"verifyingtime: Table 1.2=%d not supported "
                                " using RT=analysis/start of forecast\n", i);
                            error_count++;
                        }
                    }
                
                    units = code_table_4_4(sec);
                    dtime = forecast_time_in_units(sec);
                    return add_time(year, month, day, hour, minute, second, dtime, units);
                }
                
                
                
                int reftime(unsigned char **sec, int *year, int *month, int *day, int *hour, int *minute, int *second)
          17 -> {
                
                    unsigned char *p;
                
                    p = sec[1];
                    *year = (p[12] << 8) | p[13];
                    *month = p[14];
                    *day = p[15];
                    *hour = p[16];
                    *minute = p[17];
                    *second = p[18];
                
                    return 0;
                }
                


Top 10 Lines:

     Line      Count

       85         17
      226         17

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

       34   Total number of line executions
     4.86   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/g2clib-1.1.8/gridtemplates.c:
                #include <stdlib.h>
                #include "grib2.h"
                #include "gridtemplates.h"
                
                g2int getgridindex(g2int number)
                /*!$$$  SUBPROGRAM DOCUMENTATION BLOCK
                !                .      .    .                                       .
                ! SUBPROGRAM:    getgridindex
                !   PRGMMR: Gilbert         ORG: W/NP11    DATE: 2001-06-28
                !
                ! ABSTRACT: This function returns the index of specified Grid
                !   Definition Template 3.NN (NN=number) in array templates.
                !
                ! PROGRAM HISTORY LOG:
                ! 2001-06-28  Gilbert
                ! 2007-08-16  Vuong     -  Added GDT 3.204  Curvilinear Orthogonal Grid
                ! 2008-07-08  Vuong     -  Added GDT 3.32768 Rotate Lat/Lon E-grid (Arakawa)
                ! 2009-01-14  Vuong     -  Changed structure name template to gtemplate
                !
                ! USAGE:    index=getgridindex(number)
                !   INPUT ARGUMENT LIST:
                !     number   - NN, indicating the number of the Grid Definition
                !                Template 3.NN that is being requested.
                !
                ! RETURNS:  Index of GDT 3.NN in array templates, if template exists.
                !           = -1, otherwise.
                !
                ! REMARKS: None
                !
                ! ATTRIBUTES:
                !   LANGUAGE: C
                !   MACHINE:  IBM SP
                !
                !$$$*/
          17 -> {
                           g2int j,getgridindex=-1;
                
                           for (j=0;j<MAXGRIDTEMP;j++) {
                              if (number == templatesgrid[j].template_num) {
                                 getgridindex=j;
                                 return(getgridindex);
                              }
                           }
                
                           return(getgridindex);
                }
                
                gtemplate *getgridtemplate(g2int number)
                /*!$$$  SUBPROGRAM DOCUMENTATION BLOCK
                !                .      .    .                                       .
                ! SUBPROGRAM:    getgridtemplate 
                !   PRGMMR: Gilbert         ORG: W/NP11    DATE: 2000-05-09
                !
                ! ABSTRACT: This subroutine returns grid template information for a 
                !   specified Grid Definition Template 3.NN.
                !   The number of entries in the template is returned along with a map
                !   of the number of octets occupied by each entry.  Also, a flag is
                !   returned to indicate whether the template would need to be extended.
                !
                ! PROGRAM HISTORY LOG:
                ! 2000-05-09  Gilbert
                ! 2007-08-16  Vuong     -  Added GDT 3.204  Curvilinear Orthogonal Grid
                ! 2008-07-08  Vuong     -  Added GDT 3.32768 Rotate Lat/Lon E-grid (Arakawa)
                ! 2009-01-14  Vuong     -  Changed structure name template to gtemplate
                !
                ! USAGE:    gtemplate *getgridtemplate(number)
                !   INPUT ARGUMENT LIST:
                !     number   - NN, indicating the number of the Grid Definition 
                !                Template 3.NN that is being requested.
                !
                !   RETURN VALUE:
                !        - Pointer to the returned template struct.
                !          Returns NULL pointer, if template not found.
                !
                ! REMARKS: None
                !
                ! ATTRIBUTES:
                !   LANGUAGE: C
                !   MACHINE:  IBM SP
                !
                !$$$*/
          17 -> {
                           g2int index;
                           gtemplate *new;
                
                           index=getgridindex(number);
                
                           if (index != -1) {
                              new=(gtemplate *)malloc(sizeof(gtemplate));
                              new->type=3;
                              new->num=templatesgrid[index].template_num;
                              new->maplen=templatesgrid[index].mapgridlen;
                              new->needext=templatesgrid[index].needext;
                              new->map=(g2int *)templatesgrid[index].mapgrid;
                              new->extlen=0;
                              new->ext=0;        //NULL
                              return(new);
                           }
                           else {
                             printf("getgridtemplate: GDT Template 3.%d not defined.\n",(int)number);
                             return(0);        //NULL
                           }
                
                         return(0);        //NULL
                }
                
                
                gtemplate *extgridtemplate(g2int number,g2int *list)
                /*!$$$  SUBPROGRAM DOCUMENTATION BLOCK
                !                .      .    .                                       .
                ! SUBPROGRAM:    extgridtemplate 
                !   PRGMMR: Gilbert         ORG: W/NP11    DATE: 2000-05-09
                !
                ! ABSTRACT: This subroutine generates the remaining octet map for a 
                !   given Grid Definition Template, if required.  Some Templates can 
                !   vary depending on data values given in an earlier part of the 
                !   Template, and it is necessary to know some of the earlier entry
                !   values to generate the full octet map of the Template.
                !
                ! PROGRAM HISTORY LOG:
                ! 2000-05-09  Gilbert
                ! 2008-07-08  Vuong     -  Added GDT 3.32768 Rotate Lat/Lon E-grid (Arakawa)
                ! 2009-01-14  Vuong     -  Changed structure name template to gtemplate
                !
                ! USAGE:    CALL extgridtemplate(number,list)
                !   INPUT ARGUMENT LIST:
                !     number   - NN, indicating the number of the Grid Definition 
                !                Template 3.NN that is being requested.
                !     list()   - The list of values for each entry in 
                !                the Grid Definition Template.
                !
                !   RETURN VALUE:
                !        - Pointer to the returned template struct.
                !          Returns NULL pointer, if template not found.
                !
                ! ATTRIBUTES:
                !   LANGUAGE: C
                !   MACHINE:  IBM SP
                !
                !$$$*/
       ##### -> {
                           gtemplate *new;
                           g2int index,i;
                
                           index=getgridindex(number);
                           if (index == -1) return(0);
                
                           new=getgridtemplate(number);
                
                           if ( ! new->needext ) return(new);
                
                           if ( number == 120 ) {
                              new->extlen=list[1]*2;
                              new->ext=(g2int *)malloc(sizeof(g2int)*new->extlen);
                              for (i=0;i<new->extlen;i++) {
                                 if ( i%2 == 0 ) {
                                    new->ext[i]=2;
                                 }
                                 else {
                                    new->ext[i]=-2;
                                 }
                              }
                           }
                           else if ( number == 1000 ) {
                              new->extlen=list[19];
                              new->ext=(g2int *)malloc(sizeof(g2int)*new->extlen);
                              for (i=0;i<new->extlen;i++) {
                                 new->ext[i]=4;
                              }
                           }
                           else if ( number == 1200 ) {
                              new->extlen=list[15];
                              new->ext=(g2int *)malloc(sizeof(g2int)*new->extlen);
                              for (i=0;i<new->extlen;i++) {
                                 new->ext[i]=4;
                              }
                           }
                
                           return(new);
                
                }


Top 10 Lines:

     Line      Count

       35         17
       82         17

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

       34   Total number of line executions
    11.33   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/g2clib-1.1.8/pdstemplates.c:
                #include <stdlib.h>
                #include "grib2.h"
                #include "pdstemplates.h"
                
                g2int getpdsindex(g2int number)
                ///$$$  SUBPROGRAM DOCUMENTATION BLOCK
                //                .      .    .                                       .
                // SUBPROGRAM:    getpdsindex
                //   PRGMMR: Gilbert         ORG: W/NP11    DATE: 2001-06-28
                //
                // ABSTRACT: This function returns the index of specified Product
                //   Definition Template 4.NN (NN=number) in array templates.
                //
                // PROGRAM HISTORY LOG:
                // 2001-06-28  Gilbert
                // 2009-01-14  Vuong     Changed structure name template to gtemplate
                // 2009-12-15  Vuong     Added Product Definition Template 4.31
                //                       Added Product Definition Template 4.15
                //
                // USAGE:    index=getpdsindex(number)
                //   INPUT ARGUMENT LIST:
                //     number   - NN, indicating the number of the Product Definition
                //                Template 4.NN that is being requested.
                //
                // RETURNS:  Index of PDT 4.NN in array templates, if template exists.
                //           = -1, otherwise.
                //
                // REMARKS: None
                //
                // ATTRIBUTES:
                //   LANGUAGE: C
                //   MACHINE:  IBM SP
                //
                //$$$/
          17 -> {
                           g2int j,getpdsindex=-1;
                
                           for (j=0;j<MAXPDSTEMP;j++) {
                              if (number == templatespds[j].template_num) {
                                 getpdsindex=j;
                                 return(getpdsindex);
                              }
                           }
                
                           return(getpdsindex);
                }
                
                
                gtemplate *getpdstemplate(g2int number)
                ///$$$  SUBPROGRAM DOCUMENTATION BLOCK
                //                .      .    .                                       .
                // SUBPROGRAM:    getpdstemplate 
                //   PRGMMR: Gilbert         ORG: W/NP11    DATE: 2000-05-11
                //
                // ABSTRACT: This subroutine returns PDS template information for a 
                //   specified Product Definition Template 4.NN.
                //   The number of entries in the template is returned along with a map
                //   of the number of octets occupied by each entry.  Also, a flag is
                //   returned to indicate whether the template would need to be extended.
                //
                // PROGRAM HISTORY LOG:
                // 2000-05-11  Gilbert
                // 2009-01-14  Vuong     Changed structure name template to gtemplate
                // 2009-08-05  Vuong     Added Product Definition Template 4.31
                //
                // USAGE:    CALL getpdstemplate(number)
                //   INPUT ARGUMENT LIST:
                //     number   - NN, indicating the number of the Product Definition 
                //                Template 4.NN that is being requested.
                //
                //   RETURN VALUE:
                //        - Pointer to the returned template struct.
                //          Returns NULL pointer, if template not found.
                //
                // REMARKS: None
                //
                // ATTRIBUTES:
                //   LANGUAGE: C
                //   MACHINE:  IBM SP
                //
                //$$$/
          17 -> {
                           g2int index;
                           gtemplate *new;
                
                           index=getpdsindex(number);
                
                           if (index != -1) {
                              new=(gtemplate *)malloc(sizeof(gtemplate));
                              new->type=4;
                              new->num=templatespds[index].template_num;
                              new->maplen=templatespds[index].mappdslen;
                              new->needext=templatespds[index].needext;
                              new->map=(g2int *)templatespds[index].mappds;
                              new->extlen=0;
                              new->ext=0;        //NULL
                              return(new);
                           }
                           else {
                             printf("getpdstemplate: PDS Template 4.%d not defined.\n",(int)number);
                             return(0);        //NULL
                           }
                
                         return(0);        //NULL
                }
                         
                        
                gtemplate *extpdstemplate(g2int number,g2int *list)
                ///$$$  SUBPROGRAM DOCUMENTATION BLOCK
                //                .      .    .                                       .
                // SUBPROGRAM:    extpdstemplate 
                //   PRGMMR: Gilbert         ORG: W/NP11    DATE: 2000-05-11
                //
                // ABSTRACT: This subroutine generates the remaining octet map for a
                //   given Product Definition Template, if required.  Some Templates can
                //   vary depending on data values given in an earlier part of the 
                //   Template, and it is necessary to know some of the earlier entry
                //   values to generate the full octet map of the Template.
                //
                // PROGRAM HISTORY LOG:
                // 2000-05-11  Gilbert
                // 2009-01-14  Vuong     Changed structure name template to gtemplate
                // 2009-08-05  Vuong     Added Product Definition Template 4.31
                //
                // USAGE:    CALL extpdstemplate(number,list)
                //   INPUT ARGUMENT LIST:
                //     number   - NN, indicating the number of the Product Definition 
                //                Template 4.NN that is being requested.
                //     list()   - The list of values for each entry in the 
                //                the Product Definition Template 4.NN.
                //
                //   RETURN VALUE:
                //        - Pointer to the returned template struct.
                //          Returns NULL pointer, if template not found.
                //
                // ATTRIBUTES:
                //   LANGUAGE: C
                //   MACHINE:  IBM SP
                //
                //$$$
       ##### -> {
                           gtemplate *new;
                           g2int index,i,j,k,l;
                
                           index=getpdsindex(number);
                           if (index == -1) return(0);
                
                           new=getpdstemplate(number);
                
                           if ( ! new->needext ) return(new);
                
                           if ( number == 3 ) {
                              new->extlen=list[26];
                              new->ext=(g2int *)malloc(sizeof(g2int)*new->extlen);
                              for (i=0;i<new->extlen;i++) {
                                 new->ext[i]=1;
                              }
                           }
                           else if ( number == 4 ) {
                              new->extlen=list[25];
                              new->ext=(g2int *)malloc(sizeof(g2int)*new->extlen);
                              for (i=0;i<new->extlen;i++) {
                                 new->ext[i]=1;
                              }
                           }
                           else if ( number == 8 ) {
                              if ( list[21] > 1 ) {
                                 new->extlen=(list[21]-1)*6;
                                 new->ext=(g2int *)malloc(sizeof(g2int)*new->extlen);
                                 for (j=2;j<=list[21];j++) {
                                    l=(j-2)*6;
                                    for (k=0;k<6;k++) {
                                       new->ext[l+k]=new->map[23+k];
                                    }
                                 }
                              }
                           }
                           else if ( number == 9 ) {
                              if ( list[28] > 1 ) {
                                 new->extlen=(list[28]-1)*6;
                                 new->ext=(g2int *)malloc(sizeof(g2int)*new->extlen);
                                 for (j=2;j<=list[28];j++) {
                                    l=(j-2)*6;
                                    for (k=0;k<6;k++) {
                                       new->ext[l+k]=new->map[30+k];
                                    }
                                 }
                              }
                           }
                           else if ( number == 10 ) {
                              if ( list[22] > 1 ) {
                                 new->extlen=(list[22]-1)*6;
                                 new->ext=(g2int *)malloc(sizeof(g2int)*new->extlen);
                                 for (j=2;j<=list[22];j++) {
                                    l=(j-2)*6;
                                    for (k=0;k<6;k++) {
                                       new->ext[l+k]=new->map[24+k];
                                    }
                                 }
                              }
                           }
                           else if ( number == 11 ) {
                              if ( list[24] > 1 ) {
                                 new->extlen=(list[24]-1)*6;
                                 new->ext=(g2int *)malloc(sizeof(g2int)*new->extlen);
                                 for (j=2;j<=list[24];j++) {
                                    l=(j-2)*6;
                                    for (k=0;k<6;k++) {
                                       new->ext[l+k]=new->map[26+k];
                                    }
                                 }
                              }
                           }
                           else if ( number == 12 ) {
                              if ( list[23] > 1 ) {
                                 new->extlen=(list[23]-1)*6;
                                 new->ext=(g2int *)malloc(sizeof(g2int)*new->extlen);
                                 for (j=2;j<=list[23];j++) {
                                    l=(j-2)*6;
                                    for (k=0;k<6;k++) {
                                       new->ext[l+k]=new->map[25+k];
                                    }
                                 }
                              }
                           }
                           else if ( number == 13 ) {
                              new->extlen=((list[37]-1)*6)+list[26];
                              new->ext=(g2int *)malloc(sizeof(g2int)*new->extlen);
                              if ( list[37] > 1 ) {
                                 for (j=2;j<=list[37];j++) {
                                    l=(j-2)*6;
                                    for (k=0;k<6;k++) {
                                       new->ext[l+k]=new->map[39+k];
                                    }
                                 }
                              }
                              l=(list[37]-1)*6;
                              if ( l<0 ) l=0;
                              for (i=0;i<list[26];i++) {
                                new->ext[l+i]=1;
                              }
                           }
                           else if ( number == 14 ) {
                              new->extlen=((list[36]-1)*6)+list[25];
                              new->ext=(g2int *)malloc(sizeof(g2int)*new->extlen);
                              if ( list[36] > 1 ) {
                                 for (j=2;j<=list[36];j++) {
                                    l=(j-2)*6;
                                    for (k=0;k<6;k++) {
                                       new->ext[l+k]=new->map[38+k];
                                    }
                                 }
                              }
                              l=(list[36]-1)*6;
                              if ( l<0 ) l=0;
                              for (i=0;i<list[25];i++) {
                                new->ext[l+i]=1;
                              }
                           }
                           else if ( number == 30 ) {
                              new->extlen=list[4]*5;
                              new->ext=(g2int *)malloc(sizeof(g2int)*new->extlen);
                              for (i=0;i<list[4];i++) {
                                 l=i*5;
                                 new->ext[l]=2;
                                 new->ext[l+1]=2;
                                 new->ext[l+2]=1;
                                 new->ext[l+3]=1;
                                 new->ext[l+4]=4;
                              }
                           }
                           else if ( number == 31 ) {
                              new->extlen=list[4]*5;
                              new->ext=(g2int *)malloc(sizeof(g2int)*new->extlen);
                              for (i=0;i<list[4];i++) {
                                 l=i*5;
                                 new->ext[l]=2;
                                 new->ext[l+1]=2;
                                 new->ext[l+2]=1;
                                 new->ext[l+3]=1;
                                 new->ext[l+4]=4;
                              }
                           }
                           return(new);
                
                }


Top 10 Lines:

     Line      Count

       35         17
       82         17

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

       34   Total number of line executions
    11.33   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/Sec3.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include "grb2.h"
                #include "wgrib2.h"
                #include "fnlist.h"
                
                /*
                 * Some routines that involve Sec3 - Grid definition section
                 *
                 * Public Domain - Wesley Ebisuzaki
                 * mod: 1/2007 M. Schwarb - cleanup
                 * mod: 8/2007 Boi Vuong - bug fix - mercator variable dimension had wrong location
                 */
                
                extern int nx, ny, res, scan;
                extern unsigned int npnts;
                extern enum output_order_type output_order;
                extern char *nl;
                
                int n_variable_dim = 0;
                int *variable_dim = NULL, *raw_variable_dim = NULL;
                
                
                /*
                 * HEADER:200:Sec3:inv:0:contents of section 3 (Grid Definition Section)
                 */
                
       ##### -> int f_Sec3(ARG0) {
                
                    unsigned char *p;
                    if (mode >= 0) {
                
                        p = sec[3];
                
                        if (p[4] != 3) {
                            fatal_error("Sec3 was expected and not found", "");
                        }
                        sprintf(inv_out,
                           "Sec3 len=%u src gdef=%d npts=%d Grid Def Template=3.%d opt arg=%u" ,
                            GB2_Sec3_size(sec), GB2_Sec3_gdef(sec), GB2_Sec3_npts(sec),
                            code_table_3_1(sec), p[10] );
                    }
                    return 0;
                }
                
                /*
                 * figures out nx and ny
                 *   res = resolution and component flags table 3.3
                 *   scan = scan mode table 3.4
                 *
                 * Use this code rather than .h files for nx, ny, res and scan
                 */
                
           2 -> int get_nxny(unsigned char **sec, int *nx, int *ny, unsigned int *npnts, int *res, int *scan) {
                    int grid_template, n_var_dim, i, j, n_octets;
                    unsigned int npoints, n;
                    unsigned char *gds, *p;
                
                    grid_template = code_table_3_1(sec);
                    *res = flag_table_3_3(sec);
                    *scan = flag_table_3_4(sec);
                
                    gds = sec[3];
                
                    switch (grid_template) {
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 10:
                        case 20:
                        case 30:
                        case 31:
                        case 40:
                        case 41:
                        case 42:
                        case 43:
                        case 90:
                        case 110:
                        case 204:
                                *nx = uint4_missing(gds+30); *ny = uint4_missing(gds+34); break;
                        case 51:
                        case 52:
                        case 53:
                        case 50: *nx = GB2_Sec3_npts(sec); *ny = 1; break;        // should calculate for from parameters
                	case 32768:
                	case 32769:
                	    if (GB2_Center(sec) == NCEP) {
                		*nx = uint4_missing(gds+30);
                		*ny = uint4_missing(gds+34);
                		break;
                	    }
                            *nx = *ny = -1; break;
                        default:
                                *nx = *ny = -1; break;
                    }
                
                    n_var_dim = 0;
                    if (*nx == -1) n_var_dim = *ny;
                    if (*ny == -1) n_var_dim = *nx;
                    if (*nx == -1 && *ny == -1) n_var_dim = 0;
                
                    p = NULL;
                    if (n_var_dim) {
                        switch (grid_template) {
                           case 0: p = gds + 72; break;
                           case 1: p = gds + 84; break;
                           case 2: p = gds + 84; break;
                           case 3: p = gds + 96; break;
                           case 10: p = gds + 72; break;
                           case 40: p = gds + 72; break;
                           case 41: p = gds + 84; break;
                           case 42: p = gds + 84; break;
                           case 43: p = gds + 96; break;
                	   case 32768: if (GB2_Center(sec) == NCEP) p = gds + 72;
                			else p = NULL;
                			break;
                	   case 32769: if (GB2_Center(sec) == NCEP) p = gds + 80;
                			else p = NULL;
                			break;
                           default: p = NULL; break;
                        }
                    }
                
                    /* calculate number of grid points, check with GDS */
                    npoints = 0;
                    if (n_var_dim) {
                
                        if (n_variable_dim != n_var_dim) {
                            free(variable_dim);
                            free(raw_variable_dim);
                            variable_dim = (int *) malloc(n_var_dim * sizeof(int));
                            if (variable_dim == NULL) fatal_error("ran out of memory","");
                            raw_variable_dim = (int *) malloc(n_var_dim * sizeof(int));
                            if (raw_variable_dim == NULL) fatal_error("ran out of memory","");
                            n_variable_dim = n_var_dim;
                        }
                        n_octets = (int) gds[10];        /* number of octets per integer */
                        for (i = 0; i < n_var_dim; i++) {
                            for (n = j = 0; j < n_octets; j++) {
                                n = (n << 8) + (int) *p++;
                            }
                            raw_variable_dim[i] = variable_dim[i] = (int) n;
                            npoints += n;
                        }
                
                        /* convert variable_dim to SN order if needed */
                        if (*nx == -1 && GDS_Scan_y(*scan) == 0 && output_order == wesn) {
                            for (i = 0; i < *ny; i++) {
                                variable_dim[i] = raw_variable_dim[*ny-1-i];
                            }
                        }
                        /* convert variable_dim to NS order if needed */
                        else if (*nx == -1 && GDS_Scan_y(*scan) != 0 && output_order == wens) {
                            for (i = 0; i < *ny; i++) {
                                variable_dim[i] = raw_variable_dim[*ny-1-i];
                            }
                        }
                    }
                    else if (*nx > 0 && *ny > 0) npoints = (unsigned) *nx * *ny;
                    *npnts = GB2_Sec3_npts(sec);
                    
                    if ((*nx != -1 || *ny != -1) && GB2_Sec3_npts(sec) != npoints) {
                        fprintf(stderr,"two values for number of points %u (GDS) %u (calculated)\n",
                                      GB2_Sec3_npts(sec), npoints);
                    }
                
                /*
                    for (i = 0; i < n_var_dim; i++) {
                      printf("%d ", variable_dim[i]);
                    }
                */
                
                    return 0;
                }
                
                /*
                 * HEADER:200:nxny:inv:0:nx and ny of grid
                 */
       ##### -> int f_nxny(ARG0) {
                    if (mode >= 0) sprintf(inv_out,"(%d x %d)",nx,ny);
                    return 0;
                }
                
                
                /*
                 * HEADER:200:scan:inv:0:scan order of grid
                 */
                char *scan_order[] = {
                        "WE:NS", "WE|EW:NS",
                        "NS:WE", "NS(W|E)",
                
                        "WE:SN", "WE|EW:SN",
                        "SN:WE", "SN(W|E)",
                
                        "EW:NS", "EW|WE:NS",
                        "NS:EW", "NS(E|W)",
                
                        "EW:SN", "EW|WE:SN",
                        "SN:EW", "SN(E|W)",
                 };
                
       ##### -> int f_scan(ARG0) {
                    if (mode >= 0) {
                        if (scan == -1) sprintf(inv_out,"scan=? ????");
                        else sprintf(inv_out,"scan=%d input=%s output=%s",scan >>4, scan_order[scan >> 4], output_order_name());
                    }
                    return 0;
                }
                
                /*
                 * HEADER:200:nlons:inv:0:number of longitudes for each latitude
                 */
                
       ##### -> int f_nlons(ARG0) {
                
                    int j;
                
                    if (mode < 0) return 0;
                
                    sprintf(inv_out,"nlon (S/N)=");
                    inv_out += strlen(inv_out);
                
                    if (n_variable_dim == 0) {
                        for (j = 0; j < ny; j++) {
                            sprintf(inv_out,"%d ", nx);
                            inv_out += strlen(inv_out);
                        }
                    }
                    else {
                        for (j = 0; j < ny; j++) {
                            sprintf(inv_out, "%d ",variable_dim[j]);
                            inv_out += strlen(inv_out);
                        }
                    }
                    if (ny) inv_out[-1] = 0;
                    return 0;
                }
                
                
                /*
                 * HEADER:200:grid:inv:0:grid definition
                 */
                
                /*
                 * some really needs to add some meat to this routine.
                 */
                
       ##### -> int f_grid(ARG0) {
                    int grid_template;
                    int basic_ang, sub_ang;
                    double units;
                    double lat1, lon1, lat2, lon2, dlat, dlon;
                    unsigned char *gds, *p;
                    int i, j, val, n, noct, offset, flag_3_3, no_dx, no_dy;
                
                    if (mode >= 0) {
                
                        if (GB2_Sec3_gdef(sec) != 0) {
                            sprintf(inv_out,"no grid template");
                            return 0;
                        }
                
                        gds = sec[3];
                        grid_template = code_table_3_1(sec);
                
                	no_dx = no_dy = 0;
                
                	if (grid_template != 20 && grid_template != 30 &&
                		grid_template != 31) {
                	    flag_3_3 = flag_table_3_3(sec);
                	    if (flag_3_3 != -1) {
                	        if ((flag_3_3 & 0x20) == 0) no_dx = 1;
                	        if ((flag_3_3 & 0x10) == 0) no_dy = 1;
                	    }
                	}
                
                        sprintf(inv_out,"grid_template=%d:", grid_template);
                        inv_out += strlen(inv_out);
                
                        if (res >= 0) {
                            sprintf(inv_out, res & 8 ? "winds(grid):" : "winds(N/S):");
                            inv_out += strlen(inv_out);
                	}
                
                        switch(grid_template) {
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                sprintf(inv_out,"%s", nl);
                                inv_out += strlen(inv_out);
                                if (nx == -1 || ny == -1) {
                                    i = code_table_3_11(sec);
                                    if (i == 1) sprintf(inv_out,"thinned global ");
                                    else if (i == 2) sprintf(inv_out,"thinned regional ");
                                    else fatal_error_i("code table 3.11 =%d is not right", i);
                                    inv_out += strlen(inv_out);
                                }
                                if (grid_template == 0) sprintf(inv_out,"lat-lon grid:");
                                if (grid_template == 1) sprintf(inv_out,"rotated lat-lon grid:");
                                if (grid_template == 2) sprintf(inv_out,"stretched lat-lon grid:");
                                if (grid_template == 3) sprintf(inv_out,"stretched/rotated lat-lon grid:");
                                inv_out += strlen(inv_out);
                
                                basic_ang = GDS_LatLon_basic_ang(gds);
                                sub_ang = GDS_LatLon_sub_ang(gds);
                                units = basic_ang == 0 ?  0.000001 : (float) basic_ang / (float) sub_ang;
                
                                sprintf(inv_out,"(%d x %d)",nx,ny);
                                inv_out += strlen(inv_out);
                
                                sprintf(inv_out," units %g input %s output %s res %d%s", units, scan_order[scan>>4],output_order_name(), res,nl);
                                inv_out += strlen(inv_out);
                
                                lat1 = units * GDS_LatLon_lat1(gds);
                                lon1 = units * GDS_LatLon_lon1(gds);
                                lat2 = units * GDS_LatLon_lat2(gds);
                                lon2 = units * GDS_LatLon_lon2(gds);
                
                                if (lon1 < 0.0 || lon2 < 0.0 || lon1 > 360.0 || lon2 > 360.0)
                                    fprintf(stderr,"BAD GDS:lon1=%lf lon2=%lf should be 0..360\n",lon1,lon2);
                
                                dlon = units * GDS_LatLon_dlon(gds);
                                dlat = units * GDS_LatLon_dlat(gds);
                		if (no_dx) dlon = 0.0;
                		if (no_dy) dlat = 0.0;
                
                //vsm_frm                if (ny == -1) sprintf(inv_out, "lat %g to %g with variable spacing%s", lat1, lat2, nl);
                                if (ny == -1) sprintf(inv_out, "lat %lf to %lf with variable spacing%s", lat1, lat2, nl);
                                else sprintf(inv_out, "lat %lf to %lf by %lf%s", lat1, lat2, dlat, nl);
                                inv_out += strlen(inv_out);
                //vsm_frm                if (nx == -1) sprintf(inv_out, "lon %g to %g with variable spacing", lon1, lon2);
                //vsm_frm                else sprintf(inv_out, "lon %g to %g by %g", lon1, lon2, dlon);
                                if (nx == -1) sprintf(inv_out, "lon %lf to %lf with variable spacing", lon1, lon2);
                                else sprintf(inv_out, "lon %lf to %lf by %lf", lon1, lon2, dlon);
                                inv_out += strlen(inv_out);
                                sprintf(inv_out, " #points=%u", npnts);
                                inv_out += strlen(inv_out);
                
                                if (grid_template == 1) {
                                    sprintf(inv_out, "%ssouth pole lat=%lf lon=%lf angle of rot=%lf",
                                        nl,units*int4(gds+72), units*int4(gds+76),units*int4(gds+80));
                                }
                                if (grid_template == 2) {
                                    sprintf(inv_out, "%sstretch lat=%lf lon=%lf factor=%lf",
                                        nl,units*int4(gds+72), units*int4(gds+76),int4(gds+80)*1e-6);
                                }
                                if (grid_template == 3) {
                                    sprintf(inv_out, "%ssouth pole lat=%lf lon=%lf angle of rot=%lf",
                                        nl,units*int4(gds+72), units*int4(gds+76),units*int4(gds+80));
                //vsm +1 line:
                                    inv_out += strlen(inv_out);                        
                                    sprintf(inv_out, ", stretch lat=%lf lon=%lf factor=%lf",
                                        units*int4(gds+84), units*int4(gds+88), int4(gds+92)*1e-6);
                                }
                                inv_out += strlen(inv_out);
                
                                if (mode > 0) {
                                    sprintf(inv_out,"%sbasic_ang=%d sub_angle=%d units=%lf",nl,basic_ang,sub_ang,units);
                                    inv_out += strlen(inv_out);
                                    sprintf(inv_out,"%sunscaled lat=%d to %d lon=%u to %u",nl, GDS_Gaussian_lat1(gds),
                                        GDS_Gaussian_lat2(gds), GDS_Gaussian_lon1(gds), GDS_Gaussian_lon2(gds));
                                    inv_out += strlen(inv_out);
                                }
                                // print out the variable grid spacing
                                if (nx == -1) sprintf(inv_out,"%s#grid points by latitude:",nl);
                                if (ny == -1) sprintf(inv_out,"%s#grid points by longitude:",nl);
                                inv_out += strlen(inv_out);
                                if (nx == -1 || ny == -1) {
                                    offset = 0;
                                    switch(grid_template) {
                                        case 0: offset = 72; break;
                                        case 1: offset = 84; break;
                                        case 2: offset = 84; break;
                                        case 3: offset = 96; break;
                                        default: fatal_error_i("Fix code to handle offset grid template %d", grid_template);
                                    }
                
                                    noct = sec[3][10];
                                    n = nx > ny ? nx : ny;
                                    for (i = 0; i < n; i++) {
                                        p = &(sec[3][offset+i*noct]);
                                        val = 0;
                                        for (j = 0; j < noct; j++) {
                                            val = 256*val + *p++;
                                        }
                                        if ((i + 7) % 20 == 0) {
                                            sprintf(inv_out,"%s",nl);
                                            inv_out += strlen(inv_out);
                                        }
                                        sprintf(inv_out," %d",val);
                                        inv_out += strlen(inv_out);
                                    }
                                }
                                break;
                
                            case 10: sprintf(inv_out,"%sMercator grid: (%d x %d) LatD %lf input %s output %s res %d%s",nl,
                                        nx, ny, GDS_Mercator_latD(gds), scan_order[scan>>4],output_order_name(),res,nl);
                                inv_out += strlen(inv_out);
                                lon1 = GDS_Mercator_lon1(gds);
                                lon2 = GDS_Mercator_lon2(gds);
                		dlat = GDS_Mercator_dy(gds);
                		dlon = GDS_Mercator_dx(gds);
                		if (no_dx) dlon = 0.0;
                		if (no_dy) dlat = 0.0;
                
                                sprintf(inv_out, "lat %lf to %lf by %lf m%slon %lf to %lf by %lf m%sorientation %lf",
                                        GDS_Mercator_lat1(gds), GDS_Mercator_lat2(gds), dlat, nl,
                                        lon1, lon2, dlon, nl, GDS_Mercator_ori_angle(gds));
                
                                if (lon1 < 0.0 || lon2 < 0.0 || lon1 > 360.0 || lon2 > 360.0)
                                      fprintf(stderr,"BAD GDS:lon1=%lf lon2=%lf should be 0..360\n",lon1,lon2);
                                break;
                
                            case 20: sprintf(inv_out,"%spolar stereographic grid: (%d x %d) input %s output %s res %d%s",nl,
                                        nx, ny, scan_order[scan>>4],output_order_name(), res,nl);
                                inv_out += strlen(inv_out);
                                sprintf(inv_out,"%s pole ", flag_table_3_5(sec) & 128 ? "South" : "North");
                                inv_out += strlen(inv_out);
                                dlon = GDS_Polar_dx(gds);
                		dlat = GDS_Polar_dy(gds);
                		if (no_dx) dlon = 0.0;
                		if (no_dy) dlat = 0.0;
                
                                sprintf(inv_out,"lat1 %lf lon1 %lf latD %lf lonV %lf dx %lf m dy %lf m",
                                    GDS_Polar_lat1(gds), GDS_Polar_lon1(gds),
                                    GDS_Polar_lad(gds), GDS_Polar_lov(gds),
                                    dlon, dlat);
                                inv_out += strlen(inv_out);
                
                                break;
                            case 30:
                                sprintf(inv_out,"%sLambert Conformal: (%d x %d) input %s output %s res %d%s",nl,
                                        nx, ny, scan_order[scan>>4],output_order_name(), res,nl);
                                inv_out += strlen(inv_out);
                                dlon = GDS_Lambert_dx(gds);
                		dlat = GDS_Lambert_dy(gds);
                		if (no_dx) dlon = 0.0;
                		if (no_dy) dlat = 0.0;
                
                                sprintf(inv_out,"Lat1 %lf Lon1 %lf LoV %lf%sLatD %lf "
                                    "Latin1 %lf Latin2 %lf%sLatSP %lf LonSP %lf%s"
                                    "%s (%d x %d) Dx %lf m Dy %lf m mode %d",
                                    GDS_Lambert_La1(gds), GDS_Lambert_Lo1(gds),
                                    GDS_Lambert_Lov(gds), nl, GDS_Lambert_LatD(gds),
                                    GDS_Lambert_Latin1(gds), GDS_Lambert_Latin2(gds), nl,
                                    GDS_Lambert_LatSP(gds), GDS_Lambert_LonSP(gds), nl,
                                    GDS_Lambert_NP(gds) ? "North Pole": "South Pole",
                                    nx, ny, dlon, dlat, res);
                
                                break;
                            case 31:  sprintf(inv_out,"%sAlbers equal area",nl);
                                break;
                            case 40: 
                            case 41:
                            case 42:
                            case 43:
                                basic_ang = GDS_Gaussian_basic_ang(gds);
                                sub_ang = GDS_Gaussian_sub_ang(gds);
                                units = basic_ang == 0 ?  0.000001 : (float) basic_ang / (float) sub_ang;
                
                                lat1 = units * GDS_Gaussian_lat1(gds);
                                lon1 = units * GDS_Gaussian_lon1(gds);
                                lat2 = units * GDS_Gaussian_lat2(gds);
                                lon2 = units * GDS_Gaussian_lon2(gds);
                
                                if (lon1 < 0.0 || lon2 < 0.0 || lon1 > 360.0 || lon2 > 360.0)
                                    fprintf(stderr,"BAD GDS:lon1=%lf lon2=%lf should be 0..360\n",lon1,lon2);
                
                                sprintf(inv_out,"%s",nl);
                                inv_out += strlen(inv_out);
                                if (nx == -1 || ny == -1) {
                                    i = code_table_3_11(sec);
                                    if (i == 1) sprintf(inv_out,"thinned global ");
                                    else if (i == 2) sprintf(inv_out,"thinned regional ");
                                    else fatal_error_i("code table 3.11 =%d is not right", i);
                                    inv_out += strlen(inv_out);
                                }
                
                                if (grid_template == 40) sprintf(inv_out,"Gaussian grid:");
                                if (grid_template == 41) sprintf(inv_out,"Rotated Gaussian grid:");
                                if (grid_template == 42) sprintf(inv_out,"Stretched Gaussian grid:");
                                if (grid_template == 43) sprintf(inv_out,"%sStretched-Rotated Gaussian grid:",nl);
                                inv_out += strlen(inv_out);
                
                                sprintf(inv_out," (%d x %d) units %g input %s output %s%s", nx, ny, units, scan_order[scan>>4],output_order_name(), nl);
                                inv_out += strlen(inv_out);
                
                                sprintf(inv_out,"number of latitudes between pole-equator=%u #points=%u%s",
                                    GDS_Gaussian_nlat(gds),npnts,nl);
                                inv_out += strlen(inv_out);
                
                                sprintf(inv_out, "lat %lf to %lf%slon %lf to %lf ",
                                     lat1, lat2,nl,lon1, lon2);
                                inv_out += strlen(inv_out);
                
                                if (grid_template == 41) {
                                    sprintf(inv_out, "%ssouth pole lat=%lf lon=%lf angle of rot=%lf",
                                        nl,units*int4(gds+72),units*int4(gds+76),units*int4(gds+80));
                                }
                                if (grid_template == 42) {
                                    sprintf(inv_out, "%sstretch lat=%lf lon=%lf factor=%lf",
                                        nl,units*int4(gds+72), units*int4(gds+76),int4(gds+80)*1e-6);
                                }
                                if (grid_template == 43) {
                                      sprintf(inv_out, "%ssouth pole lat=%lf lon=%lf angle of rot=%lf",
                                        nl,units*int4(gds+72),units*int4(gds+76),units*int4(gds+80));
                                      sprintf(inv_out, ", stretch lat=%lf lon=%lf factor=%lf",
                                        units*int4(gds+84), units*int4(gds+88),int4(gds+92)*1e-6);
                                }
                                inv_out += strlen(inv_out);
                
                                if (mode > 0) {
                                    sprintf(inv_out,"%sbasic_ang=%d sub_angle=%d units=%lf",nl,basic_ang,sub_ang,units);
                                    inv_out += strlen(inv_out);
                                    sprintf(inv_out,"%sunscaled lat=%d to %d lon=%u to %u",nl, GDS_Gaussian_lat1(gds),
                                        GDS_Gaussian_lat2(gds), GDS_Gaussian_lon1(gds), GDS_Gaussian_lon2(gds));
                                    inv_out += strlen(inv_out);
                                }
                                // print out the variable grid spacing
                                if (nx == -1) sprintf(inv_out,"%s#grid points by latitude:",nl);
                                if (ny == -1) sprintf(inv_out,"%s#grid points by longitude:",nl);
                                inv_out += strlen(inv_out);
                                if (nx == -1 || ny == -1) {
                                    offset = 0;
                                    switch(grid_template) {
                                        case 40: offset = 72; break;
                                        case 41: offset = 84; break;
                                        case 42: offset = 84; break;
                                        case 43: offset = 96; break;
                                        default: fatal_error_i("f_grid code needs to be updated offset for grid template %d",
                                            grid_template);
                                    }
                                    noct = sec[3][10];
                                    n = nx > ny ? nx : ny;
                                    for (i = 0; i < n; i++) {
                                        p = &(sec[3][offset+i*noct]);
                                        val = 0;
                                        for (j = 0; j < noct; j++) {
                                                val = 256*val + *p++;
                                        }
                                        if ((i + 7) % 20 == 0) {
                                            sprintf(inv_out,"%s",nl);
                                            inv_out += strlen(inv_out);
                                        }
                                        sprintf(inv_out," %d",val);
                                        inv_out += strlen(inv_out);
                                    }
                                }
                                break;
                
                            case 50: sprintf(inv_out,"Spherical harmonic j=%d k=%d l=%d, code_table_3.6=%d code_table_3.7=%d",
                                      GDS_Harmonic_j(gds), GDS_Harmonic_k(gds), GDS_Harmonic_m(gds),
                                      GDS_Harmonic_code_3_6(gds), GDS_Harmonic_code_3_7(gds));
                                  break;
                            case 51: sprintf(inv_out,"Rotated Spherical harmonic j=%d k=%d l=%d, code_table_3.6=%d code_table_3.7=%d%s",
                                      GDS_Harmonic_j(gds), GDS_Harmonic_k(gds), GDS_Harmonic_m(gds),
                                      GDS_Harmonic_code_3_6(gds), GDS_Harmonic_code_3_7(gds),nl);
                                  inv_out += strlen(inv_out);
                                  sprintf(inv_out,"South pole of proj lat=%lf lon=%lf rotation angle=%lf",
                                      ieee2flt(gds+28), ieee2flt(gds+32),ieee2flt(gds+36));
                                  break;
                            case 52: sprintf(inv_out,"Stretched Spherical harmonic j=%d k=%d l=%d, code_table_3.6=%d code_table_3.7=%d%s",
                                      GDS_Harmonic_j(gds), GDS_Harmonic_k(gds), GDS_Harmonic_m(gds),
                                      GDS_Harmonic_code_3_6(gds), GDS_Harmonic_code_3_7(gds),nl);
                                  inv_out += strlen(inv_out);
                                  sprintf(inv_out,"pole of stretching lat=%lf lon=%lf stretching=%lf",
                                        ieee2flt(gds+28), ieee2flt(gds+32),ieee2flt(gds+36));
                                  break;
                            case 53: sprintf(inv_out,"Rotated=Stretched Spherical harmonic j=%d k=%d l=%d, code_table_3.6=%d code_table_3.7=%d%s",
                                      GDS_Harmonic_j(gds), GDS_Harmonic_k(gds), GDS_Harmonic_m(gds),
                                      GDS_Harmonic_code_3_6(gds), GDS_Harmonic_code_3_7(gds),nl);
                                  inv_out += strlen(inv_out);
                                  sprintf(inv_out,"South pole of proj lat=%lf lon=%lf rotation angle=%lf%s",
                                      ieee2flt(gds+28), ieee2flt(gds+32),ieee2flt(gds+36),nl);
                                  inv_out += strlen(inv_out);
                                  sprintf(inv_out,"pole of stretching lat=%lf lon=%lf stretching=%lf",
                                      ieee2flt(gds+40), ieee2flt(gds+44),ieee2flt(gds+48));
                
                            case 90: sprintf(inv_out,"Space view perspective or orographic");
                                  break;
                            case 100: sprintf(inv_out,"Triangular grid based on icosahedron");
                                  break;
                            case 110: sprintf(inv_out,"Equatorial azimuthal equidistant projection");
                                  break;
                            case 120:
                                  sprintf(inv_out,"Azimuth-range projection Nb=%u Nr=%u center lat=%lf lon%lf%s",
                                        uint4(gds+14), uint4(gds+18), ieee2flt(gds+22), ieee2flt(gds+26),nl);
                                  inv_out += strlen(inv_out);
                                  sprintf(inv_out,"Dx=%lf Dstart=%lf",ieee2flt(gds+30),ieee2flt(gds+34));
                                  break;
                            case 204:
                                  sprintf(inv_out,"Curvilinear Orthogonal grid: see lat lon fields in this grib file");
                                  break;
                            case 1000: sprintf(inv_out,"Cross-section, points equal spaced on horizontal");
                                  break;
                            case 1100: sprintf(inv_out,"Hovmoller diagram, equal spaced on horizontal");
                                  break;
                            case 1200: sprintf(inv_out,"Time section grid");
                                  break;
                	    case 32768:
                		  if (GB2_Center(sec) == NCEP) {
                			/* for a rotated grid, where is the rotation angle? */
                                      sprintf(inv_out,"%s", nl);
                		      inv_out += strlen(inv_out);
                		      sprintf(inv_out,"Rotated Lat/Lon (Arakawa Staggered E-grid)");
                		      inv_out += strlen(inv_out);
                
                                      basic_ang = GDS_LatLon_basic_ang(gds);
                                      sub_ang = GDS_LatLon_sub_ang(gds);
                                      units = basic_ang == 0 ?  0.000001 : (float) basic_ang / (float) sub_ang;
                
                                      sprintf(inv_out,"(%d x %d)",nx,ny);
                                      inv_out += strlen(inv_out);
                
                                      sprintf(inv_out," units %g input %s output %s res %d%s", units, scan_order[scan>>4],
                				output_order_name(), res,nl);
                                      inv_out += strlen(inv_out);
                
                                      lat1 = units * GDS_LatLon_lat1(gds);
                                      lon1 = units * GDS_LatLon_lon1(gds);
                                      lat2 = units * GDS_LatLon_lat2(gds);
                                      lon2 = units * GDS_LatLon_lon2(gds);
                
                                      if (lon1 < 0.0 || lon2 < 0.0 || lon1 > 360.0 || lon2 > 360.0)
                                          fprintf(stderr,"BAD GDS:lon1=%lf lon2=%lf should be 0..360\n",lon1,lon2);
                
                                      dlon = units * GDS_LatLon_dlon(gds);
                                      dlat = units * GDS_LatLon_dlat(gds);
                                      if (no_dx) dlon = 0.0;
                                      if (no_dy) dlat = 0.0;
                
                                      if (ny == -1) sprintf(inv_out, "lat0 %lf lat-center %lf with variable spacing%s", lat1, lat2, nl);
                                      else sprintf(inv_out, "lat0 %lf lat-center %lf dlat %lf%s", lat1, lat2, dlat, nl);
                                      inv_out += strlen(inv_out);
                
                                      if (nx == -1) sprintf(inv_out, "lon0 %lf lon-center %lf with variable spacing", lon1, lon2);
                                      else sprintf(inv_out, "lon0 %lf lon-center %lf dlon %lf", lon1, lon2, dlon);
                                      inv_out += strlen(inv_out);
                                      sprintf(inv_out, " #points=%u", npnts);
                                      inv_out += strlen(inv_out);
                
                                      // print out the variable grid spacing
                                      if (nx == -1) sprintf(inv_out,"%s#grid points by latitude:",nl);
                                      if (ny == -1) sprintf(inv_out,"%s#grid points by longitude:",nl);
                                      inv_out += strlen(inv_out);
                                      if (nx == -1 || ny == -1) {
                		          offset = 72;
                                          noct = sec[3][10];
                                          n = nx > ny ? nx : ny;
                                          for (i = 0; i < n; i++) {
                                              p = &(sec[3][offset+i*noct]);
                                              val = 0;
                                              for (j = 0; j < noct; j++) {
                                                   val = 256*val + *p++;
                                              }
                                              if ((i + 7) % 20 == 0) {
                                                  sprintf(inv_out,"%s",nl);
                                                  inv_out += strlen(inv_out);
                                              }
                                              sprintf(inv_out," %d",val);
                                              inv_out += strlen(inv_out);
                                          }
                		      }
                	          }
                		  else {
                            	      sprintf(inv_out,"no other grid info");
                		  }
                                  break;
                            default: sprintf(inv_out,"no other grid info");
                                  break;
                        
                        }
                    }
                    return 0;
                }


Top 10 Lines:

     Line      Count

       55          2

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     0.33   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/g2clib-1.1.8/int_power.c:
                #include "grib2.h"
                /*
                 * w. ebisuzaki
                 *
                 *  return x**y
                 *
                 *
                 *  input: double x
                 *         int y
                 */
          50 -> double int_power(double x, g2int y) {
                
                        double value;
                
                        if (y < 0) {
                                y = -y;
                                x = 1.0 / x;
                        }
                        value = 1.0;
                
                        while (y) {
                                if (y & 1) {
                                        value *= x;
                                }
                                x = x * x;
                                y >>= 1;
                        }
                        return value;
                }
                


Top 10 Lines:

     Line      Count

       11         50

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       50   Total number of line executions
    50.00   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/g2clib-1.1.8/drstemplates.c:
                #include <stdlib.h>
                #include "grib2.h"
                #include "drstemplates.h"
                
                g2int getdrsindex(g2int number)
                /*!$$$  SUBPROGRAM DOCUMENTATION BLOCK
                !                .      .    .                                       .
                ! SUBPROGRAM:    getdrsindex 
                !   PRGMMR: Gilbert         ORG: W/NP11    DATE: 2001-06-28
                !
                ! ABSTRACT: This function returns the index of specified Data 
                !   Representation Template 5.NN (NN=number) in array templates.
                !
                ! PROGRAM HISTORY LOG:
                ! 2001-06-28  Gilbert
                ! 2009-01-14  Vuong     Changed structure name template to gtemplate
                !
                ! USAGE:    index=getdrsindex(number)
                !   INPUT ARGUMENT LIST:
                !     number   - NN, indicating the number of the Data Representation 
                !                Template 5.NN that is being requested.
                !
                ! RETURNS:  Index of DRT 5.NN in array gtemplates, if gtemplate exists.
                !           = -1, otherwise.
                !
                ! REMARKS: None
                !
                ! ATTRIBUTES:
                !   LANGUAGE: C
                !   MACHINE:  IBM SP
                !
                !$$$*/
          17 -> {
                           g2int j,getdrsindex=-1;
                
                           for (j=0;j<MAXDRSTEMP;j++) {
                              if (number == templatesdrs[j].template_num) {
                                 getdrsindex=j;
                                 return(getdrsindex);
                              }
                           }
                
                           return(getdrsindex);
                }
                
                
                gtemplate *getdrstemplate(g2int number)
                /*!$$$  SUBPROGRAM DOCUMENTATION BLOCK
                !                .      .    .                                       .
                ! SUBPROGRAM:    getdrstemplate 
                !   PRGMMR: Gilbert         ORG: W/NP11    DATE: 2000-05-11
                !
                ! ABSTRACT: This subroutine returns DRS template information for a 
                !   specified Data Representation Template 5.NN.
                !   The number of entries in the template is returned along with a map
                !   of the number of octets occupied by each entry.  Also, a flag is
                !   returned to indicate whether the template would need to be extended.
                !
                ! PROGRAM HISTORY LOG:
                ! 2000-05-11  Gilbert
                ! 2009-01-14  Vuong     Changed structure name template to gtemplate
                !
                ! USAGE:    new=getdrstemplate(number);
                !   INPUT ARGUMENT LIST:
                !     number   - NN, indicating the number of the Data Representation 
                !                Template 5.NN that is being requested.
                !
                !   RETURN VALUE:      
                !        - Pointer to the returned template struct. 
                !          Returns NULL pointer, if template not found.
                !
                ! REMARKS: None
                !
                ! ATTRIBUTES:
                !   LANGUAGE: C
                !   MACHINE:  IBM SP
                !
                !$$$*/
          17 -> {
                           g2int index;
                           gtemplate *new;
                
                           index=getdrsindex(number);
                
                           if (index != -1) {
                              new=(gtemplate *)malloc(sizeof(gtemplate));
                              new->type=5;
                              new->num=templatesdrs[index].template_num;
                              new->maplen=templatesdrs[index].mapdrslen;
                              new->needext=templatesdrs[index].needext;
                              new->map=(g2int *)templatesdrs[index].mapdrs;
                              new->extlen=0;
                              new->ext=0;        //NULL
                              return(new);
                           }
                           else {
                             printf("getdrstemplate: DRS Template 5.%d not defined.\n",(int)number);
                             return(0);        //NULL
                           }
                
                         return(0);        //NULL
                }
                
                gtemplate *extdrstemplate(g2int number,g2int *list)
                /*!$$$  SUBPROGRAM DOCUMENTATION BLOCK
                !                .      .    .                                       .
                ! SUBPROGRAM:    extdrstemplate 
                !   PRGMMR: Gilbert         ORG: W/NP11    DATE: 2000-05-11
                !
                ! ABSTRACT: This subroutine generates the remaining octet map for a
                !   given Data Representation Template, if required.  Some Templates can
                !   vary depending on data values given in an earlier part of the 
                !   Template, and it is necessary to know some of the earlier entry
                !   values to generate the full octet map of the Template.
                !
                ! PROGRAM HISTORY LOG:
                ! 2000-05-11  Gilbert
                ! 2009-01-14  Vuong     Changed structure name template to gtemplate
                !
                ! USAGE:    new=extdrstemplate(number,list);
                !   INPUT ARGUMENT LIST:
                !     number   - NN, indicating the number of the Data Representation 
                !                Template 5.NN that is being requested.
                !     list()   - The list of values for each entry in the 
                !                the Data Representation Template 5.NN.
                !
                !   RETURN VALUE:      
                !        - Pointer to the returned template struct. 
                !          Returns NULL pointer, if template not found.
                !
                ! ATTRIBUTES:
                !   LANGUAGE: C
                !   MACHINE:  IBM SP
                !
                !$$$*/
       ##### -> {
                           gtemplate *new;
                           g2int index,i;
                
                           index=getdrsindex(number);
                           if (index == -1) return(0);
                
                           new=getdrstemplate(number);
                
                           if ( ! new->needext ) return(new);
                
                           if ( number == 1 ) {
                              new->extlen=list[10]+list[12];
                              new->ext=(g2int *)malloc(sizeof(g2int)*new->extlen);
                              for (i=0;i<new->extlen;i++) {
                                new->ext[i]=4;
                              }
                           }
                           return(new);
                
                }
                


Top 10 Lines:

     Line      Count

       33         17
       79         17

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

       34   Total number of line executions
    11.33   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/Precision.c:
                #include <stdio.h>
                #include <string.h>
                #include "grb2.h"
                #include "wgrib2.h"
                #include "fnlist.h"
                
                /*
                 * HEADER:510:scaling:inv:0:scaling for packing (old format)
                 */
                
       ##### -> int f_scaling(ARG0) {
                
                    int dec, bin, nbits;
                    double base;
                    if (mode < 0) return 0;
                    if (scaling(sec, &base, &dec, &bin, &nbits) == 0) {
                       sprintf(inv_out,"scaling ref=%g dec_scale=%d bin_scale=%d nbits=%d", base, dec, bin, nbits);
                    }
                    return 0;
                }
                
                /*
                 * HEADER:510:scale:inv:0:scale for packing
                 */
       ##### -> int f_scale(ARG0) {
                
                    int dec, bin, nbits;
                    double base;
                    if (mode < 0) return 0;
                    if (scaling(sec, &base, &dec, &bin, &nbits) == 0) {
                       sprintf(inv_out,"scale=%d,%d", dec, bin);
                    }
                    return 0;
                }
                
                
          17 -> int scaling(unsigned char **sec, double *base, int *decimal, int *binary, int *nbits) {
                    int pack;
                    unsigned char *p;
                
                    pack = (int) code_table_5_0(sec);
                    p = sec[5];
                    if (pack == 0 || pack == 1 || pack == 2 || pack == 3 || pack == 40 || pack == 40000 || 
                		pack == 50 || pack == 40010) {
                       *base = ieee2flt(p+11);
                       *binary = int2(p+15);
                       *decimal = -int2(p+17);
                       *nbits = p[19];
                    }
                    else {
                      return 1;
                    }
                    return 0;
                }
                


Top 10 Lines:

     Line      Count

       37         17

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

       17   Total number of line executions
     5.67   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/my_rd_grib2_msg.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <stddef.h>
                #include <math.h>
                #include <float.h>
                
                #include <assert.h>
                
                #include "mpi.h"
                #include "my_rd_grib2_msg.h"
                #include "grb2.h"
                #include "wgrib2.h"
                
                #define G	71
                #define R	82
                #define I	       73
                #define B	66
                
                #define NTRY 100
                
                unsigned char *mpi_seek_grib2(MPI_File *file, MPI_Offset *pos, unsigned long int *len_grib, 
          18 ->         unsigned char *buffer, unsigned int buf_len, long int *n_bytes) {
                
                    long int i, len, current_pos;
                    int j, ret;
                    MPI_Status status;
                
                    for (j = 0; j < NTRY; j++) {
                
                        //ret = MPI_File_seek(*file, *pos, MPI_SEEK_SET);
                        if ((ret = MPI_File_seek(*file, *pos, MPI_SEEK_SET)) != MPI_SUCCESS) 
                			break;
                        // if ((*n_bytes = i = fread(buffer, sizeof(unsigned char), buf_len, file)) == 0) break;
                        ret = MPI_File_read(*file, buffer, buf_len, MPI_BYTE, &status);
                		if(ret != MPI_SUCCESS || status.count == 0)
                            break;
                        else
                            *n_bytes = i = status.count;
                
                        len = i - GB2_Sec0_size;
                     
                        for (i = 0; i < len; i++) {
                            if (buffer[i] == G && buffer[i+1] == R && buffer[i+2] == I
                                && buffer[i+3] == B) {
                		if (buffer[i+7] == 2) {
                                    *len_grib = uint8(buffer+i+8);
                                    *pos += i;
                                    return (buffer+i);
                		}
                		if (buffer[i+7] == 1) {
                		    fprintf(stderr,"grib1 message ignored (use wgrib)\n");
                		}
                            }
                        }
                	*pos = *pos + (buf_len - GB2_Sec0_size);
                    }
                
                    *len_grib = 0;
                    return (unsigned char *) NULL;
                }
                
                /*
                 * rd_grib2_msg.c *                              Wesley Ebisuzaki
                 *
                 * unsigned char rd_grib2_msg(FILE *input, long int pos, *int len)
                 *
                 * to read grib2 message
                 *
                 *    msg = rd_grib_msg(input, position, &len)
                 *
                 *    input is the file
                 *    position is the byte location (should be set to zero for first record 
                 *    msg = location of message
                 *
                 *    to get next record: *  position = position + len;
                 *
                 * rd_grib_msg allocates its own buffer which can be seen by the
                 * parsing routines
                 *
                 * 1/2007 cleanup M. Schwarb
                 * 6/2009 fix repeated bitmaps W. Ebisuzuaki
                 */
                
                #define BUFF_SIZE	(1024*64)
                #define SEEK_LEN 2048
                
                static unsigned char *buffer = NULL, *Msg = NULL, *Sec[9], *Sec6_bitmap;
                static int buffer_size = 0;
                
                unsigned char *mpi_rd_grib2_msg(MPI_File *input, long int *pos, unsigned long int *len, int *num_submsgs)
          18 -> {
                
                    unsigned long int len_grib, current_pos;
                    long int i;
                    unsigned long int tmp;
                    long int n_bytes;
                    unsigned char *p, *end_of_msg;
                    
                    MPI_Offset position;
                    MPI_Status status;
                
                    int rank, ret;
                    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
                    assert(rank >= 0);
                    
                	ret = -1;
                	memset(&status, 0, sizeof(status));
                
                        /* setup grib buffer */
                        if (buffer == NULL) {
                            if ((buffer = (unsigned char *) malloc(BUFF_SIZE)) == NULL) {
                    	    fatal_error("not enough memory: rd_grib2_msg","");
                    	}
                            buffer_size = BUFF_SIZE;
                        }
                
                        /* find Msg and length of message */
                
                        position = *pos;
                        Msg = mpi_seek_grib2(input, &position, &len_grib, buffer, SEEK_LEN, &n_bytes);
                        if (Msg == NULL) {
                            *len = 0;
                    	return NULL;
                        }
                
                        /* read all whole grib record .. to save I/O time, add to end of buffer */
                
                        if (len_grib + Msg - buffer > buffer_size) {
                    	tmp = Msg - buffer;
                            buffer_size = len_grib + Msg - buffer + 5000;
                            buffer = (unsigned char *) realloc((void *) buffer, buffer_size);
                            if (buffer == NULL) fatal_error("rd_grib2_msg: ran out of memory","");
                    	Msg = buffer + tmp;
                        }
                        
                    if(rank == 0){
                        if (MPI_File_seek(*input, *pos+n_bytes, MPI_SEEK_SET) != MPI_SUCCESS) 
                               fatal_error("rd_grib2_msg seek, outside the file, bad grib file","");
                
                        i = len_grib + Msg - buffer - n_bytes; 	/* no. of bytes need to read */
                        if (i > 0 && (ret = MPI_File_read(*input, buffer+n_bytes, i, MPI_BYTE,  &status)) != MPI_SUCCESS) 
                            fatal_error("rd_grib2_msg, read outside of file, bad grib file","");
                		if(i > 0 && status.count != i)
                            fatal_error("rd_grib2_msg, read outside of file, bad grib file","");
                		//if(ret == MPI_SUCCESS)
                		//	if(status.count != i) 
                          //  fatal_error("rd_grib2_msg, read outside of file, bad grib file","");
                	}
                
                    MPI_Bcast(Msg, buffer_size - (Msg - buffer), MPI_BYTE, 0, MPI_COMM_WORLD);
                
                    Sec[8] = Msg + len_grib - 4;
                    if (Sec[8][0] != 55 || Sec[8][1] != 55 || Sec[8][2] != 55 || Sec[8][3] != 55) {
                        fatal_error("rd_grib2_msg, missing end section ('7777')","");
                    }
                    Sec[0] = Msg;
                
                    /* scan message for number of submessages and perhaps for errors */
                    p = Msg +  GB2_Sec0_size;
                    end_of_msg = Msg + len_grib;
                
                    i = 0;
                    while (p < Sec[8]) {
                	if (p[4] == 7) i++;
                	p += uint4(p);
                	if (p > end_of_msg) fatal_error("bad grib format","");
                    }
                    if (p != Sec[8]) {
                	fprintf(stderr, "rd_grib2_msg: illegal format, end section expected\n");
                	exit(8);
                    }
                    *num_submsgs = i;
                
                /*    *len = len_grib + (position-*pos); */
                
                    *pos = position;
                    *len = len_grib;
                    return Msg;
                }
                
                
                
                /*
                 * with grib 1, a message = 1 field
                 * with grib 2, a message can have more than one field
                 *
                 * this routine parses a grib2 message that has already been read into buffer
                 *
                 * parse_1st_msg .. returns 1st message starting at Msg
                 */ 
                
                int mpi_parse_1st_msg(unsigned char **sec) 
          17 -> {
                
                	unsigned char *p, *end_of_msg;
                	int i;
                 
                	if (Msg == NULL) fatal_error("parse_1st_msg .. Msg == NULL","");
                
                	Sec[0] = Msg;
                	Sec[1] = Sec[2] = Sec[3] = Sec[4] = Sec[5] = Sec[6] = Sec[7] = 
                	Sec6_bitmap = NULL;
                	end_of_msg = Msg + GB2_MsgLen(Sec);
                
                	p = Msg + 16;
                
                	while (Sec[8] - p > 0) {
                	    if (p[4] > 8) fatal_error_i("parse_1st_msg illegal section %d", (int) p[4]);
                	    Sec[p[4]] = p;
                
                	    /* Section 6: bitmap */
                	    if (p[4] == 6) {
                		if (p[5] == 0) {
                		    Sec6_bitmap = p;
                		}
                		else if (p[5] >= 1 && p[5] <= 253) {
                	            fatal_error("parse_1st_msg: predefined bitmaps are not handled","");
                		}
                		else if (p[5] == 254) {
                	            fatal_error("parse_1st_msg: illegal grib msg, bitmap not defined code, table 6.0=254","");
                		}
                	    }
                
                	    /* last section */
                	    if (p[4] == 7) {
                		for (i = 0; i < 9; i++) {
                		    sec[i] = Sec[i];
                		}
                		return 0;
                	    }
                	    p += uint4(p);
                	    if (p > end_of_msg) fatal_error("bad grib fill","");
                	}
                	fatal_error("parse_1st_msg illegally format grib","");
                	return 1;
                }
                
                int mpi_parse_next_msg(unsigned char **sec) 
       ##### -> {
                
                	unsigned char *p, *end_of_msg;
                	int i;
                 
                	end_of_msg = Msg + GB2_MsgLen(sec);
                	p = sec[7];
                	if (p[4] != 7) {
                            fatal_error("parse_next_msg: parsing error","");
                	}
                	p += uint4(p);
                	if (p > end_of_msg) fatal_error("bad grib fill","");
                
                	while (p < Sec[8]) {
                	    Sec[p[4]] = p;
                
                	    // code to handle code table 6.0
                	    if (p[4] == 6) {
                		if (p[5] == 0) {
                		    Sec6_bitmap = p;
                		}
                		else if (p[5] >= 1 && p[5] <= 253) {
                	            fatal_error("parse_next_msg: predefined bitmaps are not handled","");
                		}
                		else if (p[5] == 254) {
                	            if (Sec6_bitmap == NULL) {
                	                fatal_error("parse_1st_msg: illegal grib msg, bitmap not defined code, table 6.0=254","");
                		    }
                		    Sec[6] = Sec6_bitmap;
                		}
                	    }
                	    if (p[4] == 7) {		// end of message .. save on sec[]
                		for (i = 0; i < 9; i++) {
                		    sec[i] = Sec[i];
                		}
                		return 0;
                	    }
                	    p += uint4(p);
                	    if (p > end_of_msg) fatal_error("bad grib fill","");
                	}
                	return 1;
                }
                


Top 10 Lines:

     Line      Count

       23         18
       92         18
      194         17

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

       53   Total number of line executions
    13.25   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/g2clib-1.1.8/g2_unpack1.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include "grib2.h"
                
                g2int g2_unpack1(unsigned char *cgrib,g2int *iofst,g2int **ids,g2int *idslen)
                /*//$$$  SUBPROGRAM DOCUMENTATION BLOCK
                //                .      .    .                                       .
                // SUBPROGRAM:    g2_unpack1 
                //   PRGMMR: Gilbert         ORG: W/NP11    DATE: 2002-10-29
                //
                // ABSTRACT: This subroutine unpacks Section 1 (Identification Section)
                //           as defined in GRIB Edition 2.
                //
                // PROGRAM HISTORY LOG:
                // 2002-10-29  Gilbert
                //
                // USAGE:    int g2_unpack1(unsigned char *cgrib,g2int *iofst,g2int **ids,
                //                          g2int *idslen)
                //   INPUT ARGUMENTS:
                //     cgrib    - char array containing Section 1 of the GRIB2 message
                //     iofst    - Bit offset for the beginning of Section 1 in cgrib.
                //
                //   OUTPUT ARGUMENTS:      
                //     iofst    - Bit offset at the end of Section 1, returned.
                //     ids      - address of pointer to integer array containing information 
                //                read from Section 1, the Identification section.
                //            ids[0]  = Identification of originating Centre
                //                                 ( see Common Code Table C-1 )
                //            ids[1]  = Identification of originating Sub-centre
                //            ids[2]  = GRIB Master Tables Version Number
                //                                 ( see Code Table 1.0 )
                //            ids[3]  = GRIB Local Tables Version Number
                //                                 ( see Code Table 1.1 )
                //            ids[4]  = Significance of Reference Time (Code Table 1.2)
                //            ids[5]  = Year ( 4 digits )
                //            ids[6]  = Month
                //            ids[7]  = Day
                //            ids[8]  = Hour
                //            ids[9]  = Minute
                //            ids[10]  = Second
                //            ids[11]  = Production status of processed data
                //                                 ( see Code Table 1.3 )
                //            ids[12]  = Type of processed data ( see Code Table 1.4 )
                //     idslen   - Number of elements in ids[].
                //
                //   RETURN VALUES:
                //     ierr     - Error return code.
                //                0 = no error
                //                2 = Array passed is not section 1
                //                6 = memory allocation error
                //
                // REMARKS: 
                //
                // ATTRIBUTES:
                //   LANGUAGE: C
                //   MACHINE:
                //
                //$$$
                */
          17 -> {
                
                      g2int i,lensec,nbits,ierr,isecnum;
                      g2int mapid[13]={2,2,1,1,1,2,1,1,1,1,1,1,1};
                
                      ierr=0;
                      *idslen=13;
                      *ids=0;
                
                      gbit(cgrib,&lensec,*iofst,32);        // Get Length of Section
                      *iofst=*iofst+32;
                      gbit(cgrib,&isecnum,*iofst,8);         // Get Section Number
                      *iofst=*iofst+8;
                
                      if ( isecnum != 1 ) {
                         ierr=2;
                         *idslen=13;
                         fprintf(stderr,"g2_unpack1: Not Section 1 data.\n");
                         return(ierr);
                      }
                
                      //
                      //   Unpack each value into array ids from the
                      //   the appropriate number of octets, which are specified in
                      //   corresponding entries in array mapid.
                      //
                      *ids=(g2int *)calloc(*idslen,sizeof(g2int));
                      if (*ids == 0) {
                         ierr=6;
                         return(ierr);
                      }
                      
                      for (i=0;i<*idslen;i++) {
                        nbits=mapid[i]*8;
                        gbit(cgrib,*ids+i,*iofst,nbits);
                        *iofst=*iofst+nbits;
                      }
                      
                      return(ierr);    // End of Section 1 processing
                }


Top 10 Lines:

     Line      Count

       60         17

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       17   Total number of line executions
    17.00   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/FlagTable.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include "grb2.h"
                #include "wgrib2.h"
                #include "fnlist.h"
                
                /*
                 * FlagTable.c
                 *
                 * routines to return the value of the various flags
                 *   policy: use this instead of .h files
                 *
                 * 12/2006: Public Domain Wesley Ebisuzaki
                 * 1/2007 cleanup M. Schwarb
                 */
                
                extern char *scan_order[];
                
                /*
                 * HEADER:-1:flag_table_3.3:inv:0:flag table 3.3, resolution and component flags
                 */
                
       ##### -> int f_flag_table_3_3(ARG0) {
                    int res;
                    if (mode >= 0) {
                        res = flag_table_3_3(sec);
                	if (res >= 0) {
                            sprintf(inv_out,"flag table 3.3=%d", res);
                	    inv_out += strlen(inv_out);
                        }
                    }
                    return 0;
                }
           2 -> int flag_table_3_3(unsigned char **sec) {
                    unsigned char *p;
                    p = flag_table_3_3_location(sec);
                    if (p == NULL) return -1;
                    return (int) *p;
                }
       ##### -> int set_flag_table_3_3(unsigned char **sec, unsigned int flag) {
                    unsigned char *p;
                    p = flag_table_3_3_location(sec);
                    if (p == NULL) return -1;
                    *p = flag;
                    return 0;
                }
                
           2 -> unsigned char *flag_table_3_3_location(unsigned char **sec) {
                    int grid_template;
                    unsigned char *gds;
                
                    grid_template = code_table_3_1(sec);
                    gds = sec[3];
                    switch (grid_template) {
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 40:
                        case 41:
                        case 42:
                        case 43:
                        case 204:
                              return gds+54; break;
                        case 10:
                        case 20:
                        case 30:
                        case 31:
                        case 90:
                        case 110:
                              return gds+46; break;
                	case 32768:
                		if (GB2_Center(sec) == NCEP) return gds+54;
                		return NULL;
                	case 32769:
                		if (GB2_Center(sec) == NCEP) return gds+54;
                		return NULL;
                
                		break;
                        default: return NULL; break;
                    }
                    return NULL;
                }
                
                
                
                /*
                 * HEADER:1:vector_dir:inv:0:grid or earth relative winds
                 */
                
       ##### -> int f_vector_dir(ARG0) {
                    int res;
                    if (mode >= 0) {
                        res = flag_table_3_3(sec);
                	if (res >= 0) {
                	    sprintf(inv_out, res & 8 ? "winds(grid)" : "winds(N/S)");
                	    inv_out += strlen(inv_out);
                        }
                    }
                    return 0;
                }
                
                /*
                 * HEADER:-1:flag_table_3.4:inv:0:flag table 3.4, scanning mode
                 */
                
       ##### -> int f_flag_table_3_4(ARG0) {
                    int scan;
                    if (mode >= 0) {
                        scan = flag_table_3_4(sec);
                	if (scan >= 0) {
                            sprintf(inv_out,"flag table 3.4=%d %s", scan, scan_order[scan >> 4]);
                	}
                    }
                    return 0;
                }
           2 -> int flag_table_3_4(unsigned char **sec) {
                    unsigned char *p;
                    p = flag_table_3_4_location(sec);
                    if (p == NULL) return -1;
                    return (int) *p;
                }
                
       ##### -> int set_flag_table_3_4(unsigned char **sec, unsigned int flag) {
                    unsigned char *p;
                    p = flag_table_3_4_location(sec);
                    if (p == NULL) return 1;
                    *p = flag;
                    return 0;
                }
                
                
           2 -> unsigned char *flag_table_3_4_location(unsigned char **sec) {
                    int grid_template;
                    unsigned char *gds;
                
                    gds = sec[3];
                    grid_template = code_table_3_1(sec);
                
                    switch (grid_template) {
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 40:
                        case 41:
                        case 42:
                        case 43:
                                 return gds+71; break;
                        case 10: return gds+59; break;
                        case 20: return gds+64; break;
                        case 30:
                        case 31: return gds+64; break;
                        case 50:
                        case 51:
                        case 52:
                        case 53:
                                 /* spectral modes don't have scan order */
                                 return NULL; break;
                        case 90: return gds+63; break;
                        case 110: return gds+56; break;
                        case 190: 
                	case 120: return gds+38; break;
                	case 204: return gds+71; break;
                        case 1000: return gds+50; break;
                	case 32768:
                		if (GB2_Center(sec) == NCEP) return gds+71;
                		return NULL;
                		break;
                	case 32769:
                		if (GB2_Center(sec) == NCEP) return gds+71;
                		return NULL;
                		break;
                        default: return NULL; break;
                    }
                    return NULL;
                }
                
                /*
                 * HEADER:-1:flag_table_3.5:inv:0:flag table 3.5 projection center
                 */
       ##### -> int f_flag_table_3_5(ARG0) {
                    int p;
                    if (mode >= 0) {
                        p = flag_table_3_5(sec);
                	if (p >= 0) {
                            sprintf(inv_out,"flag table 3.5=%d", p);
                	    inv_out += strlen(inv_out);
                        }
                    }
                    return 0;
                }
       ##### -> int flag_table_3_5(unsigned char **sec) {
                
                    unsigned char *gds;
                
                    gds = sec[3];
                    switch (code_table_3_1(sec)) {
                        case 20:
                        case 30:
                        case 31: return gds[63];
                        case 110: return gds[55];
                    }
                    return -1;
                }
                
                /*
                 * HEADER:-1:flag_table_3.9:inv:0:flag table 3.9 numbering order of diamonds seen from corresponding pole
                 */
                
       ##### -> int f_flag_table_3_9(ARG0) {
                    int p;
                    if (mode >= 0) {
                        p = flag_table_3_9(sec);
                        if (p >= 0) {
                            sprintf(inv_out,"flag table 3.9=%d", p);
                            inv_out += strlen(inv_out);
                        }
                    }
                    return 0;
                }
       ##### -> int flag_table_3_9(unsigned char **sec) {
                
                    unsigned char *gds;
                
                    gds = sec[3];
                    switch (code_table_3_1(sec)) {
                        case 100: return gds[32];
                    }
                    return -1;
                }
                /*
                 * HEADER:-1:flag_table_3.10:inv:0:flag table 3.10 scanning mode for one diamond
                 */
       ##### -> int f_flag_table_3_10(ARG0) {
                    int p;
                    if (mode >= 0) {
                        p = flag_table_3_10(sec);
                        if (p >= 0) {
                            sprintf(inv_out,"flag table 3.10=%d", p);
                            inv_out += strlen(inv_out);
                        }
                    }
                    return 0;
                }
       ##### -> int flag_table_3_10(unsigned char **sec) {
                    unsigned char *gds;
                    gds = sec[3];
                    switch (code_table_3_1(sec)) {
                        case 100: return gds[33];
                    }
                    return -1;
                }
                


Top 10 Lines:

     Line      Count

       35          2
       49          2
      118          2
      134          2

Execution Summary:

       15   Executable lines in this file
       15   Lines executed
   100.00   Percent of the file executed

        8   Total number of line executions
     0.53   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/g2clib-1.1.8/gbits.c:
                #include "grib2.h"
                
                void gbit(unsigned char *in,g2int *iout,g2int iskip,g2int nbyte)
        1734 -> {
                      gbits(in,iout,iskip,nbyte,(g2int)0,(g2int)1);
                }
                
                void sbit(unsigned char *out,g2int *in,g2int iskip,g2int nbyte)
       ##### -> {
                      sbits(out,in,iskip,nbyte,(g2int)0,(g2int)1);
                }
                
                
                void gbits(unsigned char *in,g2int *iout,g2int iskip,g2int nbyte,g2int nskip,
                           g2int n)
                /*          Get bits - unpack bits:  Extract arbitrary size values from a
                /          packed bit string, right justifying each value in the unpacked
                /          iout array.
                /           *in    = pointer to character array input
                /           *iout  = pointer to unpacked array output
                /            iskip = initial number of bits to skip
                /            nbyte = number of bits to take
                /            nskip = additional number of bits to skip on each iteration
                /            n     = number of iterations
                / v1.1
                */
        1751 -> {
                      g2int i,tbit,bitcnt,ibit,itmp;
                      g2int nbit,index;
                      static g2int ones[]={1,3,7,15,31,63,127,255};
                
                //     nbit is the start position of the field in bits
                      nbit = iskip;
                      for (i=0;i<n;i++) {
                         bitcnt = nbyte;
                         index=nbit/8;
                         ibit=nbit%8;
                         nbit = nbit + nbyte + nskip;
                
                //        first byte
                         tbit= ( bitcnt < (8-ibit) ) ? bitcnt : 8-ibit;  // find min
                         itmp = (int)*(in+index) & ones[7-ibit];
                         if (tbit != 8-ibit) itmp >>= (8-ibit-tbit);
                         index++;
                         bitcnt = bitcnt - tbit;
                
                //        now transfer whole bytes
                         while (bitcnt >= 8) {
                             itmp = itmp<<8 | (int)*(in+index);
                             bitcnt = bitcnt - 8;
                             index++;
                         }
                
                //        get data from last byte
                         if (bitcnt > 0) {
                             itmp = ( itmp << bitcnt ) | ( ((int)*(in+index) >> (8-bitcnt)) & ones[bitcnt-1] );
                         }
                
                         *(iout+i) = itmp;
                      }
                }
                
                
                void sbits(unsigned char *out,g2int *in,g2int iskip,g2int nbyte,g2int nskip,
                           g2int n)
                /*C          Store bits - pack bits:  Put arbitrary size values into a
                /          packed bit string, taking the low order bits from each value
                /          in the unpacked array.
                /           *iout  = pointer to packed array output
                /           *in    = pointer to unpacked array input
                /            iskip = initial number of bits to skip
                /            nbyte = number of bits to pack
                /            nskip = additional number of bits to skip on each iteration
                /            n     = number of iterations
                / v1.1
                */
       ##### -> {
                      g2int i,bitcnt,tbit,ibit,itmp,imask,itmp2,itmp3;
                      g2int nbit,index;
                      static g2int ones[]={1,3,7,15,31,63,127,255};
                
                //     number bits from zero to ...
                //     nbit is the last bit of the field to be filled
                
                      nbit = iskip + nbyte - 1;
                      for (i=0;i<n;i++) {
                         itmp = *(in+i);
                         bitcnt = nbyte;
                         index=nbit/8;
                         ibit=nbit%8;
                         nbit = nbit + nbyte + nskip;
                
                //        make byte aligned 
                         if (ibit != 7) {
                             tbit= ( bitcnt < (ibit+1) ) ? bitcnt : ibit+1;  // find min
                             imask = ones[tbit-1] << (7-ibit);
                             itmp2 = (itmp << (7-ibit)) & imask;
                             itmp3 = (int)*(out+index) & (255-imask);
                             out[index] = (unsigned char)(itmp2 | itmp3);
                             bitcnt = bitcnt - tbit;
                             itmp = itmp >> tbit;
                             index--;
                         }
                
                //        now byte aligned
                
                //        do by bytes
                         while (bitcnt >= 8) {
                             out[index] = (unsigned char)(itmp & 255);
                             itmp = itmp >> 8;
                             bitcnt = bitcnt - 8;
                             index--;
                         }
                
                //        do last byte
                
                         if (bitcnt > 0) {
                             itmp2 = itmp & ones[bitcnt-1];
                             itmp3 = (int)*(out+index) & (255-ones[bitcnt-1]);
                             out[index] = (unsigned char)(itmp2 | itmp3);
                         }
                      }
                
                }


Top 10 Lines:

     Line      Count

       27       1751
        4       1734

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

     3485   Total number of line executions
   871.25   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/g2clib-1.1.8/g2_unpack5.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include "grib2.h"
                
                
                g2int g2_unpack5(unsigned char *cgrib,g2int *iofst,g2int *ndpts,g2int *idrsnum,
                               g2int **idrstmpl,g2int *mapdrslen)
                ////$$$  SUBPROGRAM DOCUMENTATION BLOCK
                //                .      .    .                                       .
                // SUBPROGRAM:    g2_unpack5 
                //   PRGMMR: Gilbert         ORG: W/NP11    DATE: 2002-10-31
                //
                // ABSTRACT: This subroutine unpacks Section 5 (Data Representation Section)
                //           as defined in GRIB Edition 2.
                //
                // PROGRAM HISTORY LOG:
                // 2002-10-31  Gilbert
                // 2009-01-14  Vuong     Changed structure name template to gtemplate
                //
                // USAGE:    int g2_unpack5(unsigned char *cgrib,g2int *iofst,g2int *ndpts,
                //                          g2int *idrsnum,g2int **idrstmpl,g2int *mapdrslen)
                //   INPUT ARGUMENTS:
                //     cgrib    - char array containing Section 5 of the GRIB2 message
                //     iofst    - Bit offset for the beginning of Section 5 in cgrib.
                //
                //   OUTPUT ARGUMENTS:      
                //     iofst    - Bit offset at the end of Section 5, returned.
                //     ndpts    - Number of data points unpacked and returned.
                //     idrsnum  - Data Representation Template Number ( see Code Table 5.0)
                //     idrstmpl - Pointer to an integer array containing the data values for 
                //                the specified Data Representation
                //                Template ( N=idrsnum ).  Each element of this integer
                //                array contains an entry (in the order specified) of Data
                //                Representation Template 5.N
                //     mapdrslen- Number of elements in idrstmpl[].  i.e. number of entries
                //                in Data Representation Template 5.N  ( N=idrsnum ).
                //
                //   RETURN VALUES:
                //     ierr     - Error return code.
                //                0 = no error
                //                2 = Not Section 5
                //                6 = memory allocation error
                //                7 = "GRIB" message contains an undefined Data
                //                    Representation Template.
                //
                // REMARKS: None
                //
                // ATTRIBUTES:
                //   LANGUAGE: C
                //   MACHINE:  
                //
                //$$$//
          17 -> {
                      g2int ierr,needext,i,j,nbits,isecnum;
                      g2int lensec,isign,newlen;
                      g2int *lidrstmpl=0;
                      gtemplate *mapdrs;
                
                      ierr=0;
                      *idrstmpl=0;       //NULL
                
                      gbit(cgrib,&lensec,*iofst,32);        // Get Length of Section
                      *iofst=*iofst+32;
                      gbit(cgrib,&isecnum,*iofst,8);         // Get Section Number
                      *iofst=*iofst+8;
                
                      if ( isecnum != 5 ) {
                         ierr=2;
                         *ndpts=0;
                         *mapdrslen=0;
                        // fprintf(stderr,"g2_unpack5: Not Section 5 data.\n");
                         return(ierr);
                      }
                
                      gbit(cgrib,ndpts,*iofst,32);    // Get num of data points
                      *iofst=*iofst+32;
                      gbit(cgrib,idrsnum,*iofst,16);     // Get Data Rep Template Num.
                      *iofst=*iofst+16;
                
                      //   Gen Data Representation Template
                      mapdrs=getdrstemplate(*idrsnum);
                      if (mapdrs == 0) {
                        ierr=7;
                        *mapdrslen=0;
                        return(ierr);
                      }
                      *mapdrslen=mapdrs->maplen;
                      needext=mapdrs->needext;
                      //
                      //   Unpack each value into array ipdstmpl from the
                      //   the appropriate number of octets, which are specified in
                      //   corresponding entries in array mapdrs.
                      //
                      if (*mapdrslen > 0) lidrstmpl=(g2int *)calloc(*mapdrslen,sizeof(g2int));
                      if (lidrstmpl == 0) {
                         ierr=6;
                         *mapdrslen=0;
                         *idrstmpl=0;     //NULL
                         if ( mapdrs != 0 ) free(mapdrs);
                         return(ierr);
                      }
                      else {
                         *idrstmpl=lidrstmpl;
                      }
                      for (i=0;i<mapdrs->maplen;i++) {
                        nbits=abs(mapdrs->map[i])*8;
                        if ( mapdrs->map[i] >= 0 ) {
                          gbit(cgrib,lidrstmpl+i,*iofst,nbits);
                        }
                        else {
                          gbit(cgrib,&isign,*iofst,1);
                          gbit(cgrib,lidrstmpl+i,*iofst+1,nbits-1);
                          if (isign == 1) lidrstmpl[i]=-1*lidrstmpl[i];
                        }
                        *iofst=*iofst+nbits;
                      }
                      //
                      //   Check to see if the Data Representation Template needs to be
                      //   extended.
                      //   The number of values in a specific gtemplate may vary
                      //   depending on data specified in the "static" part of the
                      //   gtemplate.
                      //
                      if ( needext == 1 ) {
                        free(mapdrs);
                        mapdrs=extdrstemplate(*idrsnum,lidrstmpl);
                        newlen=mapdrs->maplen+mapdrs->extlen;
                        lidrstmpl=(g2int *)realloc(lidrstmpl,newlen*sizeof(g2int));
                        *idrstmpl=lidrstmpl;
                        //   Unpack the rest of the Data Representation Template
                        j=0;
                        for (i=*mapdrslen;i<newlen;i++) {
                          nbits=abs(mapdrs->ext[j])*8;
                          if ( mapdrs->ext[j] >= 0 ) {
                            gbit(cgrib,lidrstmpl+i,*iofst,nbits);
                          }
                          else {
                            gbit(cgrib,&isign,*iofst,1);
                            gbit(cgrib,lidrstmpl+i,*iofst+1,nbits-1);
                            if (isign == 1) lidrstmpl[i]=-1*lidrstmpl[i];
                          }
                          *iofst=*iofst+nbits;
                          j++;
                        }
                        *mapdrslen=newlen;
                      }
                      if( mapdrs->ext != 0 ) free(mapdrs->ext);
                      if( mapdrs != 0 ) free(mapdrs);
                
                      return(ierr);    // End of Section 5 processing
                
                }


Top 10 Lines:

     Line      Count

       53         17

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       17   Total number of line executions
    17.00   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/Netcdf_sup.c:
                /******************************************************************************************
                
                vsm: test compilation with undefined USE_NETCDF...
                
                 This file is part of wgrib2 and is distributed under terms of the GNU General Public License
                 For details see, Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
                 Boston, MA  02110-1301  USA
                
                 Edition 2008.02.18
                
                 Sergey Varlamov
                 Kristian Nilssen
                 Wesley Ebisuzaki
                */
                
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <time.h>
                #include <math.h>
                #include <ctype.h>
                //#include "grb2.h"
                #include "wgrib2.h"
                #include "fnlist.h"
                #include "wgrib2nc.h"
                
                //#define DEBUG_NC
                
                #if defined USE_NETCDF3 || defined USE_NETCDF4
                
                /*
                 * Find UTC "seconds since 1970-01-01 00:00:00.0 0:00"
                 */
                double get_unixtime(int year, int month, int day, int hour,
                                    int minute, int second, int * err_code)
          34 -> {
                  struct tm t, *gmt_tm;
                  time_t local_t, gmt_t;
                  *err_code = 0;
                  t.tm_sec = second;
                  t.tm_min = minute;
                  t.tm_hour = hour;
                  t.tm_mday = day;
                  t.tm_mon = month - 1;
                  t.tm_year = year - 1900;
                  t.tm_isdst = 0;
                /*
                   vsm: for int(4) type max valid date range for mktime is
                   1902-2037 or 1970-2037 depending on C library implementation.
                */
                  if (sizeof(time_t) <= 4 && (year > 2037 || year < 1902))
                  {
                    *err_code = 1;
                    return 0;
                  }
                  local_t = mktime(&t);
                  /* Simple check that mktime realization returns "normal" expected values,
                  start of Epoch = 1970.01.01 */
                  if (year < 1970 && local_t >= 0)
                  {
                    *err_code = 2;
                    return 0;
                  }
                  if (year > 1970 && local_t <= 0)
                  {
                    *err_code = 3;
                    return 0;
                  }
                  gmt_tm = gmtime(&local_t);
                  gmt_t = mktime(gmt_tm);
                  return ((double)(local_t + (local_t-gmt_t)));
                }
                /*
                 * Create time string (UTC) from time
                 */
                char * get_unixdate(double utime, char * date_str)
       ##### -> {
                  struct tm *gmt;
                  time_t gmt_t;
                
                  gmt_t=(time_t)utime;
                  gmt = gmtime(&gmt_t);
                  sprintf(date_str,"%.4d.%.2d.%.2d %.2d:%.2d:%.2d UTC",
                  gmt->tm_year+1900,gmt->tm_mon+1,gmt->tm_mday,gmt->tm_hour,gmt->tm_min,gmt->tm_sec);
                  return date_str;
                }
                
                /*
                * remove characters from string
                */
                
                void delchars(char *s, int c)
          17 -> {
                  char *tail;
                  tail = s;
                  while (*s)
                  {
                    if (*s != c) *tail++ = *s;
                    s++;
                  }
                  *tail = 0;
                }
                
                /*
                * change any "old" characters into "new"
                */
                
                void rep_chars(char *s, int old, int new)
         136 -> {
                  while (*s)
                  {
                    if (*s == old) *s = new;
                    s++;
                  }
                }
                
                /*
                * makes units COARDS compliant: C -> Celsius g -> gram
                */
                
                void fix_units(char *s, int n)
           9 -> {
                // seems to be risky incrementing the pointer s...
                // modify to more safe having time. vsm
                  char tmp[n+2], *p;
                
                  tmp[0] = '+';
                  strncpy(tmp+1, s, n);
                  p = tmp+1;
                  *s = 0;
                
                  while (*p)
                  {
                    if (toupper(*p) == 'C' && !isalpha(p[1]) && !isalpha(p[-1]))
                    {
                      *s++ = 'C';
                      *s++ = 'e';
                      *s++ = 'l';
                      *s++ = 's';
                      *s++ = 'i';
                      *s++ = 'u';
                      *s++ = 's';
                      p++;
                    }
                    else if (toupper(*p) == 'G' && !isalpha(p[1]) && !isalpha(p[-1]))
                    {
                      *s++ = 'g';
                      *s++ = 'r';
                      *s++ = 'a';
                      *s++ = 'm';
                      p++;
                    }
                    else
                    {
                      *s++ = *p++;
                    }
                  }
                  *s = 0;
                }
                
                int get_nc_conv_table(const char * name, const char * level,
                                      const g2nc_table * nc_table)
       ##### -> {
                  int i;
                  if ( nc_table )
                    if ( nc_table->nvc )
                      for (i=0; i < nc_table->nvc; i++)
                        if ( strcmp(nc_table->vc[i].wgrib2_name, name) == 0 &&
                             strcmp(nc_table->vc[i].wgrib2_level, level) == 0 ) return i;
                  return -1;
                }
                
                int free_nc_table( g2nc_table * nc_table )
       ##### -> {
                  // cleanup
                  int i;
                  if ( nc_table == NULL ) return 0;
                  if ( nc_table->nvc > 0 && nc_table->vc )
                  {
                    for (i=0; i < nc_table->nvc; i++)
                    {
                      free(nc_table->vc[i].wgrib2_name);
                      free(nc_table->vc[i].wgrib2_level);
                      free(nc_table->vc[i].nc_name);
                    }
                  }
                  free(nc_table->vc);
                  free(nc_table->lt);
                  free(nc_table->lv);
                  free(nc_table);
                  nc_table = NULL;
                #ifdef DEBUG_NC
                fprintf(stderr,"nc_table: cleaned-up...\n");
                #endif
                  return 0;
                }
                
                g2nc_4Dlt nc_4Dlt[G2NC_NUM_4DLT] = {
                  { 20,"klevel","K level","K",1.,},             //"%g K level",
                  {100,"plevel","pressure level","mb",0.01,},   //"%g hPa",
                  {104,"slevel","sigma level","level",1.,},     //"%g sigma level",
                  {105,"hlevel","hybrid level","level",1.,},    //"%g hybrid level",
                  {107,"kilevel","K isentropic level","K",1.,}, //"%g K isentropic level",
                  {160,"depth","ocean depth","m",1.,},          //"%g m below sea level",
                };
                
                g2nc_table * nc_table = NULL; /* table undefined */
                /*
                 * HEADER:100:nc_grads:setup:0:require netcdf file to be grads v1.9b4 compatible (fixed time step only)
                 */
                int nc_grads_compatible = 0;
                
                int f_nc_grads(ARG0)
       ##### -> {
                  if (mode == -1) nc_grads_compatible = 1;
                  return 0;
                }
                
                /*
                 * HEADER:100:no_nc_grads:setup:0:netcdf file may be not grads v1.9b4 compatible, variable time step
                 */
                int f_no_nc_grads(ARG0)
       ##### -> {
                  if (mode == -1) nc_grads_compatible = 0;
                  return 0;
                }
                
                /*
                 * HEADER:100:nc_pack:setup:1:pack/check limits of all NEW input variables, X=min:max[:byte|short|float]
                 *
                 * NEW means that if some variable was already defined in the netcdf file and now is appended to it (-append mode)
                 * initially defined packing parameters are used. min and max are used to estimate appropriate offset and scaling,
                 * if both are zero - automatic scaling goes.
                 */
                int nc_pack = 0;
                float nc_pack_offset = 0.;
                float nc_pack_scale = 1.;
                float nc_valid_min = 0.;
                float nc_valid_max = 0.;
                
                int f_nc_pack(ARG1)
       ##### -> {
                  char * pack_to=NULL;
                  float range;
                  int i;
                  if (mode == -1)
                  {
                //fprintf(stderr,"nc_pack: get arg: %s\n", arg1);
                    pack_to = (char*) malloc((strlen(arg1)+12)*sizeof(char));
                    if (pack_to == NULL) fatal_error("nc_pack: error allocating tmp string","");
                    i = sscanf(arg1,"%g:%g:%s", &nc_valid_min, &nc_valid_max, pack_to);
                    if ( i < 2)
                    {
                      fatal_error("nc_pack: bad value, expect min:max[:byte|short|float(default)], found %s", arg1);
                //    if (sscanf(arg1,"%g:%g:%s", &nc_pack_offset, &nc_pack_scale, pack_to) != 3){
                //      fatal_error("netcdf: bad nc_pack, expect offset:scale:[byte|short], found %s", arg1);
                    }
                    range = (nc_valid_max - nc_valid_min);
                    if ( i == 2 ) strcpy(pack_to,"float");
                
                    if (strcmp(pack_to,"byte")==0 || strcmp(pack_to,"BYTE")==0 || strcmp(pack_to,"Byte")==0)
                      nc_pack = G2NC_PACK_BYTE;
                    else if (strcmp(pack_to,"short")==0 || strcmp(pack_to,"SHORT")==0 || strcmp(pack_to,"Short")==0)
                      nc_pack = G2NC_PACK_SHORT;
                    else if (strcmp(pack_to,"float")==0 || strcmp(pack_to,"FLOAT")==0 || strcmp(pack_to,"Float")==0)
                      nc_pack = G2NC_PACK_FLOAT; /* will check valid_range */
                    else
                      fatal_error("nc_pack: bad value, expect min:max:byte|short|float, found %s", arg1);
                    if ( nc_pack == G2NC_PACK_FLOAT && fabs(range) < 1e-20 ) fatal_error(
                      "nc_pack: small valid_range specified, expected min:max[:float], min<max, found %s", arg1);
                
                    /* Center near 0 as signed char or short are used. */
                    if (nc_pack != G2NC_PACK_FLOAT)
                    {
                      nc_pack_offset = (float)(nc_valid_max+nc_valid_min)*0.5;
                      if ( nc_pack == G2NC_PACK_BYTE )
                        nc_pack_scale = (float) (range/(G2NC_FILL_VALUE_BYTE - 2))*0.5;
                      else if ( nc_pack == G2NC_PACK_SHORT )
                        nc_pack_scale = (float) (range/(G2NC_FILL_VALUE_SHORT - 2))*0.5;
                    }
                    free(pack_to);
                
                //fprintf(stderr,"nc_pack: nc_pack=%d\n", nc_pack);
                
                  }
                  return 0;
                }
                
                /*
                 * HEADER:100:no_nc_pack:setup:0:no packing in netcdf for NEW variables
                 *
                 */
                int f_no_nc_pack(ARG0)
       ##### -> {
                  if (mode == -1)
                  {
                    nc_pack = 0;
                    nc_pack_scale = 1.;
                    nc_pack_offset = 0.;
                    nc_valid_min = 0.;
                    nc_valid_max = 0.;
                  }
                  return 0;
                }
                
                /*
                 * HEADER:100:nc_nlev:setup:1:netcdf, X = max LEV dimension for {TIME,LEV,LAT,LON} data
                 */
                int nc_nlev = 0;
                
                int f_nc_nlev(ARG1)
       ##### -> {
                  if (mode == -1)
                  {
                    if (sscanf(arg1,"%d", &nc_nlev) != 1)
                    {
                      fatal_error("netcdf: bad nc_nlev %s", arg1);
                    }
                    if (nc_nlev > G2NC_MAX_NLEV)
                    {
                      fatal_error("nc_nlev: value exceeds G2NC_MAX_NLEV, %s", arg1);
                    }
                  }
                  return 0;
                }
                
                /*
                 * HEADER:100:nc_table:setup:1:X is conversion_to_netcdf_table file name
                 */
                int f_nc_table(ARG1)
       ##### -> {
                  char   input[_MAX_PATH], on[_MAX_PATH], lv[_MAX_PATH],
                         nn[_MAX_PATH], pk[_MAX_PATH], defl[_MAX_PATH], ctmp[_MAX_PATH];
                  char * prd;
                  FILE * fl;
                  int i, ir, ierr, itmp;
                  g2nc_conv * old_nct;
                  float min, max, range, ftmp;
                
                  if (mode == -1)
                  {
                    /* avoid 'lost memory' */
                    if ( nc_table )
                      if ( !nc_table->used)
                        fatal_error("nc_table: second table name entered when first was not used: %s", arg1);
                
                    fl = fopen(arg1,"r");
                    if(fl == NULL)
                      fatal_error("nc_table: can not open file for reading: %s", arg1);
                
                    /* Deconnect from allocated memory, it is mapped in some 'local' structure,
                     * and allocate new instance
                     */
                    nc_table = (g2nc_table*)malloc(sizeof(g2nc_table));
                    if ( nc_table == NULL )
                      fatal_error("nc_table: error allocating new table: %s", arg1);
                
                    nc_table->vc = NULL;
                    nc_table->lt = NULL;
                    nc_table->lv = NULL;
                    nc_table->nvc = 0;
                    nc_table->used = 0;
                    nc_table->nlev = -1;
                    nc_table->grads = -1;
                    nc_table->endianness = -1;
                
                    ierr = 0;
                
                    while(!feof(fl))
                    {/* read strings including \n symbol */
                      prd = fgets(input, _MAX_PATH, fl);
                      if(prd == NULL) continue;
                      if(strlen(input) < 2)continue;
                      /* format:
                
                wgib2_name:wgrib2_level|*:nc_name|ignore[:ignore|no|float|deflate{0-9}|[short|byte:min:max]][:deflate{0-9}]
                
                         or/and special instructions that overcome command-line options
                         for the netcdf file they are applied:
                
                           # 4D level type description: grib2_type:user_short_name:user:long_name:user_units:scale_to_user_units
                           $lev_type 100:plevel:pressure level:mb:0.01   #JMA MSM model upper layer (p) data; scale: Pa->mb
                           $nlev 3   #number of vertical levels for 4D variables
                           $levs 1000 500 100  #vertical level values in user_units, at least nlev;
                                 50 10
                           $endianness native|little-endian|big-endian
                
                         Length of input strings must be less then _MAX_PATH or 256 symbols,
                         input on multiple lines is supported.
                         The "deflate{0-9}" directive is supported only if netCDF-4 type new file is created;
                         deflate0 means "no compression", other values define compression level. Default is 1.
                       */
                //
                //    next do not work as expected, parse string 'manually', it's C...
                //    ir = sscanf(input," %[^:]s:%[^:]s%[^:\n]s%[^:\n]s:%g:%g",
                //                     on,    lv,    nn,      pk,    &min, &max);
                      ir=0;
                      min=max=0;
                      prd = input;
                      i = sscanf(prd," %[^:]s",on);
                      if (i < 1) continue;
                      if (on[0]=='#' || on[0]=='\n') continue;  /* comment or line of spaces only, pass */
                      if (on[0]=='$')
                      {
                        /* specification of vertical level for 4D variables in grib2 to netcdf conversion */
                        if (strncmp(on,"$nlev",5) == 0 || strncmp(nn,"$NLEV",5) == 0)
                        {
                          itmp = -1;
                          i = sscanf(prd," %*s %d",&itmp);
                          if ( i < 1 || itmp < 0 || itmp > G2NC_MAX_NLEV)
                          {
                            fprintf(stderr,"nc_table: large value or error in $nlev definition string:\n%s\n", prd);
                            ierr = -1;
                            break;
                          }
                          if (nc_table->nlev >= 0)
                          {
                            fprintf(stderr,"nc_table: found dublicate $nlev definition, was %d, new:\n%s\n",
                            nc_table->nlev,prd);
                            ierr = -2;
                            break;
                          }
                          nc_table->nlev=itmp;
                        }
                        else if (strncmp(on,"$grads",6) == 0 || strncmp(nn,"$GRADS",6) == 0)
                        {
                          itmp = -1;
                          i = sscanf(prd," %*s %d",&itmp);
                          if ( i < 1 || itmp < 0 || itmp > 1)
                          {
                            fprintf(stderr,"nc_table: use 0 or 1 in $grads definition string:\n%s\n", prd);
                            ierr = -1;
                            break;
                          }
                          if (nc_table->grads >= 0)
                          {
                            fprintf(stderr,"nc_table: found dublicate $grads definition, was %d, new:\n%s\n",
                            nc_table->grads,prd);
                            ierr = -2;
                            break;
                          }
                          nc_table->grads=itmp;
                        }
                        else if (strncmp(on,"$lev_type",9) == 0 || strncmp(nn,"$LEV_TYPE",9) == 0)
                        {
                          /* parse input string */
                          i = sscanf(prd," %*s %d:",&itmp); /* type */
                          if ( i >= 1 )
                          {
                            ir++;
                            i = strcspn( prd, ":");
                            if (i > 0 && i < strlen(prd) )
                            {
                              prd += (i+1);
                              i = sscanf(prd," %[^: ]s",nn); /* sname, no spaces */
                              if (i >= 1 )
                              {
                                ir++;
                                i = strcspn( prd, ":");
                                if (i > 0 && i < strlen(prd) )
                                {
                                  prd += (i+1);
                                  i = sscanf(prd," %[^:]s",lv); /* lname */
                                  if (i >= 1 )
                                  {
                                    ir++;
                                    i = strcspn( prd, ":");
                                    if (i > 0 && i < strlen(prd) )
                                    {
                                      prd += (i+1);
                                      i = sscanf(prd," %[^:#\n]s",pk); /* units could be last */
                                      if (i >= 1 )
                                      {
                                        ir++;
                                        i = strcspn( prd, ":");
                                        if (i > 0 && i < strlen(prd) )
                                        {
                                          prd += (i+1);
                                          i = sscanf(prd," %g",&ftmp); /* scale */
                                          if (i >= 1 )
                                          {
                                            ir++;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                          if ( ir < 4 )
                          {
                            ierr = -3;
                            fprintf(stderr,"nc_table: error %d in $lev_type definition string:\n%s\n", ir,on);
                            break;
                          }
                          if ( nc_table->lt != NULL )
                          {
                            fprintf(stderr,"nc_table: found dublicate $lev_type definition:\n%s\n",on);
                            ierr = -4;
                            break;
                          }
                          nc_table->lt = (g2nc_4Dlt*)malloc(sizeof(g2nc_4Dlt));
                          if ( ir > 4 )nc_table->lt->scale = ftmp;
                          else         nc_table->lt->scale = 1;
                          nc_table->lt->type = itmp;
                          nc_table->lt->sname = (char *)malloc((strlen(nn)+1)*sizeof(char));
                          if (nc_table->lt->sname) strcpy(nc_table->lt->sname,nn);
                          else ierr = 1;
                          nc_table->lt->lname = (char *)malloc((strlen(lv)+1)*sizeof(char));
                          if (nc_table->lt->lname) strcpy(nc_table->lt->lname,lv);
                          else ierr = 2;
                          nc_table->lt->units = (char *)malloc((strlen(pk)+1)*sizeof(char));
                          if (nc_table->lt->units) strcpy(nc_table->lt->units,pk);
                          else ierr = 3;
                          if ( ierr ) break;
                        }
                        else if (strncmp(on,"$levs",5) == 0 || strncmp(nn,"$LEVS",5) == 0)
                        {
                          if ( nc_table->lv )
                          {
                            fprintf(stderr,"nc_table: found dublicate $levs definition:\n%s\n",on);
                            ierr = -5;
                            break;
                          }
                          if (nc_table->nlev > 0)
                          {
                            nc_table->lv = (float *)malloc(nc_table->nlev*sizeof(float));
                            if ( nc_table->lv == NULL )
                            {
                              ierr = 4;
                              break;
                            }
                          }
                          else
                          {
                            fprintf(stderr,"nc_table: found $levs directive for undef $nlev:\n%s\n",prd);
                            ierr = -6;
                            break;
                          }
                          i = strcspn( prd, "$");
                          prd += (i+4+1);
                
                          for (i=0; i < nc_table->nlev; i++)
                          {
                            search_lev: ir = strcspn(prd,"+-.0123456789");
                            itmp = strcspn(prd,"#"); /* inline comment */
                            if ( ir < 0 || ir >= strlen(prd) || itmp < ir )
                            { /* read next line */
                              prd = fgets(input, _MAX_PATH, fl);
                              if (prd == NULL )
                              {
                                fprintf(stderr,"nc_table: error reading multy line $levs \n");
                                ierr = -7;
                                break;
                              }
                              goto search_lev;
                            }
                            itmp = strcspn(prd,":"); /* second important fields separator before number */
                            if (itmp <= ir )
                            {
                              fprintf(stderr,"nc_table: error entering $levs, check that there are $nlev values defined\n");
                              ierr = -8;
                              break;
                            }
                            prd += ir;
                            ir = sscanf(prd,"%g",&nc_table->lv[i]);
                            if ( ir < 1 )
                            {
                              fprintf(stderr,"nc_table: $levs formatted input error\n");
                              ierr = -9;
                              break;
                            }
                            ir = strcspn(prd," ,;:\n");
                            if(ir <= strlen(prd) ) prd += ir;
                            else
                            {
                              fprintf(stderr,"nc_table: $levs parsing error, do no found fields separator\n");
                              ierr = -10;
                              break;
                            }
                          }
                          if ( ierr ) break;
                        }
                        else if (strncmp(on,"$endianness",11) == 0 || strncmp(nn,"$ENDIANNESS",11) == 0)
                        {
                          *ctmp = 0;
                          itmp = 0;
                          i = sscanf(prd," %*s %[^ #\n]s",ctmp); /* could be last, no spaces */
                          if ( i >= 1){
                            if (strcmp(ctmp,"native")==0 || strcmp(ctmp,"NATIVE")==0 || strcmp(ctmp,"Native")==0)
                            {
                              nc_table->endianness = 0;
                            }
                            else if (strcmp(ctmp,"little-endian")==0 || strcmp(ctmp,"LITTLE-ENDIAN")==0)
                            {
                              nc_table->endianness = 1;
                            }
                            else if (strcmp(ctmp,"big-endian")==0 || strcmp(ctmp,"BIG-ENDIAN")==0)
                            {
                              nc_table->endianness = 2;
                            }
                            else
                            {
                              itmp = 1;
                            }
                          }
                          if ( i < 1 || itmp == 1)
                          {
                            fprintf(stderr,"nc_table: use native, little-endian or big-endian strings in $endianness definition:\n%s\n", prd);
                            ierr = -1;
                            break;
                          }
                          /* dublicates do not checked, last found value would be used for endianness */
                        }
                        else
                        {
                          fprintf(stderr,"nc_table: found unrecognized directive:\n%s\n", prd);
                          ierr = -11;
                          break;
                        }
                        continue;
                      }
                /********************************************************************
                      grib2 to netcdf variable convertion rule string parsing
                ********************************************************************/
                      ir++;
                      i = strcspn( prd, ":");
                      if (i > 0 && i < strlen(prd) )
                      {
                        prd += (i+1);
                        i = sscanf(prd," %[^:]s",lv);
                        if (i >= 1 )
                        {
                          ir++;
                          i = strcspn( prd, ":");
                          if (i > 0 && i < strlen(prd) )
                          {
                            prd += (i+1);
                            i = sscanf(prd," %[^: #\n]s",nn); /* could be last, no spaces */
                            if (i >= 1 )
                            {
                              ir++;
                              i = strcspn( prd, ":");
                              if (i > 0 && i < strlen(prd) )
                              {
                                prd += (i+1);
                                i = sscanf(prd," %[^: #\n]s",pk);  /* could be last, no spaces */
                                if (i >= 1 )
                                {
                                  ir++;
                                  i = strcspn( prd, ":");
                                  if (i > 0 && i < strlen(prd) )
                                  {
                                    prd += (i+1);
                                    i = strcspn( prd, ":");
                                    if (i > 0 && i < strlen(prd) ) //one more separator found, min:max
                                    {
                //                      i = sscanf(prd," %g: %g",&offset, &scale);
                                      i = sscanf(prd," %g: %g",&min, &max);
                                      if (i >= 2 )
                                      {
                                        ir += i;
                                        i = strcspn( prd, ":");
                                        if (i > 0 && i < strlen(prd) )
                                        {
                                          prd += (i+1);
                                          i = strcspn( prd, ":");
                                          if (i > 0 && i < strlen(prd) )
                                          {
                                            prd += (i+1);
                                            i = sscanf(prd," %[^: #\n]s",defl);  /* must be last, no spaces */
                                            ir += i;
                                          }
                                        }
                                      }
                                    }
                                    else /* no separators more, single last input string*/
                                    {
                                      i = sscanf(prd," %[^: #\n]s",defl);  /* could be last, no spaces */
                                      ir += i;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      if ( ir < 3 )
                      {
                        /* not eligible string, issue warning and pass */
                //        fprintf(stderr,"nc_table: badly formatted string, ignore: %s",input);
                //        continue;
                        fprintf(stderr,"nc_table: badly formatted string:\n %s",input);
                        ierr = -21;
                        break;
                      }
                      if ( nc_table->nvc > G2NC_MAX_VARS )
                      {
                        fprintf(stderr,"nc_table: nvc exceed G2NC_MAX_VARS: %d %d\n",
                        nc_table->nvc, G2NC_MAX_VARS);
                        ierr = -22;
                        break;
                      }
                      i = nc_table->nvc;
                      nc_table->nvc++;
                      old_nct = nc_table->vc;
                
                      nc_table->vc = (g2nc_conv*) realloc((void*)old_nct, nc_table->nvc*sizeof(g2nc_conv));
                      nc_table->vc[i].ignore = 0;
                      nc_table->vc[i].nc_pack = 0;
                      nc_table->vc[i].nc_offset = 0.;
                      nc_table->vc[i].nc_scale = 1.;
                      nc_table->vc[i].nc_valid_min = 0.;
                      nc_table->vc[i].nc_valid_max = 0.;
                      nc_table->vc[i].nc_deflate = 1;
                      nc_table->vc[i].wgrib2_name = (char *)malloc((strlen(on)+1)*sizeof(char));
                      if (nc_table->vc[i].wgrib2_name)
                        strcpy(nc_table->vc[i].wgrib2_name,on);
                      else
                      {
                        ierr = 21;
                        break;
                      }
                      nc_table->vc[i].wgrib2_level = (char *)malloc((strlen(lv)+1)*sizeof(char));
                      if (nc_table->vc[i].wgrib2_level)
                        strcpy(nc_table->vc[i].wgrib2_level,lv);
                      else
                      {
                        ierr = 22;
                        break;
                      }
                      nc_table->vc[i].nc_name = (char *)malloc((strlen(nn)+1)*sizeof(char));
                      if (nc_table->vc[i].nc_name)
                      {
                        strcpy(nc_table->vc[i].nc_name,nn);
                        if (strcmp(nn,"ignore")==0 || strcmp(nn,"IGNORE")==0 || strcmp(nn,"Ignore")==0)
                          nc_table->vc[i].ignore = 1;
                      }
                      else
                      {
                        ierr = 23;
                        break;
                      }
                      if (ir < 4)continue;
                
                      range = (max - min);
                      if (strcmp(pk,"byte")==0 || strcmp(pk,"BYTE")==0 || strcmp(pk,"Byte")==0)
                      {
                        nc_table->vc[i].nc_pack = G2NC_PACK_BYTE;
                        nc_table->vc[i].nc_scale = (float) (range/(G2NC_FILL_VALUE_BYTE - 2))*0.5;
                      }
                      else if (strcmp(pk,"short")==0 || strcmp(pk,"SHORT")==0 || strcmp(pk,"Short")==0)
                      {
                        nc_table->vc[i].nc_pack = G2NC_PACK_SHORT;
                        nc_table->vc[i].nc_scale = (float) (range/(G2NC_FILL_VALUE_SHORT - 2))*0.5;
                      }
                      else if (strcmp(pk,"float")==0 || strcmp(pk,"FLOAT")==0 || strcmp(pk,"Float")==0)
                      {
                        nc_table->vc[i].nc_pack = G2NC_PACK_FLOAT;
                      }
                      else if (strcmp(pk,"ignore")==0 || strcmp(pk,"IGNORE")==0 || strcmp(pk,"Ignore")==0)
                      {
                        nc_table->vc[i].ignore = 1;
                        continue;
                      }
                      else if (strcmp(pk,"no") == 0 || strcmp(pk,"NO") == 0 )
                      {
                        continue;
                      }
                      else if (strncmp(pk,"deflate",7)==0 || strncmp(pk,"DEFLATE",7)==0 || strncmp(pk,"Deflate",7)==0)
                      {
                        if ( strlen(pk) > 7 && isdigit((int)pk[7]))
                        {
                          nc_table->vc[i].nc_deflate = (int)pk[7];
                          continue;
                        }
                        else
                        {
                          fprintf(stderr,"nc_table: unsupported deflate definition, ignored: %s in %s",pk,input);
                          continue;  /* not eligible string, warning and pass */
                        }
                      }
                      else
                      {
                        fprintf(stderr,"nc_table: unsupported packing type, ignored: %s in %s",pk,input);
                        continue;  /* not eligible string, warning and pass */
                      }
                      if (nc_table->vc[i].nc_pack == G2NC_PACK_FLOAT)
                      {
                        if (fabs(range) < 1e-20)
                        {
                          fprintf(stderr,"nc_table: small valid_range specified, expected ...:float:{min}:{max}, min<max: %s",input);
                          ierr = 23;
                          break;
                        }
                      }
                      else  nc_table->vc[i].nc_offset = (float) (min+max)*0.5;
                
                      nc_table->vc[i].nc_valid_min=min;
                      nc_table->vc[i].nc_valid_max=max;
                
                      if (strncmp(defl,"deflate",7)==0 || strncmp(defl,"DEFLATE",7)==0 || strncmp(defl,"Deflate",7)==0)
                      {
                        if ( strlen(defl) > 7 && isdigit((int)defl[7]))
                        {
                          nc_table->vc[i].nc_deflate = (int)defl[7];
                          continue;
                        }
                        else
                        {
                          fprintf(stderr,"nc_table: unsupported deflate definition, ignored: %s in %s",defl,input);
                          continue;  /* not eligible string, warning and pass */
                        }
                      }
                    }
                    fclose(fl);
                    if( ierr )
                    {
                      if ( ierr > 0 ) fprintf(stderr,"nc_table: allocation error\n");
                      fatal_error("nc_table: fatal error parsing file %s", arg1);
                    }
                
                #ifdef DEBUG_NC
                fprintf(stderr, "nc_table: total found: %d entries\n",nc_table->nvc);
                for (i=0; i < nc_table->nvc; i++)
                {
                  fprintf(stderr, "%2d) %s:%s:%s:%d:%d:%f:%f:%f:%f:%d\n",i,
                    nc_table->vc[i].wgrib2_name,
                    nc_table->vc[i].wgrib2_level,
                    nc_table->vc[i].nc_name,
                    nc_table->vc[i].ignore,
                    nc_table->vc[i].nc_pack,
                    nc_table->vc[i].nc_valid_min,
                    nc_table->vc[i].nc_valid_max,
                    nc_table->vc[i].nc_offset,
                    nc_table->vc[i].nc_scale,
                    nc_table->vc[i].nc_deflate);
                }
                fprintf(stderr, "nc_table: $endianness=%d\n",nc_table->endianness);
                if (nc_table->nlev >= 0)
                {
                  fprintf(stderr, "nc_table: $nlev=%d\n",nc_table->nlev);
                  if (nc_table->lv)
                    for (i=0; i < nc_table->nlev; i++)
                      fprintf(stderr, "lev(%d)=%g\n",i,nc_table->lv[i]);
                }
                if( nc_table->lt )
                {
                  fprintf(stderr, "nc_table: found $lev_type directive:\n");
                  fprintf(stderr, "$lev_type = %d:%s:%s:%s:%g\n",
                    nc_table->lt->type,  nc_table->lt->sname,
                    nc_table->lt->lname, nc_table->lt->units,
                    nc_table->lt->scale);
                }
                #endif
                  }
                  return 0;
                }
                
                /*
                 * HEADER:100:no_nc_table:setup:0:disable previously defined conversion_to_netcdf_table
                 */
                int f_no_nc_table(ARG0)
       ##### -> {
                  if (mode == -1)
                  {
                    if (nc_table)
                    {
                      if (nc_table->used)
                      { /* disconnect from allocated memory, it is mapped in some 'local' structure */
                       nc_table = NULL;
                      }
                      else fatal_error("no_nc_table: disabling not used -nc_table, is it your intention?","");
                    }
                  }
                  return 0;
                }
                /*
                 * HEADER:100:nc_time:setup:1:netcdf, [[-]yyyymmddhhnnss]:[dt{s[ec]|m[in]|h[our]|d[ay]}], [-] is for time alignment only
                 */
                //nc_time option [+|-]{yyyymmddhhnn}:{dt}[mn|hr|dy]
                double nc_date0 = 0;      /* undefined value... */
                int    nc_date0_type = 0; /* undefined; 1 for absolute, -1 for relative (alignment only) */
                double nc_dt = 0;         /* not initialized; -1 will be used for variable (undefined) step */
                
                int f_nc_time(ARG1)
       ##### -> {
                  char *p, chr;
                  int year,month,day,hour,minute,second,dt_val,dt_conv,err_code;
                  char dt_type[25];
                
                  if (mode == -1)
                  {
                
                    if (strlen(arg1) == 0) return 0;
                    /* default initialization, clear any previously defined values */
                    nc_date0_type = 0;
                    nc_date0 = 0;
                    nc_dt = 0;
                
                    sscanf(arg1,"%c",&chr);
                
                    p=arg1;
                    if (chr==':')
                    { /* separator symbol is first, time step only, any long string*/
                      p++;
                      goto get_time_step;
                    }
                    if (strlen(p) < 14)
                    { /* time step only */
                      goto get_time_step;
                    }
                    /* include date */
                    nc_date0_type = 1;    /*absolute */
                    if (chr=='-')
                    {
                      p++;
                      nc_date0_type = -1; /* relative*/
                    }
                    else if (chr == '+')
                    {
                      p++;
                    }
                    if (sscanf(p,"%4d%2d%2d%2d%2d%2d",&year,&month,&day,&hour,&minute,&second) != 6)
                      fatal_error("nc_time: bad format of yyyymmddhhnnss value in nc_time: %s", arg1);
                
                    if(year<0 || year>9999 || month<1 || month>12 || day<1 || day>31 ||
                       hour <0 || hour>23 || minute < 0 || minute >59 || second < 0 || second >59)
                      fatal_error("nc_time: bad value of yyyymmddhhnnss value in nc_time: %s", arg1);
                
                #ifdef DEBUG_NC
                printf("nc_time: date0_type=%d date0=%d.%d.%d %d:%d:%d\n",nc_date0_type,year,month,day,hour,minute,second);
                #endif
                    nc_date0 = get_unixtime(year, month, day, hour, minute, second, &err_code);
                    if(err_code)
                      fatal_error("nc_time: time [sec] is out of range for this OS","");
                
                    p+=14;
                    if (strlen(p) <= 1)
                    {
                      if (nc_date0_type > 0) return 0;
                      fatal_error("nc_time: negative yyyymmddhhnnss (relative date) need time step in -nc_time option: %s", arg1);
                    }
                    p++; /*pass separator symbol ':' or other*/
                
                get_time_step:
                
                    if (sscanf(p,"%d%s",&dt_val,dt_type) != 2)
                      fatal_error("nc_time: bad time step in nc_time: %s", p);
                
                    if( strlen(dt_type) == 0)
                      fatal_error("nc_time: undef time step type in nc_time: %s", arg1);
                
                    p = dt_type;
                    dt_conv=0;
                    if (*p=='s' || *p=='S')
                     dt_conv=1;
                    else if (*p=='m' || *p=='M')
                     dt_conv=60;
                    else if (*p=='h' || *p=='H')
                     dt_conv=3600;
                    else if (*p=='d' || *p=='D')
                     dt_conv=86400;
                    else
                      fatal_error("nc_time: unsupported time step type in nc_time: %s", p);
                
                //    if (align_only && dt_conv > 86400*30) // unclear behavior for monthly data...
                //      fatal_error("netcdf: unsupported large time increment in nc_time %s", arg1);
                    nc_dt = (double)dt_val*(double)dt_conv;  // convert to seconds
                
                #ifdef DEBUG_NC
                printf("nc_time: time_step_value=%d, type=%s, val_sec=%.1lf\n",dt_val,dt_type,nc_dt);
                #endif
                  }
                  return 0;
                }
                /*
                 * HEADER:100:no_nc_time:setup:0:netcdf, disable previously defined initial or relative date and time step
                 */
                int f_no_nc_time(ARG0)
       ##### -> {
                  if (mode == -1)
                  {
                    nc_date0 = 0;      /* undefined value... */
                    nc_date0_type = 0; /* undefined; 1 for absolute, -1 for relative (alignment only) */
                    nc_dt = 0;         /* not initialized; -1 will be used for variable (undefined) step */
                  }
                  return 0;
                }
                /*
                 * HEADER:100:nc4:setup:0:use netcdf4 (compressed, controlled endianness etc)
                 */
                int nc4 = 0;
                
                int f_nc4(ARG0)
       ##### -> {
                  if (mode == -1) nc4 = 1;
                  return 0;
                }
                /*
                 * HEADER:100:nc3:setup:0:use netcdf3 (classic)
                 */
                int f_nc3(ARG0)
       ##### -> {
                  if (mode == -1) nc4 = 0;
                  return 0;
                }
                
                #else
                
                int f_nc_nlev(ARG1)
                {
                  if (mode == -1) {fprintf(stderr,"netcdf package not installed\n"); return 1;}
                  return 0;
                }
                int f_nc_pack(ARG1)
                {
                  if (mode == -1) {fprintf(stderr,"netcdf package not installed\n"); return 1;}
                  return 0;
                }
                int f_nc_table(ARG1)
                {
                  if (mode == -1) {fprintf(stderr,"netcdf package not installed\n"); return 1;}
                  return 0;
                }
                int f_no_nc_table(ARG0)
                {
                  if (mode == -1) {fprintf(stderr,"netcdf package not installed\n"); return 1;}
                  return 0;
                }
                int f_no_nc_pack(ARG0)
                {
                  if (mode == -1) {fprintf(stderr,"netcdf package not installed\n"); return 1;}
                  return 0;
                }
                int f_nc_grads(ARG0)
                {
                  if (mode == -1) {fprintf(stderr,"netcdf package not installed\n"); return 1;}
                  return 0;
                }
                int f_no_nc_grads(ARG0)
                {
                  if (mode == -1) {fprintf(stderr,"netcdf package not installed\n"); return 1;}
                  return 0;
                }
                int f_nc_time(ARG1)
                {
                  if (mode == -1) {fprintf(stderr,"netcdf package not installed\n"); return 1;}
                  return 0;
                }
                int f_no_nc_time(ARG0)
                {
                  if (mode == -1) {fprintf(stderr,"netcdf package not installed\n"); return 1;}
                  return 0;
                }
                int f_nc4(ARG0)
                {
                  if (mode == -1) {fprintf(stderr,"netcdf package not installed\n"); return 1;}
                  return 0;
                }
                int f_nc3(ARG0)
                {
                  if (mode == -1) {fprintf(stderr,"netcdf package not installed\n"); return 1;}
                  return 0;
                }
                
                #endif
                
                
                


Top 10 Lines:

     Line      Count

      109        136
       36         34
       93         17
      122          9

Execution Summary:

       18   Executable lines in this file
       18   Lines executed
   100.00   Percent of the file executed

      196   Total number of line executions
    10.89   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/Level.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <math.h>
                #include "grb2.h"
                #include "wgrib2.h"
                #include "fnlist.h"
                
                /* Levels.c
                 *   2006: public domain wesley ebisuzaki
                 *   1/2007: cleanup M. Schwarb
                 *   1/2007: Caser Tejeda Hernandez found error in meter underground
                 *   2/2007: level 11
                 *   2/2007: spelling error fixed
                 *   9/2008: type 241 added Nick Lott 
                 */
                
                
                /*
                 * HEADER:200:lev:inv:0:level (code table 4.5)
                 */
                
                /* code table 4.5 */
                
                const char *level_table[192] = {
                /* 0 */ "reserved",
                /* 1 */ "surface",
                /* 2 */ "cloud base",
                /* 3 */ "cloud top",
                /* 4 */ "0C isotherm",
                /* 5 */ "level of adiabatic condensation from sfc",
                /* 6 */ "max wind",
                /* 7 */ "tropopause",
                /* 8 */ "top of atmosphere",
                /* 9 */ "sea bottom",
                /* 10 */ "entire atmosphere",
                /* 11 */ "cumulonimbus base",
                /* 12 */ "cumulonimbus top",
                /* 13 */ "reserved",
                /* 14 */ "reserved",
                /* 15 */ "reserved",
                /* 16 */ "reserved",
                /* 17 */ "reserved",
                /* 18 */ "reserved",
                /* 19 */ "reserved",
                /* 20 */ "%g K level",
                /* 21 */ "reserved",
                /* 22 */ "reserved",
                /* 23 */ "reserved",
                /* 24 */ "reserved",
                /* 25 */ "reserved",
                /* 26 */ "reserved",
                /* 27 */ "reserved",
                /* 28 */ "reserved",
                /* 29 */ "reserved",
                /* 30 */ "reserved",
                /* 31 */ "reserved",
                /* 32 */ "reserved",
                /* 33 */ "reserved",
                /* 34 */ "reserved",
                /* 35 */ "reserved",
                /* 36 */ "reserved",
                /* 37 */ "reserved",
                /* 38 */ "reserved",
                /* 39 */ "reserved",
                /* 40 */ "reserved",
                /* 41 */ "reserved",
                /* 42 */ "reserved",
                /* 43 */ "reserved",
                /* 44 */ "reserved",
                /* 45 */ "reserved",
                /* 46 */ "reserved",
                /* 47 */ "reserved",
                /* 48 */ "reserved",
                /* 49 */ "reserved",
                /* 50 */ "reserved",
                /* 51 */ "reserved",
                /* 52 */ "reserved",
                /* 53 */ "reserved",
                /* 54 */ "reserved",
                /* 55 */ "reserved",
                /* 56 */ "reserved",
                /* 57 */ "reserved",
                /* 58 */ "reserved",
                /* 59 */ "reserved",
                /* 60 */ "reserved",
                /* 61 */ "reserved",
                /* 62 */ "reserved",
                /* 63 */ "reserved",
                /* 64 */ "reserved",
                /* 65 */ "reserved",
                /* 66 */ "reserved",
                /* 67 */ "reserved",
                /* 68 */ "reserved",
                /* 69 */ "reserved",
                /* 70 */ "reserved",
                /* 71 */ "reserved",
                /* 72 */ "reserved",
                /* 73 */ "reserved",
                /* 74 */ "reserved",
                /* 75 */ "reserved",
                /* 76 */ "reserved",
                /* 77 */ "reserved",
                /* 78 */ "reserved",
                /* 79 */ "reserved",
                /* 80 */ "reserved",
                /* 81 */ "reserved",
                /* 82 */ "reserved",
                /* 83 */ "reserved",
                /* 84 */ "reserved",
                /* 85 */ "reserved",
                /* 86 */ "reserved",
                /* 87 */ "reserved",
                /* 88 */ "reserved",
                /* 89 */ "reserved",
                /* 90 */ "reserved",
                /* 91 */ "reserved",
                /* 92 */ "reserved",
                /* 93 */ "reserved",
                /* 94 */ "reserved",
                /* 95 */ "reserved",
                /* 96 */ "reserved",
                /* 97 */ "reserved",
                /* 98 */ "reserved",
                /* 99 */ "reserved",
                /* 100 */ "%g mb",
                /* 101 */ "mean sea level",
                /* 102 */ "%g m above mean sea level",
                /* 103 */ "%g m above ground",
                /* 104 */ "%g sigma level",
                /* 105 */ "%g hybrid level",
                /* 106 */ "%g m underground",
                /* 107 */ "%g K isentropic level",
                /* 108 */ "%g mb above ground",
                /* 109 */ "PV=%g (Km^2/kg/s) surface",
                /* 110 */ "reserved",
                /* 111 */ "%g Eta level",
                /* 112 */ "reserved",
                /* 113 */ "reserved",
                /* 114 */ "reserved",
                /* 115 */ "reserved",
                /* 116 */ "reserved",
                /* 117 */ "mixed layer depth",
                /* 118 */ "reserved",
                /* 119 */ "reserved",
                /* 120 */ "reserved",
                /* 121 */ "reserved",
                /* 122 */ "reserved",
                /* 123 */ "reserved",
                /* 124 */ "reserved",
                /* 125 */ "reserved",
                /* 126 */ "reserved",
                /* 127 */ "reserved",
                /* 128 */ "reserved",
                /* 129 */ "reserved",
                /* 130 */ "reserved",
                /* 131 */ "reserved",
                /* 132 */ "reserved",
                /* 133 */ "reserved",
                /* 134 */ "reserved",
                /* 135 */ "reserved",
                /* 136 */ "reserved",
                /* 137 */ "reserved",
                /* 138 */ "reserved",
                /* 139 */ "reserved",
                /* 140 */ "reserved",
                /* 141 */ "reserved",
                /* 142 */ "reserved",
                /* 143 */ "reserved",
                /* 144 */ "reserved",
                /* 145 */ "reserved",
                /* 146 */ "reserved",
                /* 147 */ "reserved",
                /* 148 */ "reserved",
                /* 149 */ "reserved",
                /* 150 */ "reserved",
                /* 151 */ "reserved",
                /* 152 */ "reserved",
                /* 153 */ "reserved",
                /* 154 */ "reserved",
                /* 155 */ "reserved",
                /* 156 */ "reserved",
                /* 157 */ "reserved",
                /* 158 */ "reserved",
                /* 159 */ "reserved",
                /* 160 */ "%g m below sea level",
                /* 161 */ "reserved",
                /* 162 */ "reserved",
                /* 163 */ "reserved",
                /* 164 */ "reserved",
                /* 165 */ "reserved",
                /* 166 */ "reserved",
                /* 167 */ "reserved",
                /* 168 */ "reserved",
                /* 169 */ "reserved",
                /* 170 */ "reserved",
                /* 171 */ "reserved",
                /* 172 */ "reserved",
                /* 173 */ "reserved",
                /* 174 */ "reserved",
                /* 175 */ "reserved",
                /* 176 */ "reserved",
                /* 177 */ "reserved",
                /* 178 */ "reserved",
                /* 179 */ "reserved",
                /* 180 */ "reserved",
                /* 181 */ "reserved",
                /* 182 */ "reserved",
                /* 183 */ "reserved",
                /* 184 */ "reserved",
                /* 185 */ "reserved",
                /* 186 */ "reserved",
                /* 187 */ "reserved",
                /* 188 */ "reserved",
                /* 189 */ "reserved",
                /* 190 */ "reserved",
                /* 191 */ "reserved"
                };
                
                
                int level1(int mode, int type, int undef_val, float value, int center, int subcenter, char *inv_out);
                int level2(int mode, int type1, int undef_val1, float value1, int type2, int undef_val2, 
                   float value2, int center, int subcenter, char *inv_out);
                
          17 -> int f_lev(ARG0) {
                
                    int level_type1, level_type2;
                    float val1, val2;
                    int undef_val1, undef_val2;
                    int center, subcenter;
                
                    if (mode < 0) return 0;
                
                    center = GB2_Center(sec);
                    subcenter = GB2_Subcenter(sec);
                
                    fixed_surfaces(sec, &level_type1, &val1, &undef_val1, &level_type2, &val2, &undef_val2);
                
                    if (mode > 1) {
                	if (undef_val1 == 0) sprintf(inv_out,"lvl1=(%d,%lg) ",level_type1,val1);
                	else sprintf(inv_out,"lvl1=(%d,missing) ",level_type1);
                	inv_out += strlen(inv_out);
                
                	if (undef_val2 == 0) sprintf(inv_out,"lvl2=(%d,%lg):",level_type2,val2);
                	else sprintf(inv_out,"lvl2=(%d,missing):",level_type2);
                	inv_out += strlen(inv_out);
                    }
                
                    level2(mode, level_type1, undef_val1, val1, level_type2, undef_val2, val2, center, subcenter, inv_out);
                    return 0;
                }
                
                /*
                 * level2 is for layers
                 */
                
                int level2(int mode, int type1, int undef_val1, float value1, int type2, int undef_val2, float value2, int center, int subcenter,
          17 -> 	char *inv_out) {
                
                    if (type1 == 100 && type2 == 100) {
                	sprintf(inv_out,"%g-%g mb",value1/100,value2/100);
                    }
                    else if (type1 == 102 && type2 == 102) {
                	sprintf(inv_out,"%g-%g m above mean sea level",value1,value2);
                    }
                    else if (type1 == 103 && type2 == 103) {
                	sprintf(inv_out,"%g-%g m above ground",value1,value2);
                    }
                    else if (type1 == 104 && type2 == 104) {
                	sprintf(inv_out,"%g-%g sigma layer",value1,value2);
                    }
                    else if (type1 == 105 && type2 == 105) {
                	sprintf(inv_out,"%g-%g hybrid layer",value1,value2);
                    }
                    else if (type1 == 106 && type2 == 106) {
                	/* sprintf(inv_out,"%g-%g m below ground",value1/100,value2/100); removed 1/2007 */
                	sprintf(inv_out,"%g-%g m below ground",value1,value2);
                    }
                    else if (type1 == 107 && type2 == 107) {
                	sprintf(inv_out,"%g-%g K isentropic layer",value1,value2);
                    }
                    else if (type1 == 108 && type2 == 108) {
                	sprintf(inv_out,"%g-%g mb above ground",value1/100,value2/100);
                    }
                    else if (type1 == 160 && type2 == 160) {
                	sprintf(inv_out,"%g-%g m below sea level",value1,value2);
                    }
                    else if (type1 == 1 && type2 == 8) {
                	sprintf(inv_out,"atmos col");		// compatible with wgrib
                    }
                    else if (type1 == 9 && type2 == 1) {
                	sprintf(inv_out,"ocean column");
                    }
                    else if (center == 7 && type1 == 235 && type2 == 235) {
                	    sprintf(inv_out,"%g-%gC ocean isotherm layer", value1/10,value2/10);
                    }
                    else if (center == 7 && type1 == 236 && type2 == 236) {	// obsolete
                	    sprintf(inv_out,"%g-%g m ocean layer", value1*10,value2*10);
                    }
                    else if (type1 == 255 && type2 == 255) {
                	    sprintf(inv_out,"no_level");
                    }
                    else {
                        level1(mode, type1, undef_val1, value1, center, subcenter,inv_out);
                	inv_out += strlen(inv_out);
                        if (type2 != 255) {
                	    sprintf(inv_out," - ");
                	    inv_out += strlen(inv_out);
                	    level1(mode, type2, undef_val2, value2, center, subcenter,inv_out);
                        }
                    }
                    return 0;
                }
                
                /*
                 * level1 is for a single level (not a layer)
                 */
                
          17 -> int level1(int mode, int type, int undef_val, float val, int center, int subcenter,char *inv_out) {
                
                    char *string;
                
                    /* local table for NCEP */
                    if (center == 7 && type >= 192 && type <= 254) {
                	if (type == 235) {
                	    sprintf(inv_out,"%gC ocean isotherm", val/10);
                	    return 0;
                	}
                	if (type == 241) {
                	    sprintf(inv_out,"%g in sequence", val);
                	    return 0;
                	}
                
                	string = NULL;
                        switch (type) {
                #include "CodeTable_4.5_ncep.dat"
                	}
                	if (string != NULL) {
                	    sprintf(inv_out,string, val);
                	    return 0;
                	}
                    }
                
                    if (type == 100 || type == 108) val = val * 0.01;  // Pa -> mb
                
                    // no numeric information
                    if (type == 255) return 8;
                
                    if (type <= 192) {
                	sprintf(inv_out,level_table[type], val);
                    }
                    else if (center == 7){
                	if (undef_val == 0) sprintf(inv_out,"NCEP level type %d %g", type, val);
                	else sprintf(inv_out,"NCEP level type %d", type);
                    }
                    else {
                        if (undef_val == 0) sprintf(inv_out,"local level type %d %g", type, val);
                        else sprintf(inv_out,"local level type %d", type);
                    }
                
                    return 0;
                }


Top 10 Lines:

     Line      Count

      225         17
      258         17
      319         17

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

       51   Total number of line executions
    17.00   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/my_grib2nc.c:
                /* wgrib2 main module:  w. ebisuzaki
                 *
                 * CHECK code is now duplicated
                 *  if (decode) -- check before decoding
                 *  if (!decode) -- check after processing one record so you can use wgrib2 to look at the field
                 *
                 * 1/2007 mods M. Schwarb: unsigned int ndata
                 * 2/2008 WNE add -if support
                 * 2/2008 WNE fixed bug in processing of submessages
                 */
                
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <stddef.h>
                #include <ctype.h>
                
                #include "grb2.h"
                #include "wgrib2.h"
                #include "fnlist.h"
                #include "grib2.h"
                #include "my_netcdf.h"
                #include "my_grib2nc.h"
                #include "my_defs.h"
                #include "my_rd_grib2_msg.h"
                
                #include <assert.h>
                #include <mpi.h>
                
                /* #define DEBUG */
                //#define CHECK
                
                /* global variables .. can be modified by funtions */
                
                
                int flush_mode = 0;	/* flush of output 1 = yes */
                
                int use_g2clib = USE_G2CLIB;	/* use g2clib code for decoding */
                int fix_ncep_2_flag = 0;	
                int fix_ncep_3_flag = 0;	
                int fix_ncep_4_flag = 0;
                
                
                int last_message = 0;	/* last message to process if set */
                
                FILE *inv_file;
                
                
                enum input_type input = all_mode;
                enum output_order_type output_order = wesn, output_order_wanted = wesn;
                
                char inv_out[INV_BUFFER]; 		/* inv functions write to this buffer */
                
                int decode = 0;		/* decode grib file flag */
                
                
                
                /* current grib location */
                long int pos;
                unsigned long int len;
                int submsg; 
                int msg_no;
                int inv_no;
                
                /* lat lon array .. used by Latlon.c to store location information */
                double *lat = NULL, *lon = NULL;
                int latlon = 0;
                int new_GDS = 0;
                int old_GDS_size = 0;
                int GDS_max_size = 100;
                unsigned char *old_gds;
                int nx, ny, res, scan;
                unsigned int npnts;
                int use_scale = 0, dec_scale, bin_scale,  max_bits = 16, wanted_bits = 12;
                enum output_grib_type grib_type = simple;
                
                
                /* may disappear in future versions  grib2 decoder variables */
                gribfield *grib_data;
                int free_gribfield = 0;			// flag for allocated gribfield
                int free_sec4 = 0;			// flag for allocated sec4
                
                
                /* 
                  * local varibles extracted from grib2nc
                  */
                 static int num_submsgs;
                 static unsigned char *g2msg;
                 static float *data;
                 static unsigned int ndata;
                
                
                int init_nc_info(int nc_version, nc_info_t *local, char *ncpath);
                int parse_nc_info(MPI_File *in, unsigned char **sec);
                
                  
                int init_nc_info(int nc_version, nc_info_t *save, char *ncpath)
           1 -> {
                
                    assert(save);
                
                    if (!save) 
                	  fatal_error("netcdf: %s","error doing malloc of save");
                    
                	save->ncfile = (char*) malloc(STRLEN);
                	//memset(save->ncfile, 0, STRLEN);
                	if (!(save->ncfile)) 
                	  fatal_error("netcdf: %s","error doing malloc of ncfile");
                    strcpy(save->ncfile, ncpath);
                	
                	decode = latlon = 1;
                    save->initialized = 0; /* not yet */
                    save->ncid = -1; /* do not created or open */
                    save->nid = 0;
                    save->time_step = 0;
                    save->time_step_type = 0;
                    save->date0 = 0;
                    save->date0_type = 0;
                
                    save->nc_pack = 0;
                    save->nc_pack_scale = 1;
                    save->nc_pack_offset = 0;
                    save->nc_valid_min = 0;
                    save->nc_valid_max = 0;
                    
                    save->grid_template=-1;
                    save->dim_latlon=0;
                    save->lev_ind=-1;
                    save->time_ind=-1;
                
                    save->nc4 = nc_version;
                    save->grads_compatible = 0;
                    save->nc_nlev = 0;
                    save->endianness=0;
                  
                    return 0;
                }
                
                
                int parse_nc_info(MPI_File *in, unsigned char **sec)
          18 -> {
                    unsigned char *msg;
                
                    /*
                     * safe definition
                     */
                    int i,j;
                    unsigned int k;
                    float missing_c_val_1, missing_c_val_2;
                    double ref;
                    g2float *g2_data;
                    g2int *bitmap, has_bitmap;
                    int err;
                
                    nc_info_t *nc_info;
                        
                    /*
                     * read the grib message into the memory
                     * and pase the meta data section into sec variable
                     */
                    
                    /* the first time of reading grib2 message */
                	if (submsg == 0) {
                	    if ((g2msg = mpi_rd_grib2_msg(in, &pos, &len, &num_submsgs)) == NULL) return BREAK;
                            submsg = 1;
                	}
                   /* 
                    * if a file include more than one grib2 messages, read it after the 
                    *  previous message read 
                	*/
                	else if (submsg > num_submsgs) {
                		pos += len;
                        msg_no++;
                	    if ((g2msg = mpi_rd_grib2_msg(in, &pos, &len, &num_submsgs)) == NULL) return BREAK;
                            submsg = 1;
                	}
                    /* 
                     * submsg mean a grib2 message has a repetive sections(2-7, 3-7, 4-7), if this
                     * happens, need parse message many times
                     */
                    if (submsg == 1) {
                		if (mpi_parse_1st_msg(sec) != 0) {
                			fprintf(stderr,"illegal format: parsing 1st submessage\n");
                		}
                    }
                    else {
                		if (mpi_parse_next_msg(sec) != 0) {
                            fprintf(stderr,"illegal format: parsing submessages\n");
                        }
                	}
                	
                	/* 
                	 * see if new GDS 
                	 */
                	if ((i = GB2_Sec3_size(sec)) != old_GDS_size) {
                	    new_GDS = 1;
                	}
                	else {
                	    new_GDS = 0;
                	    for (j = 0; j < i; j++) {
                			if (old_gds[j] != sec[3][j]) 
                			  new_GDS = 1;
                	    }
                	}
                	if (new_GDS) {
                	    if (i > GDS_max_size) {
                			free(old_gds);
                			GDS_max_size = i;
                    		if ((old_gds = (unsigned char *) malloc(GDS_max_size) ) == NULL) {
                				fatal_error("memory allocation problem old_gds in wgrib2.main","");
                			}
                	    }
                	    for (j = 0; j < i; j++) {
                			old_gds[j] = sec[3][j];
                        }
                	    old_GDS_size = i;
                	    /* update grid information */
                        get_nxny(sec, &nx, &ny, &npnts, &res, &scan);	 /* get nx, ny, and scan mode of grid */
                	    output_order = (nx == -1 || ny == -1) ? raw : output_order_wanted;
                        if (latlon) get_latlon(sec);			 /* get lat lon of grid points */
                	}
                
                	// any fixes to raw grib message before decode need to be placed here
                	if (fix_ncep_2_flag) fix_ncep_2(sec);
                	if (fix_ncep_3_flag) fix_ncep_3(sec);
                	if (fix_ncep_4_flag) fix_ncep_4(sec);
                
                
                	if (decode) {
                
                #ifdef CHECK
                		if (code_table_6_0(sec) == 0) {                         // has bitmap
                            k = GB2_Sec3_npts(sec) -  GB2_Sec5_nval(sec);
                            if (k != missing_points(sec[6]+6, GB2_Sec3_npts(sec))) 
                				fatal_error_ii("inconsistent number of bitmap points sec3-sec5: %d sec6: %d",
                								k, missing_points(sec[6]+6, GB2_Sec3_npts(sec)));
                        }
                        else if (code_table_6_0(sec) == 255) {                  // no bitmap
                            if (GB2_Sec3_npts(sec) != GB2_Sec5_nval(sec))
                                fatal_error_ii("inconsistent number of data points sec3: %d sec5: %d",
                                    GB2_Sec3_npts(sec), GB2_Sec5_nval(sec));
                        }
                #endif
                
                        /* allocate data */
                        if (GB2_Sec3_npts(sec) != ndata) {
                            if (ndata) free(data);
                            ndata = GB2_Sec3_npts(sec);
                            if (ndata) {
                                data = (float *) malloc(ndata * sizeof(float));
                                if (data == NULL) fatal_error("main: memory allocation failed data","");
                            }
                            else { data = NULL; }
                        }
                
                	    j = code_table_5_0(sec);		// type of compression
                
                        /* 
                         * set the data
                         */
                	  if ((j == 4 || j == 200) || ( (use_g2clib == 0) && (j == 0 || 
                			j == 4 || j == 2 || j == 3 ||
                			j == 40 || j == 41 || j == 40000))) {
                				err = unpk_grib(sec, data);
                                if (err != 0) {
                                    fprintf(stderr,"Fatal decode packing type %d\n",j);
                                    exit(8);
                				}
                	    }
                        else {
                
                	        err = g2_getfld(g2msg,submsg,1,1,&grib_data);
                            if (err != 0) {
                                fprintf(stderr,"Fatal decode err=%d msg %d.%d\n",err, msg_no, submsg);
                                exit(8);
                            }
                			free_gribfield = 1;
                
                	        has_bitmap = grib_data->ibmap;
                	        g2_data = &(grib_data->fld[0]);
                	        if (has_bitmap == 0 || has_bitmap == 254) {
                				bitmap = grib_data->bmap;
                		    	for (k = 0; k < ndata; k++) {
                		    	     data[k] = (bitmap[k] == 0) ? UNDEFINED : g2_data[k];
                		    	}
                	        }
                	        else {
                				for (k = 0; k < ndata; k++) {
                		    	    data[k] = *g2_data++;
                		    	}
                	        }
                
                	        /* complex packing uses special values for undefined */
                			i = sub_missing_values(sec, &missing_c_val_1, &missing_c_val_2);
                			if (i == 1) {
                			    for (k = 0; k < ndata; k++) {
                			        if (data[k] == missing_c_val_1) data[k] = UNDEFINED;
                			    }
                			}
                  	        else if (i == 2) {
                				for (k = 0; k < ndata; k++) {
                		    	    if (data[k] == missing_c_val_1) data[k] = UNDEFINED;
                		    	    if (data[k] == missing_c_val_2) data[k] = UNDEFINED;
                		    	}
                	        }
                
                        }
                
                	    /* convert to standard output order we:sn */
                
                	    if (output_order_wanted == wesn) 
                			to_we_sn_scan(data);
                	    else if (output_order_wanted == wens) 
                			to_we_ns_scan(data);
                	}
                    else {
                		if (ndata) 
                			free(data);
                    	ndata = 0;
                    	data = NULL;
                    }
                
                    //data_p[0] = data;
                    //ndata_p[0] = ndata;
                	/* get scaling parameters */
                
                	use_scale = scaling(sec, &ref, &dec_scale, &bin_scale, &i) == 0;
                
                
                	if (num_submsgs > 1) {
                	    fprintf(inv_file, "%d.%d%s%ld", msg_no, submsg, ":", pos);
                	}
                    else {
                	    fprintf(inv_file, "%d%s%ld", msg_no, ":", pos);
                	}
                        
                    return 0;
                }
                
                
                int grib2nc(char *g2path, char *ncpath, int nc_version)
           1 -> {
                    //FILE *in;
                    MPI_File in;
                    unsigned char *msg, *sec[9];
                
                    int i, j;
                    double *ddata, ref;
                    g2int *bitmap, has_bitmap;
                    g2float *g2_data;
                
                    int err;
                
                    nc_info_t *nc_info;
                
                    MPI_Init(NULL, NULL);
                    
                    nc_info = (nc_info_t *)malloc(sizeof(nc_info_t));
                    assert(nc_info);
                
                	inv_file = stdout;
                    
                    /*
                     * initialize
                     */
                    init_nc_info(nc_version, nc_info, ncpath);
                
                    /* open input file */
                    /*if ((in = fopen(g2path,"rb")) == NULL) {
                        fatal_error("could not open file: %s", g2path);
                    }*/
                    if ((err = MPI_File_open(MPI_COMM_WORLD, g2path, MPI_MODE_RDONLY, MPI_INFO_NULL, &in)) != MPI_SUCCESS) {
                        fatal_error("could not open file: %s", g2path);
                    }
                
                    ndata = 0;
                    data = NULL;
                    msg_no = 1;
                    inv_no = 0;
                    len = pos = 0;
                    submsg = 0;
                    g2msg = NULL;
                
                    if ((old_gds = (unsigned char *) malloc(GDS_max_size * sizeof(char)) ) == NULL) {
                		fatal_error("memory allocation problem old_gds in wgrib2.main","");
                    }
                
                    /* 
                     * submsg = 0 .. beginning of unread record
                     * submsg = i .. start at ith submsg
                     * num_submsgs = number of submessages in grib message
                     */
                
                    /* inventory loop */ 
                
                    for (;last_message == 0;) {
                
                		/* parse the message: metadata in sec and raw data in data */
                       err = parse_nc_info(&in, sec);
                	
                	   if(err == BREAK)
                		 break;
                
                	   if(err == 8)
                		 exit(err);    
                        /*
                         * transform
                         */
                	    //f_s(0, sec, NULL, 0, inv_out, NULL);
                    	convert_nc_info(sec, data, ndata, inv_out, &nc_info);
                
                		submsg++;
                
                		if (free_sec4) { 
                			free(sec[4]); free_sec4 = 0;
                		}
                		if (free_gribfield) { 
                			g2_free(grib_data); 
                			free_gribfield = 0;
                		}
                
                		fprintf(inv_file, "\n");
                		if (flush_mode) fflush(inv_file);
                		//if (dump_msg > 0) break;
                    }
                
                    /* finalize */
                    finalize_nc_info(nc_info);
                
                    MPI_File_close(&in);
                    MPI_Finalize();
                    
                    return 0;
                }
                
       ##### -> int main(int argc, char **argv) {
                	int	ch, err;
                    
                    FILE *out = stdout;
                    int nc_version;
                
                
                    /* no arguments .. help screen */
                    if (argc == 1) {
                	fprintf(out, "command format error!");
                	exit(8);
                    }
                
                	nc_version = 1;
                
                	if(argc == 2){
                		char ncpath[STRLEN];
                		int slen = strlen(argv[1]);
                		memset(ncpath, 0, STRLEN * sizeof(char));
                		strncpy(ncpath, argv[1], slen-4);
                		strcat(ncpath, "nc");
                		err = grib2nc(argv[1], ncpath, nc_version);
                	}
                	else
                	  err = grib2nc(argv[1], argv[2], nc_version);    
                	
                	/*ch = getopt(argc, argv, "34");
                    if(ch == '3')
                        nc_version = 0;
                    else
                	 nc_version = 1;*/
                
                	
                    //err = grib2nc(argv[1], argv[2], nc_version);
                    
                    return 0;
                }
                


Top 10 Lines:

     Line      Count

      141         18
       98          1
      342          1

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

       20   Total number of line executions
     5.00   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/int8.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include <limits.h>
                #include <math.h>
                #include "grb2.h"
                #include "wgrib2.h"
                
                /*
                 * various conversion routines
                 *
                 * 2006: Public Domain Wesley Ebisuzaki
                 * 1/2007: uint8 fix Wesley Ebisuzaki
                 */
                
                /* routines to return various sized integers from GRIB file */
                
          76 -> unsigned int uint2(unsigned char *p) {
                	return (p[0] << 8) + p[1];
                }
                
         243 -> unsigned int uint4(unsigned char *p) {
                    return ((p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]);
                }
                
                /*
                 * uint4_missing
                 * if missing return (uint) -1
                 */
           4 -> int uint4_missing(unsigned char *p) {
                    int t;
                
                    /* old
                    t = p[0] & 128 ? -1 : 0;
                    t = t << 8 | p[0];
                    t = t << 8 | p[1];
                    t = t << 8 | p[2];
                    t = t << 8 | p[3];
                    */
                
                    t = p[0];
                    t = t << 8 | p[1];
                    t = t << 8 | p[2];
                    t = t << 8 | p[3];
                
                    if (t == 0xffffffff) return -1;
                    return t;
                }
                
          34 -> unsigned long int uint8(unsigned char *p) {
                
                #if (ULONG_MAX == 4294967295UL) 
                	if (p[0] || p[1] || p[2] || p[3]) {
                		fprintf(stderr,"unsigned value (8 byte integer) too large for machine\n");
                		fprintf(stderr,"fatal error .. run on 64-bit machine\n");
                		exit(8);
                	}
                	return  ((unsigned long int)p[4] << 24) + ((unsigned long int)p[5] << 16) + 
                                ((unsigned long int)p[6] << 8) + (unsigned long int)p[7];
                #else
                	return  ((unsigned long int)p[0] << 56) + ((unsigned long int)p[1] << 48) + 
                                ((unsigned long int)p[2] << 40) + ((unsigned long int)p[3] << 32) + 
                                ((unsigned long int)p[4] << 24) + ((unsigned long int)p[5] << 16) +
                		((unsigned long int)p[6] << 8) + (unsigned long int)p[7];
                #endif
                }
                
                /*  uint_n: converts n bytes to unsigned int */
                
       ##### -> unsigned  int uint_n(unsigned char *p, int n) {
                    unsigned int i;
                    i = 0;
                    while (n-- > 0) {
                	i = (i << 8) + *p++;
                    }
                    return i;
                }
                
       ##### -> int int1(unsigned char *p) {
                	int i;
                	if (*p & 0x80) {
                		i = -(*p & 0x7f);
                	}
                	else {
                		i = (int) *p;
                	}
                	return i;
                }
                
          34 -> int int2(unsigned char *p) {
                	int i;
                	if (p[0] & 0x80) {
                		i = -(((p[0] & 0x7f) << 8) + p[1]);
                	}
                	else {
                		i = (p[0] << 8) + p[1];
                	}
                	return i;
                }
                
          44 -> int int4(unsigned char *p) {
                	int i;
                	if (p[0] & 0x80) {
                		i = -(((p[0] & 0x7f) << 24) + (p[1] << 16) + (p[2] << 8) + p[3]);
                	}
                	else {
                		i = (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3];
                	}
                	return i;
                }
                
                /*  int_n: converts n bytes to int */
                
       ##### -> int int_n(unsigned char *p, int n) {
                    int i, sign;
                
                    if (n == 0) return 0;
                    sign = *p;
                    i = *p++ & 127;
                    while (n-- > 1) {
                	i = i * 256 + (int) *p++;
                    }
                    if (sign & 0x80) i = -i;
                    return i;
                }
                
                //
                // 2's complement integer4 -- normal storage
                //
       ##### -> int int4_comp(unsigned char *p) {
                    int i;
                    unsigned int j;
                
                    if (p[0] & 0x80) {
                        j = (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3];
                	j = (j ^ 0xffffffff) + 1;
                	i = 0 - j;
                    }
                    else {
                	i = (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3];
                    }
                    return i;
                }
                
                //
                // floating point values are often represented as int * power of 10
                //
          34 -> float scaled2flt(int scale_factor, int scale_value) {
                   if (scale_factor == 0) return (float) scale_value;
                   if (scale_factor < 0) return scale_value * Int_Power(10.0, -scale_factor);
                   return scale_value / Int_Power(10.0, scale_factor);
                }
       ##### -> double scaled2dbl(int scale_factor, int scale_value) {
                   if (scale_factor == 0) return (float) scale_value;
                   if (scale_factor < 0) return scale_value * Int_Power(10.0, -scale_factor);
                   return scale_value / Int_Power(10.0, scale_factor);
                }
                
                //
                // inverse of scaled2flt
                //
       ##### -> int flt2scaled(int scale_factor, float value) {
                	if (scale_factor == 0) return (int) value;
                	if (scale_factor > 0) return (int) (value * Int_Power(10.0,scale_factor));
                	return (int) (value / Int_Power(10.0,-scale_factor));
                }
                //
                // best scaled values
                //
       ##### -> int best_scaled_value(double val, int *scale_factor, int *scale_value) {
                
                    int n;
                
                    if (isinf(val)) {
                	fatal_error("best_scaled_value: encountered an infinite value","");
                    }
                
                    if (val == 0.0) {
                	*scale_factor = *scale_value = 0;
                	return 0;
                    }
                
                    n = 0;
                
                    // scale for large numbers
                    if (fabs(val) > INT_MAX) {
                	n = 0;
                        while (fabs(val) > INT_MAX) {
                	    val *= 0.1;
                	    n--;
                	}
                	*scale_factor = n;
                        *scale_value = floor(val + 0.5);
                	return 0;
                    }
                
                    while (fabs(val*10.0) < INT_MAX) {
                	if (fabs( floor(val+0.5) - val)  < 0.00001*fabs(val) ) {
                	    *scale_factor = n;
                            *scale_value = floor(val + 0.5);
                	    return 0;
                	}
                	n++;
                	val *= 10.0;
                    }
                    *scale_factor = n;
                    *scale_value = floor(val + 0.5);
                    return 0;
                }
                
                
       ##### -> void uint8_char(unsigned long int i, unsigned char *p) {
                    int j;
                    for (j = 0; j < 8; j++) {
                	p[7-j] = i & 255;
                        i = i >> 8;
                    }
                }
                
       ##### -> void uint_char(unsigned int i, unsigned char *p) {
                    p[0] = (i >> 24) & 255;
                    p[1] = (i >> 16) & 255;
                    p[2] = (i >>  8) & 255;
                    p[3] = (i      ) & 255;
                }
                
       ##### -> void int_char(int i, unsigned char *p) {
                    int sign = 0;
                    if (i < 0) {
                	sign = 128;
                	i = -i;
                    }
                    p[0] = ((i >> 24) & 127) | sign;
                    p[1] = (i >> 16) & 255;
                    p[2] = (i >>  8) & 255;
                    p[3] = (i      ) & 255;
                    return;
                }
                
       ##### -> void uint2_char(unsigned int i, unsigned char *p) {
                    p[0] = (i >>  8) & 255;
                    p[1] = (i      ) & 255;
                    return;
                }
                
       ##### -> void int2_char(int i, unsigned char *p) {
                    int sign = 0;
                    if (i < 0) {
                	sign = 128;
                	i = -i;
                    }
                    p[0] = ((i >> 8) & 127) | sign;
                    p[1] = i & 255;
                    return;
                }


Top 10 Lines:

     Line      Count

       21        243
       17         76
      100         44
       49         34
       89         34
      147         34
       29          4

Execution Summary:

       19   Executable lines in this file
       19   Lines executed
   100.00   Percent of the file executed

      469   Total number of line executions
    24.68   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/Scan.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include "wgrib2.h"
                #include "fnlist.h"
                
                extern int nx, ny, scan;
                extern unsigned int npnts;
                extern int *raw_variable_dim;
                extern enum output_order_type output_order_wanted, output_order;
                extern int save_translation;
                
                static unsigned int n_translation = 0;
                static int *translation = NULL;
                
                /*
                 * undo the scan mode madness
                 *
                 * i, j is grid coordinate (0,0) is south west corner
                 * nx, ny are grid dimensions
                 * scan_mode is grib2 scan mode parameter
                 *
                 * returns integer 0 .. nx*ny-1 which is the location of the i, jth data
                 *         -1 for error
                 * 3/2008 public domain Wesley Ebisuzaki
                 * 3/2008 bug fix Manfred Schwarb
                 * 7/2009 bug fix Reinoud Bokhorst 
                 */
                
       ##### -> int ij2p(int i, int j, int scan_mode) {
                
                    if (i < 0 || j < 0) return -1;
                
                    /* regular grid */
                    if (nx > 0 && ny > 0) {
                        if (i >= nx || j >= ny) return -1;
                
                        j = (scan_mode & 64) ? j : ny-1 - j;
                        i = ((scan_mode & 16) && (j % 2 == 1)) ?  nx - 1 - i : i;
                        i = (scan_mode & 128) ? nx-1 - i : i;
                
                        return (scan_mode & 32) ?  j + i*ny : i + nx*j;
                    }
                    /* thinned longitudes */
                    if (nx == -1 && ny > 0) {
                	return -1;
                    }
                   return -1;
                }
                
                /*
                 * to_we_sn_scan
                 *    this routine converts scanning order to standard we:sn
                 *    default for binary and text output
                 */
                
          17 -> int to_we_sn_scan(float *data) {
                
                    float *data2;
                    int ix, iy, i, dx;
                    float *p0, *p1, *p2;
                    int lscan;
                
                
                    lscan = scan >> 4;
                    if (lscan == 4) {
                	if (save_translation && translation) {
                            free(translation);
                            translation = NULL;
                            n_translation = 0;
                        }
                	return 0; 			/* already we:sn order */
                    }
                
                    if (save_translation && npnts != n_translation) {
                	free(translation);
                	if ((translation = (int *) malloc(npnts*sizeof(int))) == NULL) {
                	    fatal_error("not enough memory for translation array","");
                	}
                	n_translation = npnts;
                    }
                
                
                    if ((data2 = (float *) malloc(npnts * sizeof(float))) == NULL) 
                	fatal_error("allocation of memory error","");
                
                    if (lscan == 0 && nx > 0 && ny > 0) {	/* regular grid: convert from we:ns to we:sn */
                	p0 = data;
                	p1 = data2 + npnts;
                        for (iy = 0; iy < ny; iy++) {
                	    p1 -= nx;
                	    memcpy(p1, p0, nx * sizeof(float));
                	    if (save_translation) for (i = 0; i < nx; i++) translation[p1+i-data2] = p0 - data + i;
                	    p0 += nx;
                	}
                        memcpy(data, data2, npnts * sizeof(float));
                	free(data2);
                	return 0;
                    }
                
                    if (lscan == 0 && nx == -1 && ny > 0) { /* quasi-regular grid: convert from we:ns to we:sn */
                	p0 = data;
                	p1 = data2 + npnts;
                        for (iy = 0; iy < ny; iy++) {
                	    dx = raw_variable_dim[iy];
                	    p1 -= dx;
                	    memcpy(p1,p0,dx * sizeof(float));
                	    if (save_translation) for (i = 0; i < dx; i++) translation[p1+i-data2] = p0 - data + i;
                	    p0 += dx;
                	}
                        memcpy(data, data2, npnts * sizeof(float));
                	free(data2);
                	return 0;
                    }
                
                    if (nx == -1 || ny == -1) fatal_error("not handled by to_we_sn_scan","");
                
                    p0 = data2;
                    for (iy = 0; iy < ny; iy++) {
                	p1 = data + ij2p(0,iy,scan);
                	p2 = data + ij2p(1,iy,scan);
                	dx = p2 - p1;
                	for (ix = 0; ix < nx; ix++) {
                	    if (save_translation) translation[p0 - data2] = p1 - data;
                	    *p0++ = *p1;
                	    p1 += dx;
                	}
                    }
                    memcpy(data, data2, npnts * sizeof(float));
                    free(data2);
                    return 0;
                }
                
                /*
                 * to_we_ns_scan
                 *    this routine converts scanning order to standard we:ns
                 */
                
       ##### -> int to_we_ns_scan(float *data) {
                
                    float *data2;
                    int ix, iy, i, dx;
                    float *p0, *p1, *p2;
                    int lscan;
                
                    lscan = scan >> 4;
                    if (lscan == 0) {
                	if (save_translation && translation) {
                            free(translation);
                            translation = NULL;
                            n_translation = 0;
                        }
                	return 0;                   /* already we:ns order */
                    }
                
                    if (save_translation && npnts != n_translation) {
                	free(translation);
                	if ((translation = (int *) malloc(npnts*sizeof(int))) == NULL) {
                	    fatal_error("not enough memory for translation array","");
                	}
                    }
                
                    if ((data2 = (float *) malloc(npnts * sizeof(float))) == NULL)
                        fatal_error("allocation of memory error","");
                
                    if (lscan == 0 && nx > 0 && ny > 0) {       /* regular grid: convert from we:sn to we:ns */
                        p0 = data;
                        p1 = data2 + npnts;
                        for (iy = 0; iy < ny; iy++) {
                            p1 -= nx;
                            memcpy(p1, p0, nx * sizeof(float));
                	    if (save_translation) for (i = 0; i < nx; i++) translation[p1+i-data2] = p0 - data + i;
                            p0 += nx;
                        }
                        memcpy(data, data2, npnts * sizeof(float));
                        free(data2);
                        return 0;
                    }
                
                    if (nx == -1 || ny == -1) fatal_error("not handled by to_we_ns_scan","");
                
                    if (lscan == 0 && nx == -1 && ny > 0) { /* quasi-regular grid: convert from we:sn to we:ns */
                        p0 = data;
                        p1 = data2 + npnts;
                        for (iy = 0; iy < ny; iy++) {
                            dx = raw_variable_dim[iy];
                            p1 -= dx;
                            memcpy(p1,p0,dx * sizeof(float));
                	    if (save_translation) for (i = 0; i < dx; i++) translation[p1+i-data2] = p0 - data + i;
                            p0 += dx;
                        }
                        memcpy(data, data2, npnts * sizeof(float));
                        free(data2);
                        return 0;
                    }
                
                    /* uncommon scan order .. use general routine */
                
                    p0 = data2;
                    for (iy = ny-1; iy >= 0; iy--) {
                        p1 = data + ij2p(0,iy,scan);
                        p2 = data + ij2p(1,iy,scan);
                        dx = p2 - p1;
                        for (ix = 0; ix < nx; ix++) {
                	    if (save_translation) translation[p0 - data2] = p1 - data;
                            *p0++ = *p1;
                            p1 += dx;
                        }
                    }
                    memcpy(data, data2, npnts * sizeof(float));
                    free(data2);
                    return 0;
                }
                
                /*
                 * HEADER:200:order:setup:1:decoded data in X (raw|we:sn|we:ns) order, we:sn is default
                 */
                
                
       ##### -> int f_order(ARG1) {
                    if (mode == -1) {
                	if (strcmp(arg1,"raw") == 0) output_order_wanted = raw;
                	else if (strcmp(arg1,"we:sn") == 0) output_order_wanted = wesn;
                	else if (strcmp(arg1,"we:ns") == 0) output_order_wanted = wens;
                	else {
                	    fatal_error("order: arg=%s expecting raw|we:sn|we:ns", arg1);
                	}
                    }
                    return 0;
                }
                
                /*
                 * returns a string with the name of the output_order
                 */
                
       ##### -> const char *output_order_name(void) {
                	if (output_order == raw) return "raw";
                	if (output_order == wesn) return "WE:SN";
                	if (output_order == wens) return "WE:NS";
                	return "order?";
                }
                
       ##### -> int undo_output_order(float *data, float *data_old_order, unsigned int npnts) {
                    unsigned int i;
                    if (translation == NULL) {
                        for (i = 0; i < npnts; i++) {
                	    data_old_order[i] = data[i];
                	}
                	return 0;
                    }
                    if (npnts != n_translation) fatal_error("undo_output_order: program error",
                	"");
                    for (i = 0; i < npnts; i++) {
                        data_old_order[translation[i]] = data[i];
                    }
                    return 0;
                }


Top 10 Lines:

     Line      Count

       57         17

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

       17   Total number of line executions
     2.83   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/Code_Values.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include "grb2.h"
                #include "wgrib2.h"
                #include "fnlist.h"
                
                /*
                 * this file contains nice to know values 
                 */
                
                /*
                 * HEADER:-1:pds_fcst_time:inv:0:fcst_time(1) in units given by pds
                 */
       ##### -> int f_pds_fcst_time(ARG0) {
                    unsigned int p;
                    if (mode >= 0) {
                        p = forecast_time_in_units(sec);
                	if (p != 0xffffffff) sprintf(inv_out,"pds_fcst_time1=%u", p);
                    }
                    return 0;
                }
                
                
       ##### -> int number_of_forecasts_in_the_ensemble(unsigned char **sec) {
                    int pdt, n;
                
                    pdt = code_table_4_0(sec);
                    switch(pdt) {
                	case 1:
                	case 11:
                		n = sec[4][36]; break;
                	case 2:
                	case 3:
                	case 4:
                	case 12:
                	case 13:
                		n = sec[4][35]; break;
                	case 41:
                	case 43:
                		n = sec[4][38]; break;
                	default: n=-1; break;
                    }
                    return n;
                }
                
       ##### -> int perturbation_number(unsigned char **sec) {
                    int pdt, n;
                
                    pdt = code_table_4_0(sec);
                    switch(pdt) {
                	case 1:
                	case 11:
                		n = sec[4][35]; break;
                	case 41:
                	case 43:
                		n = sec[4][37]; break;
                	default: n = -1; break;
                    }
                    return n;
                }
                
          17 -> unsigned int forecast_time_in_units(unsigned char **sec) {
                
                    int p;
                    p = code_table_4_0(sec);
                    if (p <= 15 || p == 1000 || p == 1001 || p == 1002 || p == 1100 || p == 1101)  {
                        return uint4(sec[4]+18);
                    }
                    if (p >= 40 && p <= 43)  {
                        return uint4(sec[4]+20);
                    }
                    return 0xffffffff;
                }
                
                
                void fixed_surfaces(unsigned char **sec, int *type1, float *surface1, 
          34 -> 	int *undef_val1, int *type2, float *surface2, int *undef_val2) {
                
                    int pdt;
                    unsigned char *p1, *p2;
                    pdt = code_table_4_0(sec);
                    *undef_val1 = *undef_val2 = 1;
                    *surface1 = *surface2 = UNDEFINED;
                    *type1 = *type2 = 255;
                
                    switch (pdt) {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 1100:
                    case 1101:
                	p1 = sec[4]+22; p2 = sec[4]+28; break;
                    case 40:
                    case 41:
                    case 42:
                    case 43:
                	p1 = sec[4]+24; p2 = sec[4]+30; break;
                    case 20:
                    case 30:
                    case 31:
                    case 1000:
                    case 1001:
                    case 1002:
                    case 254:
                	return; break;
                    default: 
                	fprintf(stderr,"levels: product definition template #%d not supported\n", pdt);
                	return;
                	break;
                    }
                
                    if (*p1 != 255) {
                	*type1 = *p1;
                        if (p1[1] != 255) {
                	    if (p1[2] != 255 || p1[3] != 255 || p1[4] != 255 || p1[5] != 255) {
                		*undef_val1 = 0;
                                *surface1 = scaled2flt(INT1(p1[1]), int4(p1+2));
                	    }
                	}
                    }
                    if (*p2 != 255) {
                	*type2 = *p2;
                        if (p2[1] != 255) {
                	    if (p2[2] != 255 || p2[3] != 255 || p2[4] != 255 || p2[5] != 255) {
                		*undef_val2 = 0;
                                *surface2 = scaled2flt(INT1(p2[1]), int4(p2+2));
                	    }
                	}
                    }
                    return ;
                }
                
       ##### -> int background_generating_process_identifier(unsigned char **sec) {
                    unsigned char *p;
                    p = background_generating_process_identifier_location(sec);
                    if (p) return (int) *p;
                    return -1;
                }
       ##### -> unsigned char *background_generating_process_identifier_location(unsigned char **sec) {
                    int p;
                    p = GB2_ProdDefTemplateNo(sec);
                    if (p <= 15 || p == 1000 || p == 1001 || p == 1002 || p == 1100 || p == 1101)
                        return sec[4]+12;
                    if ( (p >= 40 && p <= 43) )
                        return sec[4]+14;
                    return NULL;
                }
                
                
       ##### -> int analysis_or_forecast_generating_process_identifier(unsigned char **sec) {
                    unsigned char *p;
                    p = analysis_or_forecast_generating_process_identifier_location(sec);
                    if (p) return (int) *p;
                    return -1;
                }
       ##### -> unsigned char *analysis_or_forecast_generating_process_identifier_location(unsigned char **sec) {
                    int p;
                    p = GB2_ProdDefTemplateNo(sec);
                    if (p <= 15 || p == 1000 || p == 1001 || p == 1002 || p == 1100 || p == 1101)
                        return sec[4]+13;
                    if ( (p >= 40 && p <= 43) )
                        return sec[4]+15;
                    return NULL;
                }
                
       ##### -> int hours_of_observational_data_cutoff_after_reference_time(unsigned char **sec) {
                    int p;
                    p = GB2_ProdDefTemplateNo(sec);
                    if (p <= 15 || p == 1000 || p == 1001 || p == 1002 || p == 1100 || p == 1101)
                        return int2(sec[4]+14);
                    return -1;
                }
                
       ##### -> int minutes_of_observational_data_cutoff_after_reference_time(unsigned char **sec) {
                    int p;
                    p = GB2_ProdDefTemplateNo(sec);
                    if (p <= 15 || p == 1000 || p == 1001 || p == 1002 || p == 1100 || p == 1101)
                        return int1(sec[4]+16);
                    return -1;
                }
                
                
       ##### -> int observation_generating_process_identifier(unsigned char **sec) {
                    int p;
                    p = GB2_ProdDefTemplateNo(sec);
                    if (p == 30 || p == 31)
                        return (int) sec[4][12];
                    return -1;
                }
                
                
                /*
                 * get substitute umissing value
                 *
                 * returns number of missing values
                 */
                
          17 -> int sub_missing_values(unsigned char **sec, float *missing1, float *missing2) {
                    int i, j;
                    unsigned char *p;
                
                    i = code_table_5_5(sec);
                    if (i < 1 || i > 2) return 0;
                    j = code_table_5_1(sec);
                    p = sec[5];
                    if (j == 0) {		// ieee
                	if (p[23] == 255 && p[24] == 255 && p[25] == 255 && p[26] == 255) *missing1 = UNDEFINED;
                	else *missing1 = ieee2flt(p+23);
                	if (i == 2) {
                	    if (p[27] == 255 && p[28] == 255 && p[29] == 255 && p[30] == 255) *missing1 = UNDEFINED;
                	    else *missing2 = ieee2flt(p+27);
                	}
                    }
                    else if (j == 1) {		// integer
                	if (p[23] == 255 && p[24] == 255 && p[25] == 255 && p[26] == 255) *missing1 = UNDEFINED;
                	else *missing1 = (float) int4(p+23);
                	if (i == 2) {
                	    if (p[27] == 255 && p[28] == 255 && p[29] == 255 && p[30] == 255) *missing1 = UNDEFINED;
                	    else *missing2 = (float) int4(p+27);
                	}
                    }
                    return i;
                }
                
                
                int stat_proc_verf_time(unsigned char **sec, int *year, int *month, int *day, int *hour, int *minute, int *second)
          17 -> {
                    int i, j;
                    i = code_table_4_0(sec);
                    j = 0;
                    if (i == 8) j = 34;
                    else if (i == 9) j = 47;
                    else if (i == 10) j = 35;
                    else if (i == 11) j = 37;
                    else if (i == 12) j = 36;
                    else if (i == 13) j = 68;
                    else if (i == 14) j = 64;
                
                    if (j) {
                	get_time(sec[4]+j, year, month, day, hour, minute, second);
                	return 0;
                    }
                    else {
                	*year = *month = *day = *hour = *minute = *second = 0;
                    }
                    return 1;
                }
                	
                	
                


Top 10 Lines:

     Line      Count

       78         34
       63         17
      212         17
      241         17

Execution Summary:

       14   Executable lines in this file
       14   Lines executed
   100.00   Percent of the file executed

       85   Total number of line executions
     6.07   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/Latlon.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include "grb2.h"
                #include "wgrib2.h"
                #include "fnlist.h"
                
                /*
                 * 12/2006 Public Domain Wesley Ebisuzaki
                 * 1/2007 Cleanup M. Schwarb
                 * 1/2008 lat and lon changed from float to double 
                 */
                   
                extern int decode;
                extern int need_output_file;
                extern enum output_order_type output_order;
                
                extern double *lat, *lon;
                extern int latlon;
                
                extern int nx, ny, new_GDS;
                extern unsigned int npnts;
                
                void free_lat_lon(void);
                
                /*
                 * HEADER:100:ij:inv:2:value of field at grid(X,Y) X=1,..,nx Y=1,..,ny
                 */
                
       ##### -> int f_ij(ARG2) {
                
                    struct local_struct {
                        int ix, iy, iptr;
                    };
                    struct local_struct *save;
                
                    if (mode == -1) {
                        decode = 1;
                        *local = save = (struct local_struct *) malloc( sizeof(struct local_struct));
                        if (save == NULL) fatal_error("memory allocation f_ij","");
                        save->ix = atoi(arg1);
                        save->iy = atoi(arg2);
                        save->iptr = -1;
                    }
                    if (mode < 0) return 0;
                    save = *local;
                
                    if (new_GDS) {
                        if (output_order != wesn) {
                            fatal_error("ij only works in we:sn order","");
                        }
                        if (save->ix <= 0 || save->ix > nx || save->iy <= 0 || save->iy > ny) {
                            fatal_error("invalid i, j values","");
                        }
                        save->iptr = (save->ix-1) + (save->iy-1) *nx;
                    }
                
                    if (mode > 0) sprintf(inv_out,"(%d,%d),val=%lg",save->ix,save->iy,data[save->iptr]);
                    else sprintf(inv_out,"val=%lg",data[save->iptr]);
                
                    return 0;
                }
                
                /*
                 * HEADER:100:ijlat:inv:2:lat,lon and grid value at grid(X,Y) X=1,..,nx Y=1,..,ny
                 */
                
       ##### -> int f_ijlat(ARG2) {
                
                    struct local_struct {
                        int ix, iy, iptr;
                    };
                    struct local_struct *save;
                
                    if (mode == -1) {
                        decode = latlon = 1;
                        *local = save = (struct local_struct *) malloc( sizeof(struct local_struct));
                        if (save == NULL) fatal_error("memory allocation f_ijlat","");
                        save->ix = atoi(arg1);
                        save->iy = atoi(arg2);
                        save->iptr = -1;
                    }
                    if (mode < 0) return 0;
                    save = *local;
                
                    if (new_GDS) {
                        if (output_order != wesn) {
                            fatal_error("ijlat only works in we:sn order","");
                        }
                        if (lat == NULL || lon == NULL || data == NULL) {
                            fatal_error("no lat/lon in ijlat","");
                        }
                
                        if (save->ix <= 0 || save->ix > nx || save->iy <= 0 || save->iy > ny) {
                            /* fprintf(stderr," nx=%d ny=%d ix=%d iy=%d\n",nx,ny,save->ix,save->iy); */
                            fatal_error("ijlat: invalid i, j values","");
                        }
                        save->iptr = (save->ix-1) + (save->iy-1) * nx;
                    }
                //vsm_fmt    sprintf(inv_out,"(%d,%d),lon=%g,lat=%g,val=%lg",save->ix,save->iy,
                    sprintf(inv_out,"(%d,%d),lon=%lf,lat=%lf,val=%lg",save->ix,save->iy,
                        lon[save->iptr],lat[save->iptr],data[save->iptr]);
                    return 0;
                }
                
                /*
                 * HEADER:100:ilat:inv:1:lat,lon and grid value at Xth grid point, X=1,..,npnts
                 */
                
       ##### -> int f_ilat(ARG1) {
                
                    struct local_struct {
                        int ix;
                    };
                    struct local_struct *save;
                    int i;
                
                    if (mode == -1) {
                        decode = latlon = 1;
                        *local = save = (struct local_struct *) malloc( sizeof(struct local_struct));
                        if (save == NULL) fatal_error("memory allocation f_ilat","");
                        save->ix = atoi(arg1);
                    }
                    if (mode < 0) return 0;
                
                    save = *local;
                    i = save->ix;
                
                    if (new_GDS) {
                        if (output_order != wesn) {
                            fatal_error("ilat only works in we:sn order","");
                        }
                        if (lat == NULL || lon == NULL || data == NULL) {
                            fatal_error("no lat/lon in ilat","");
                        }
                        if (i < 1 || i > (int) npnts) {
                            fatal_error_i("ilat: invalid i = %d", i);
                        }
                    }
                //vsm_fmt    sprintf(inv_out,"grid pt %d,lon=%g,lat=%g,val=%lg",i,
                    sprintf(inv_out,"grid pt %d,lon=%lf,lat=%lf,val=%lg",i,
                        lon[i-1],lat[i-1],data[i-1]);
                    return 0;
                }
                
                /*
                 * HEADER:100:lon:inv:2:value at grid point nearest lon=X lat=Y
                 */
                
       ##### -> int f_lon(ARG2) {
                
                    struct local_struct {
                        double plat, plon;
                        int iptr;
                    };
                    struct local_struct *save;
                
                    if (mode == -1) {
                        decode = latlon = 1;
                        *local = save = (struct local_struct *)malloc( sizeof(struct local_struct));
                        if (save == NULL) fatal_error("memory allocation f_lon","");
                        save->plon = atof(arg1);
                        if (save->plon < 0.0) save->plon += 360.0;
                        save->plat = atof(arg2);
                        save->iptr = -1;
                    }
                    if (mode < 0) return 0;
                    save = *local;
                
                    if (new_GDS) {
                //        if (output_order != wesn) {
                //            fatal_error("lon only works in we:sn order","");
                //        }
                        if (lat == NULL || lon == NULL || data == NULL) {
                            fatal_error("no val","");
                        }
                        closest_init(sec);
                        save->iptr = closest(sec, save->plat, save->plon);
                    }
                //vsm_frm    sprintf(inv_out,"lon=%g,lat=%g,val=%lg",lon[save->iptr],lat[save->iptr],data[save->iptr]);
                    if (save->iptr < 0)  {
                	sprintf(inv_out,"lon=999,lat=999,val=%lg", UNDEFINED);
                	fprintf(stderr,"-lon: grid outside of domain of data\n");
                	return 0;
                    }
                
                    if (mode == 0) {
                        sprintf(inv_out,"lon=%lf,lat=%lf,val=%lg",lon[save->iptr],lat[save->iptr],data[save->iptr]);
                    }
                    else {
                	sprintf(inv_out,"lon=%lf,lat=%lf,i=%d,", lon[save->iptr],lat[save->iptr],(save->iptr)+1);
                	inv_out += strlen(inv_out);
                	if (nx > 0 && ny > 0) {
                	    sprintf(inv_out,"ix=%d,iy=%d,", (save->iptr)%nx+1, (save->iptr)/nx+1);
                	    inv_out += strlen(inv_out);
                	}
                	sprintf(inv_out,"val=%lg", data[save->iptr]);
                    }
                    return 0;
                }
                
                
           1 -> int get_latlon(unsigned char **sec) {
                    int grid_template;
                
                    free_lat_lon();
                    grid_template = code_table_3_1(sec);
                    if (grid_template == 0) {
                        regular2ll(sec, &lat, &lon);
                    }
                    else if (grid_template == 10) {
                        mercator2ll(sec, &lat, &lon);
                    }
                    else if (grid_template == 20) {
                        polar2ll(sec, &lat, &lon);
                    }
                    else if (grid_template == 30) {
                        lambert2ll(sec, &lat, &lon);
                    }
                    else if (grid_template == 40) {
                        gauss2ll(sec, &lat, &lon);
                    }
                
                    return 0; 
                }
                
           1 -> void free_lat_lon(void) {
                    if (lat != NULL) {
                        free(lat);
                        lat = NULL;
                        free(lon);
                        lon = NULL;
                    }
                }
                


Top 10 Lines:

     Line      Count

      203          1
      227          1

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     0.33   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/CodeTable.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include "grb2.h"
                #include "wgrib2.h"
                #include "fnlist.h"
                
                /*
                 * CodeTable.c
                 *
                 * returns values of various code tables
                 *  use this routine instead of .h files
                 *
                 * 12/2006 Public Domain Wesley Ebisuzaki
                 * 1/2007 M. Schwarb
                 * 1/2008 S. Varlamov fixed to code_table_5.5
                 */
                
                /*
                 * HEADER:-1:code_table_0.0:inv:0:code table 0.0 discipline
                 */
                
       ##### -> int f_code_table_0_0(ARG0) {
                    int val;
                    char *string;
                
                    if (mode >= 0) {
                        val = code_table_0_0(sec);
                        string = NULL;
                        switch(val) {
                #include "CodeTable_0.0.dat"
                        }
                        if (string) sprintf(inv_out,"code table 0.0=%d %s", val, string);
                        else sprintf(inv_out,"code table 0.0=%d", val);
                    }
                    return 0;
                }
       ##### -> int code_table_0_0(unsigned char **sec) {
                    return  (int) sec[0][9];
                }
                
                /*
                 * HEADER:-1:code_table_1.0:inv:0:code table 1.0 master table version
                 */
                
       ##### -> int f_code_table_1_0(ARG0) {
                
                    if (mode >= 0) {
                        sprintf(inv_out,"code table 1.0=%d", code_table_1_0(sec));
                    }
                    return 0;
                }
       ##### -> int code_table_1_0(unsigned char **sec) {
                    return  (int) sec[1][9];
                }
                
                /*
                 * HEADER:-1:code_table_1.1:inv:0:code table 1.1 local table version
                 */
                
       ##### -> int f_code_table_1_1(ARG0) {
                
                    if (mode >= 0) {
                        sprintf(inv_out,"code table 1.1=%d", code_table_1_1(sec));
                    }
                    return 0;
                }
       ##### -> int code_table_1_1(unsigned char **sec) {
                    return  (int) sec[1][10];
                }
                
                
                /*
                 * HEADER:-1:code_table_1.2:inv:0:code table 1.2 significance of reference time
                 */
                
       ##### -> int f_code_table_1_2(ARG0) {
                    char *string;
                    int val;
                    if (mode >= 0) {
                        val = code_table_1_2(sec);
                        string = NULL;
                        switch(val) {
                #include "CodeTable_1.2.dat"
                        }
                	if (string == NULL) sprintf(inv_out,"code table 1.2=%d", val);
                        else sprintf(inv_out,"code table 1.2=%d %s", val, string);
                    }
                    return 0;
                }
          17 -> int code_table_1_2(unsigned char **sec) {
                    return  (int) sec[1][11];
                }
                
                /*
                 * HEADER:-1:code_table_1.3:inv:0:code table 1.3 production status of processed data
                 */
                
       ##### -> int f_code_table_1_3(ARG0) {
                    char *string;
                    int val;
                
                    if (mode >= 0) {
                        val = code_table_1_3(sec);
                        string = NULL;
                	switch(val) {
                #include "CodeTable_1.3.dat"
                        }
                        if (string == NULL) sprintf(inv_out,"code table 1.3=%d", val);
                        else sprintf(inv_out,"code table 1.3=%d %s", val, string);
                    }
                    return 0;
                }
       ##### -> int code_table_1_3(unsigned char **sec) {
                    return  (int) sec[1][19];
                }
                
                
                /*
                 * HEADER:-1:code_table_1.4:inv:0:code table 1.4 type of processed data
                 */
                
       ##### -> int f_code_table_1_4(ARG0) {
                    char *string;
                    int val;
                    if (mode >= 0) {
                        val = code_table_1_4(sec);
                	string = NULL;
                	switch(val) {
                #include "CodeTable_1.4.dat"
                	}
                	if (string == NULL) sprintf(inv_out,"code table 1.4=%d", val);
                	else sprintf(inv_out,"code table 1.4=%d %s", val, string);
                    }
                    return 0;
                }
       ##### -> int code_table_1_4(unsigned char **sec) {
                    return  (int) sec[1][20];
                }
                
                /*
                 * HEADER:-1:code_table_3.0:inv:0:code table 3.0 Source of grid definition
                 */
                
       ##### -> int f_code_table_3_0(ARG0) {
                
                    if (mode >= 0) {
                        sprintf(inv_out,"code table 3.0=%d", code_table_3_0(sec));
                    }
                    return 0;
                }
       ##### -> int code_table_3_0(unsigned char **sec) {
                    return  (int) sec[3][5];
                }
                
                /*
                 * HEADER:-1:code_table_3.1:inv:0:code table 3.1 Grid definition template number
                 */
                
       ##### -> int f_code_table_3_1(ARG0) {
                    char *string;
                    int val;
                    if (mode >= 0) {
                        val = code_table_3_1(sec);
                	string = NULL;
                	switch(val) {
                #include "CodeTable_3.1.dat"
                	}
                	if (string == NULL) sprintf(inv_out,"code table 3.1=%d", val);
                	else sprintf(inv_out,"code table 3.1=%d %s", val, string);
                    }
                    return 0;
                }
          25 -> int code_table_3_1(unsigned char **sec) {
                    return  (int) uint2(sec[3]+12);
                }
                
                /*
                 * HEADER:-1:code_table_3.2:inv:0:code table 3.2 Size and Shape of Earth
                 */
                
       ##### -> int f_code_table_3_2(ARG0) {
                    int val;
                    char *string;
                    if (mode >= 0) {
                	val = code_table_3_2(sec);
                        if (val >= 0) {
                            string = NULL;
                            switch(val) {
                #include "CodeTable_3.2.dat"
                	    }
                	    if (string == NULL) sprintf(inv_out,"code table 3.2=%d", val);
                	    else sprintf(inv_out,"code table 3.2=%d %s", val, string);
                        }
                	if (mode > 0) {
                	    inv_out += strlen(inv_out);
                	    sprintf(inv_out,", ave radius of earth=%lf km",radius_earth(sec)/1000.0);
                	}
                    }
                    return 0;
                }
                
       ##### -> int code_table_3_2(unsigned char **sec) {
                    unsigned char *p;
                    p = code_table_3_2_location(sec);
                    if (p == NULL) return -1;
                    return (int) *p;
                }
                
           1 -> unsigned char *code_table_3_2_location(unsigned char **sec) {
                    int grid_def;
                    grid_def = code_table_3_1(sec);
                    if (grid_def < 50 || grid_def == 90 || grid_def == 110 || grid_def == 204 ||
                        grid_def == 1000 || grid_def == 1100 ||
                         (grid_def == 32768 && GB2_Center(sec) == NCEP) 
                         || (grid_def == 32768 && GB2_Center(sec) == NCEP) ) return sec[3]+14;
                    return  NULL;
                }
                
                
                /*
                 * HEADER:-1:code_table_3.6:inv:0:code table 3.6 Spectral data representation type
                 */
                
       ##### -> int f_code_table_3_6(ARG0) {
                    int val;
                    if (mode >= 0) {
                	val = code_table_3_6(sec);
                	if (val >= 0) sprintf(inv_out,"code table 3.6=%d", val);
                    }
                    return 0;
                }
       ##### -> int code_table_3_6(unsigned char **sec) {
                    int grid_def;
                    grid_def = code_table_3_1(sec);
                    if (grid_def >= 50 && grid_def <= 53)  return GDS_Harmonic_code_3_6(sec[3]);
                    return -1;
                }
                
                /*
                 * HEADER:-1:code_table_3.7:inv:0:code table 3.7 Spectral data representation mode
                 */
                
       ##### -> int f_code_table_3_7(ARG0) {
                    int val;
                    if (mode >= 0) {
                        val = code_table_3_7(sec);
                        if (val >= 0) sprintf(inv_out,"code table 3.7=%d", val);
                    }
                    return 0;
                }
       ##### -> int code_table_3_7(unsigned char **sec) {
                    int grid_def;
                    grid_def = code_table_3_1(sec);
                    if (grid_def >= 50 && grid_def <= 53)  return GDS_Harmonic_code_3_7(sec[3]);
                    return -1;
                }
                
                /*
                 * HEADER:-1:code_table_3.8:inv:0:code table 3.8 Grid point position
                 */
                
       ##### -> int f_code_table_3_8(ARG0) {
                    int val;
                    char *string;
                    if (mode >= 0) {
                        val = code_table_3_8(sec);
                	if (val >= 0) {
                            string = NULL;
                            switch(val) {
                #include "CodeTable_3.8.dat"
                            }
                            if (string == NULL) sprintf(inv_out,"code table 3.8=%d", val);
                            else sprintf(inv_out,"code table 3.8=%d %s", val, string);
                        }
                    }
                    return 0;
                }
                
       ##### -> int code_table_3_8(unsigned char **sec) {
                    int grid_def;
                    grid_def = code_table_3_1(sec);
                    if (grid_def == 100)  return sec[3][31];
                    return -1;
                }
                
                /*
                 * HEADER:-1:code_table_3.11:inv:0:code table 3.11 regional/global thinned/reduced grid
                
                 */
       ##### -> int f_code_table_3_11(ARG0) {
                    int val;
                    char *string;
                    if (mode >= 0) {
                        if ((val = code_table_3_11(sec)) >= 0) {
                            string = NULL;
                            switch(val) {
                		case 0: string = "not used";
                			break;
                		case 1: string = "thinned global grid";
                			break;
                		case 2: string = "thinned regional grid";
                			break;
                            }
                            if (string == NULL) sprintf(inv_out,"code table 3.11=%d", val);
                            else sprintf(inv_out,"code table 3.11=%d %s", val, string);
                        }
                    }
                    return 0;
                }
       ##### -> int code_table_3_11(unsigned char **sec) {
                    return sec[3][11];
                }
                
                /*
                 * HEADER:-1:code_table_3.15:inv:0:code table 3.15 Physical meaning of vertical coordinate
                 */
       ##### -> int f_code_table_3_15(ARG0) {
                    int val;
                    char *string;
                    if (mode >= 0) {
                        if ((val = code_table_3_15(sec)) >= 0) {
                            string = NULL;
                            switch(val) {
                #include "CodeTable_3.15.dat"
                            }
                            if (string == NULL) sprintf(inv_out,"code table 3.15=%d", val);
                            else sprintf(inv_out,"code table 3.15=%d %s", val, string);
                        }
                    }
                    return 0;
                }
       ##### -> int code_table_3_15(unsigned char **sec) {
                    int grid_def;
                    grid_def = code_table_3_1(sec);
                    if (grid_def == 1000)  return sec[3][62];
                    if (grid_def == 1200)  return sec[3][38];
                    return -1;
                }
                
                /*
                 * HEADER:-1:code_table_3.21:inv:0:code table 3.21 Vertical Dimension coordinate values defn
                 */
       ##### -> int f_code_table_3_21(ARG0) {
                    int val;
                    char *string;
                    if (mode >= 0) {
                        val = code_table_3_21(sec);
                        if (val >= 0) {
                            string = NULL;
                            switch(val) {
                #include "CodeTable_3.21.dat"
                            }
                            if (string == NULL) sprintf(inv_out,"code table 3.21=%d", val);
                            else sprintf(inv_out,"code table 3.21=%d %s", val, string);
                        }
                    }
                    return 0;
                }
       ##### -> int code_table_3_21(unsigned char **sec) {
                    int grid_def;
                    grid_def = code_table_3_1(sec);
                    if (grid_def == 1000)  return sec[3][63];
                    if (grid_def == 1200)  return sec[3][39];
                    return -1;
                }
                
                /*
                 * HEADER:-1:code_table_4.0:inv:0:code table 4.0 Product Definition Template Number
                 */
                
       ##### -> int f_code_table_4_0(ARG0) {
                    int val;
                    char *string;
                    if (mode >= 0) {
                        val = code_table_4_0(sec);
                        string = NULL;
                        switch(val) {
                #include "CodeTable_4.0.dat"
                        }
                        if (string == NULL) sprintf(inv_out,"code table 4.0=%d", val);
                        else sprintf(inv_out,"code table 4.0=%d %s", val, string);
                    }
                    return 0;
                }
          85 -> int code_table_4_0(unsigned char **sec) {
                    return  GB2_ProdDefTemplateNo(sec);
                }
                
                /*
                 * HEADER:-1:code_table_4.1:inv:0:code table 4.1
                 */
                
       ##### -> int f_code_table_4_1(ARG0) {
                    int p;
                    if (mode >= 0) {
                	p = code_table_4_1(sec);
                	if (p >= 0) sprintf(inv_out,"code table 4.1=%d", p);
                    }
                    return 0;
                }
       ##### -> int code_table_4_1(unsigned char **sec) {
                    int p;
                    p = GB2_ProdDefTemplateNo(sec);
                	if (p <= 15 || p == 20 || p == 30 || p == 31 || (p >= 40 && p <= 43)||  p == 254 || p == 1000 || p == 1001 || 
                		p == 1002 || p == 1100 || p == 1101) return (int) sec[4][9];
                    return -1;
                }
                
                /*
                 * HEADER:-1:code_table_4.2:inv:0:code table 4.2
                 */
                
       ##### -> int f_code_table_4_2(ARG0) {
                    int p;
                    if (mode >= 0) {
                	p = code_table_4_2(sec);
                	if (p >= 0) sprintf(inv_out,"code table 4.2=%d", p);
                    }
                    return 0;
                }
       ##### -> int code_table_4_2(unsigned char **sec) {
                    int p;
                    p = GB2_ProdDefTemplateNo(sec);
                    if (p <= 15 || p == 20 || p == 30 || p == 31 || (p >= 40 && p <= 43) ||  p == 1000 || p == 1001 || p == 1002 || p == 1100 || p == 1101) 
                        return (int) sec[4][10];
                    return -1;
                }
                
                /*
                 * HEADER:-1:code_table_4.3:inv:0:code table 4.3 Type of Generating Process
                 */
       ##### -> int f_code_table_4_3(ARG0) {
                    int val, center;
                    char *string;
                    if (mode >= 0) {
                        val = code_table_4_3(sec);
                	center = GB2_Center(sec);
                        string = NULL;
                        switch(val) {
                #include "CodeTable_4.3.dat"
                        }
                        if (string == NULL) sprintf(inv_out,"code table 4.3=%d", val);
                        else sprintf(inv_out,"code table 4.3=%d %s", val, string);
                    }
                    return 0;
                }
       ##### -> int code_table_4_3(unsigned char **sec) {
                    int p;
                    p = GB2_ProdDefTemplateNo(sec);
                    if (p <= 15 || p == 20 || p == 30 || p == 31 ||  p == 1000 || p == 1001 || p == 1002 || p == 1100 || p == 1101) 
                        return (int) sec[4][11];
                    if ( (p >= 40 && p <= 43) ) 
                        return (int) sec[4][13];
                    return -1;
                }
                
                /*
                 * HEADER:-1:code_table_4.4:inv:0:code table 4.4
                 */
       ##### -> int f_code_table_4_4(ARG0) {
                    int val;
                    char *string;
                    if (mode >= 0) {
                	val = code_table_4_4(sec);
                        string = NULL;
                        switch(val) {
                #include "CodeTable_4.4.dat"
                        }
                        if (string == NULL) sprintf(inv_out,"code table 4.4=%d", val);
                        else sprintf(inv_out,"code table 4.4=%d (%s)", val, string);
                    }
                    return 0;
                }
          17 -> int code_table_4_4(unsigned char **sec) {
                    int p;
                    p = GB2_ProdDefTemplateNo(sec);
                    if (p <= 15 || p == 1000 || p == 1001 || p == 1002 || p == 1100 || p == 1101) 
                	return (int) sec[4][17];
                    if (p >= 40 && p <= 43) return (int) sec[4][19];
                    return -1;
                }
                
                /*
                 * HEADER:-1:code_table_4.5a:inv:0:code table 4.5 (1st value)
                 */
       ##### -> int f_code_table_4_5a(ARG0) {
                    int p;
                    if (mode >= 0) {
                	p = code_table_4_5a(sec);
                	if (p >= 0) sprintf(inv_out,"code table 4.5a=%d", p);
                    }
                    return 0;
                }
       ##### -> int code_table_4_5a(unsigned char **sec) {
                    int p;
                    p = GB2_ProdDefTemplateNo(sec);
                
                    if (p <= 15 || p == 1100 || p == 1101) return (int) sec[4][22];
                    if (p >= 40 && p <= 43) return (int) sec[4][24];
                    return -1;
                }
                /*
                 * HEADER:-1:code_table_4.5b:inv:0:code table 4.5 (2nd value)
                 */
       ##### -> int f_code_table_4_5b(ARG0) {
                    int p;
                    if (mode >= 0) {
                	p = code_table_4_5b(sec);
                	if (p >= 0) sprintf(inv_out,"code table 4.5b=%d", p);
                    }
                    return 0;
                }
       ##### -> int code_table_4_5b(unsigned char **sec) {
                    int p;
                    p = GB2_ProdDefTemplateNo(sec);
                
                    if (p <= 15 || p == 1100 || p == 1101) return (int) sec[4][28];
                    if (p >= 40 && p <= 43) return (int) sec[4][30];
                    return -1;
                }
                
                /*
                 * HEADER:-1:code_table_4.6:inv:0:code table 4.6 ensemble type
                 */
       ##### -> int f_code_table_4_6(ARG0) {
                    int p;
                    if (mode >= 0) {
                	p = code_table_4_6(sec);
                	if (p >= 0) sprintf(inv_out,"code table 4.6=%d", p);
                    }
                    return 0;
                }
       ##### -> int code_table_4_6(unsigned char **sec) {
                    unsigned char *p;
                    p = code_table_4_6_location(sec);
                    if (p == NULL) return -1;
                    return *p;
                }
       ##### -> unsigned char *code_table_4_6_location(unsigned char **sec) {
                    int p;
                    p = GB2_ProdDefTemplateNo(sec);
                    if (p == 1 || p == 11) return  sec[4]+34;
                    if (p >= 40 && p <= 43) return sec[4]+36;
                    return NULL;
                }
                
                
                /*
                 * HEADER:-1:code_table_4.7:inv:0:code table 4.7 derived forecast
                 */
       ##### -> int f_code_table_4_7(ARG0) {
                    int val;
                    if (mode >= 0) {
                	val = code_table_4_7(sec);
                	if (val >= 0) sprintf(inv_out,"code table 4.7=%d", val);
                    }
                    return 0;
                }
       ##### -> int code_table_4_7(unsigned char **sec) {
                    int pdt;
                    pdt = GB2_ProdDefTemplateNo(sec);
                    switch (pdt) {
                	case 2:
                	case 3:
                	case 4:
                	case 12:
                		return (int) sec[4][34]; break;
                    }
                    return -1;
                }
                /*
                 * HEADER:-1:code_table_4.9:inv:0:code table 4.9 Probability Type
                 */
       ##### -> int f_code_table_4_9(ARG0) {
                    int val;
                    char *string;
                    if (mode >= 0) {
                        val = code_table_4_9(sec);
                        if (val >= 0) {
                            string = NULL;
                            switch(val) {
                #include "CodeTable_4.9.dat"
                            }
                            if (string == NULL) sprintf(inv_out,"code table 4.9=%d", val);
                            else sprintf(inv_out,"code table 4.9=%d %s", val, string);
                        }
                    }
                    return 0;
                }
                
       ##### -> int code_table_4_9(unsigned char **sec) {
                    unsigned char *p;
                    p = code_table_4_9_location(sec);
                    if (p == NULL) return -1;
                    return *p;
                }
                
       ##### -> unsigned char *code_table_4_9_location(unsigned char **sec) {
                    int val;
                    val = GB2_ProdDefTemplateNo(sec);
                    switch(val) {
                    case 5:
                    case 9:
                	return sec[4]+36;
                	break;
                    }
                    return NULL;
                }
                
                
                /*
                 * HEADER:-1:code_table_4.10:inv:0:code table 4.10 statistical processing
                 */
       ##### -> int f_code_table_4_10(ARG0) {
                    int val;
                    char *string;
                    if (mode >= 0) {
                	val = code_table_4_10(sec);
                	if (val >= 0) {
                	    string = NULL;
                	    switch(val) {
                #include "CodeTable_4.10.dat"
                	    }
                	    if (string == NULL) sprintf(inv_out,"code table 4.10=%d", val);
                	    else sprintf(inv_out,"code table 4.10=%d %s", val, string);
                	}
                    }
                    return 0;
                }
       ##### -> int code_table_4_10(unsigned char **sec) {
                    int val, i; 
                    val = GB2_ProdDefTemplateNo(sec);
                    switch (val) {
                	case 8: i = sec[4][46]; break;
                	case 9: i = sec[4][59]; break;
                	case 10: i = sec[4][47]; break;
                	case 11: i = sec[4][49]; break;
                	case 12: i = sec[4][48]; break;
                	case 13: i = sec[4][80]; break;
                	case 14: i = sec[4][76]; break;
                	case 15: i = sec[4][34]; break;
                	case 42: i = sec[4][48]; break;
                	case 43: i = sec[4][51]; break;
                	case 1001: i = sec[4][26]; break;
                	case 1002: i = sec[4][24]; break;
                	case 1101: i = sec[4][38]; break;
                	default: i = -1; break;
                    }
                    return i;
                }
                
                /*
                 * HEADER:-1:code_table_4.11:inv:0:code table 4.11 type of time intervals
                 */
       ##### -> int f_code_table_4_11(ARG0) {
                    int val;
                    char *string;
                    if (mode >= 0) {
                        val = code_table_4_11(sec);
                        if (val >= 0) {
                            string = NULL;
                            switch(val) {
                #include "CodeTable_4.11.dat"
                            }
                            if (string == NULL) sprintf(inv_out,"code table 4.11=%d", val);
                            else sprintf(inv_out,"code table 4.11=%d %s", val, string);
                        }
                    }
                    return 0;
                }
                
                
       ##### -> int code_table_4_11(unsigned char **sec) {
                    int val, i; 
                    val = GB2_ProdDefTemplateNo(sec);
                    switch (val) {
                	case 8: i = sec[4][47]; break;
                	case 9: i = sec[4][60]; break;
                	case 10: i = sec[4][48]; break;
                	case 11: i = sec[4][50]; break;
                	case 12: i = sec[4][49]; break;
                	case 13: i = sec[4][81]; break;
                	case 14: i = sec[4][77]; break;
                	case 42: i = sec[4][49]; break;
                	case 43: i = sec[4][52]; break;
                	case 1001: i = sec[4][27]; break;
                	case 1101: i = sec[4][39]; break;
                	default: i = -1; break;
                    }
                    return i;
                }
                
                /*
                 * HEADER:-1:code_table_4.15:inv:0:code table 4.11 type of areal statistical processing
                 */
       ##### -> int f_code_table_4_15(ARG0) {
                    int val;
                    char *string;
                    if (mode >= 0) {
                        val = code_table_4_15(sec);
                        if (val >= 0) {
                            string = NULL;
                            switch(val) {
                #include "CodeTable_4.15.dat"
                            }
                            if (string == NULL) sprintf(inv_out,"code table 4.15=%d", val);
                            else sprintf(inv_out,"code table 4.15=%d %s", val, string);
                        }
                    }
                    return 0;
                }
                
       ##### -> int code_table_4_15(unsigned char **sec) {
                    int val, i;
                    val = GB2_ProdDefTemplateNo(sec);
                    switch (val) {
                        case 15: i = sec[4][35]; break;
                        default: i = -1; break;
                    }
                    return i;
                }
                
                
                /*
                 * HEADER:-1:code_table_4.230:inv:0:code table 4.230 chemical constituent type
                 */
       ##### -> int f_code_table_4_230(ARG0) {
                    int val;
                    char *string;
                    if (mode >= 0) {
                        val = code_table_4_230(sec);
                        if (val >= 0) {
                            string = NULL;
                            switch(val) {
                #include "CodeTable_4.230.dat"
                            }
                            if (string == NULL) sprintf(inv_out,"code table 4.230=%d", val);
                            else sprintf(inv_out,"code table 4.230=%d %s", val, string);
                        }
                    }
                    return 0;
                }
                
       ##### -> int code_table_4_230(unsigned char **sec) {
                    int val, i;
                    val = GB2_ProdDefTemplateNo(sec);
                    switch (val) {
                        case 40: 
                	case 41:
                	case 42:
                	case 43:
                		i = uint2(sec[4]+11); break;
                        default: i = -1; break;
                    }
                    return i;
                }
                
                /*
                 * HEADER:-1:code_table_5.0:inv:0:code table 5.0 data representation number
                 */
       ##### -> int f_code_table_5_0(ARG0) {
                    int p;
                    char *string;
                    if (mode >= 0) {
                	p = code_table_5_0(sec);
                	if (p >= 0) {
                	    string = NULL;
                	    switch(p) {
                #include "CodeTable_5.0.dat"
                            }
                	    if (string == NULL) sprintf(inv_out,"code table 5.0=%d", p);
                	    else sprintf(inv_out,"code table 5.0=%d %s", p, string);
                	}
                    }
                    return 0;
                }
                
          51 -> int code_table_5_0(unsigned char **sec) {
                    return (int) uint2(sec[5]+9);
                }
                
                /*
                 * HEADER:-1:code_table_5.1:inv:0:code table 5.1 type of original field values
                 */
       ##### -> int f_code_table_5_1(ARG0) {
                    int p;
                    char *string;
                
                    if (mode >= 0) {
                        p = code_table_5_1(sec);
                        if (p >= 0) {
                	    string = NULL;
                	    switch(p) {
                #include "CodeTable_5.1.dat"
                            }
                	    if (string == NULL) sprintf(inv_out,"code table 5.1=%d", p);
                	    else sprintf(inv_out,"code table 5.1=%d %s", p, string);
                	}
                    }
                    return 0;
                }
                
       ##### -> int code_table_5_1(unsigned char **sec) {
                
                    switch(code_table_5_0(sec)) {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 40:
                    case 41:
                        return (int) (sec[5][20]);
                        break;
                    default:
                	return -1;
                	break;
                    }
                    return -1;
                }
                
                /*
                 * HEADER:-1:code_table_5.4:inv:0:code table 5.4 group splitting method
                 */
                
       ##### -> int f_code_table_5_4(ARG0) {
                    int p;
                    if (mode >= 0) {
                        p = code_table_5_4(sec);
                        if (p >= 0) sprintf(inv_out,"code table 5.4=%d", p);
                    }
                    return 0;
                }
       ##### -> int code_table_5_4(unsigned char **sec) {
                    if (code_table_5_0(sec) < 2 || code_table_5_0(sec) > 3) return -1;
                    return (int) (sec[5][21]);
                }
                
                
                /*
                 * HEADER:-1:code_table_5.5:inv:0:code table 5.5 missing value management for complex packing
                 */
       ##### -> int f_code_table_5_5(ARG0) {
                    int p;
                    if (mode >= 0) {
                        p = code_table_5_5(sec);
                        if (p >= 0) sprintf(inv_out,"code table 5.5=%d", p);
                    }
                    return 0;
                }
          17 -> int code_table_5_5(unsigned char **sec) {
                    if (code_table_5_0(sec) < 2 || code_table_5_0(sec) > 3) return -1;
                    return (int) (sec[5][22]);
                }
                
                /*
                 * HEADER:-1:code_table_5.6:inv:0:code table 5.5 complex packing spatial differencing
                 */
       ##### -> int f_code_table_5_6(ARG0) {
                    int p;
                    if (mode >= 0) {
                        p = code_table_5_6(sec);
                        if (p >= 0) sprintf(inv_out,"code table 5.6=%d", p);
                    }
                    return 0;
                }
       ##### -> int code_table_5_6(unsigned char **sec) {
                    if (code_table_5_0(sec) != 3) return -1;
                    return (int) (sec[5][47]);
                }
                
                /*
                 * HEADER:-1:code_table_5.7:inv:0:code table 5.7 precision in IEEE packing
                 */
       ##### -> int f_code_table_5_7(ARG0) {
                    int p;
                    if (mode >= 0) {
                        p = code_table_5_7(sec);
                        if (p >= 0) sprintf(inv_out,"code table 5.7=%d", p);
                    }
                    return 0;
                }
                
       ##### -> int code_table_5_7(unsigned char **sec) {
                    if (code_table_5_0(sec) ==  4) return (int) (sec[5][11]);
                    return -1;
                }
                
                
                
                
                /*
                 * HEADER:-1:code_table_6.0:inv:0:code table 6.0 Bitmap indicator
                 */
       ##### -> int f_code_table_6_0(ARG0) {
                    int p;
                    char *string;
                    if (mode >= 0) {
                        p = code_table_6_0(sec);
                        if (p >= 0) {
                	    if (mode == 0) sprintf(inv_out,"code table 6.0=%d", p);
                	    else {
                	        string = NULL;
                	        switch(p) {
                #include "CodeTable_6.0.dat"
                                }
                	        if (string == NULL) sprintf(inv_out,"code table 6.0=%d", p);
                	        else sprintf(inv_out,"code table 6.0=%d %s", p, string);
                	    }
                	}
                    }
                    return 0;
                }
                
       ##### -> int code_table_6_0(unsigned char **sec) {
                    return (int) (sec[6][5]);
                }


Top 10 Lines:

     Line      Count

      386         85
      779         51
      174         25
       91         17
      475         17
      851         17
      210          1

Execution Summary:

       75   Executable lines in this file
       75   Lines executed
   100.00   Percent of the file executed

      213   Total number of line executions
     2.84   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/my_convert.c:
                /******************************************************************************************
                
                 This file is part of wgrib2 and is distributed under terms of the GNU General Public License
                 For details see, Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
                 Boston, MA  02110-1301  USA
                
                 First version: Copyright (C) 2007 Kristian Nilssen
                 1st release version 3/2007, changes by Wesley Ebisuzaki
                 versions 05/2007 - 06/2009 Sergey Varlamov, vsm@jamstec.go.jp
                 Version 8 June 2009
                 */
                
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <math.h>
                //#include <time.h>
                #include <ctype.h>
                #include "grb2.h"
                #include "wgrib2.h"
                #include "fnlist.h"
                #include "wgrib2nc.h"
                
                #include <assert.h>
                #include <mpi.h>
                #include "my_netcdf.h"
                
                //#define DEBUG_NC
                
                
                #if defined USE_NETCDF3 || defined USE_NETCDF4
                #include <netcdf.h>
                
                /* defined in Netcdf_sup.c */
                extern int nc_grads_compatible;
                extern int nc_pack;
                extern float nc_pack_offset;
                extern float nc_pack_scale;
                extern float nc_valid_min;
                extern float nc_valid_max;
                extern int nc_nlev;
                extern double nc_date0;
                extern int    nc_date0_type;  /* 1 for absolute, -1 for relative (alignment only) */
                extern double nc_dt;          /* -1 will be used for variable (undefined) step */
                extern int nc4;
                
                /* defined in wgrib2.c */
                extern int file_append;
                extern int decode, latlon;
                extern double *lat, *lon;
                extern int nx, ny;
                // extern unsigned in npnts;
                extern enum output_order_type output_order;
                extern int mode, new_GDS;
                
                
                static int check_nc_latlon( int ncid, int y_dim, int x_dim, int dim_latlon );
                
                static int get_nc_time_ind(int ncid, double verf_utime, int time_var, int time_dim,
                                  int * time_ind, double * last_verf_time,
                                  double * tm_step, int time_step_type, double date0 );
                static int update_nc_ref_time(int ncid, double verf_utime, double ref_utime,
                                       int time_var, int time_step_type, double time_step);
                
                
                
                /******************************************************************************************/
                static int g2nc_type2pack(int type)
       ##### -> {
                  switch (type)
                  {
                    case NC_BYTE:
                      return G2NC_PACK_BYTE;
                    case NC_SHORT:
                      return G2NC_PACK_SHORT;
                    case NC_FLOAT:
                      return G2NC_PACK_FLOAT;
                    case NC_DOUBLE:
                      return G2NC_PACK_DOUBLE;
                    default:
                      return G2NC_PACK_UNDEF;
                  }
                }
                static int g2nc_pack2type(int pack)
       ##### -> {
                  switch (pack)
                  {
                    case G2NC_PACK_BYTE:
                      return NC_BYTE;
                    case G2NC_PACK_SHORT:
                      return NC_SHORT;
                    case G2NC_PACK_FLOAT:
                      return NC_FLOAT;
                    case G2NC_PACK_DOUBLE:
                      return NC_DOUBLE;
                    case G2NC_PACK_UNDEF:  /*default - float*/
                      return NC_FLOAT;
                    default:
                      return NC_NAT;
                  }
                }
                /*_FillValue for different data types, could be used for packing (short,byte), max value*/
                static short       sfill_value = G2NC_FILL_VALUE_SHORT;
                static signed char bfill_value = G2NC_FILL_VALUE_BYTE;
                static float       ffill_value = G2NC_FILL_VALUE_FLOAT;
                static double      dfill_value = G2NC_FILL_VALUE_DOUBLE;
                
                /****************
                 * cheap copy of f_netcdf
                 ****************/
                 int convert_nc_info(unsigned char **sec, float *data, unsigned int ndata,
                                                    char *inv_out, nc_info_t **local)
          17 -> {
                  
                    nc_info_t *save;
                
                  int varid, i, ok;
                  unsigned int j;
                  char varname_buf[_MAX_PATH],level_buf[_MAX_PATH];
                  char name[_MAX_PATH], desc[_MAX_PATH], unit[_MAX_PATH];
                  int time_ind;      /* current time step index to write in netcdf */
                  int level_ind=-1;   /* current z-dim index to write in netcdf */
                  size_t start[4];   /* record start location in 4D = {TIME0, LEV0, LAT0, LON0}; */
                  size_t count[4];   /* record size in 4D = {TIMES, LEVS, LATS, LONS}; */
                  int dimids[4],test_dimids[4];   //lev_types[2];
                
                  size_t chunks[4];
                  int shuffle, deflate, deflate_level;
                
                  int year, month, day, hour, minute, second, err_code;
                  int grid_template, ndims;
                  double verf_utime, tm_step, dx, dy, ref_utime;
                  int level_type1 = -1, level_type2 = -1;
                  int undef_val1, undef_val2;
                //  int center, subcenter;
                  float level_val1=0, level_val2, dz, dz1; //level_val2=0,lev_vals[2], test_val1, test_val2;
                  float scale_factor, add_offset, valid_min, valid_max;
                  double max=0, min=0, range=0;
                  nc_type var_type;
                  int var_pack;
                  float* fdata;
                  short* sdata;
                  signed char* bdata;
                  char *str;
                  float dd;
                  unsigned char *gds;
                
                  size_t dimlens[2];
                  size_t bufsize, nvar;
                  int offset;
                  int rank;
                
                  rank = MPI_Comm_rank(MPI_COMM_WORLD, &rank);
                
                    assert(rank >= 0);
                
                    //if(rank == 0){      /* start of if(rank == 0) */
                        
                    // mode 0,1,2 for decoding a message.
                    if (output_order != wesn && output_order != wens) fatal_error("netcdf: only works in we:sn order","");
                    save = *local;
                    if (new_GDS && save->initialized && save->nid ) fatal_error("netcdf: only one grid type at a time","");
                
                    // Specify dimension of lat-lon coordinates (1 - COARDS, 2 - CF-1.0)
                    dx = 1;
                    dy = 1;
                
                    /*
                     * deal with grid template
                     */
                    grid_template = code_table_3_1(sec);
                    
                    if (save->initialized)
                    {
                      if (save->grid_template != grid_template)
                      {
                        fatal_error("netcdf: grid templates differs from this in netcd file %s",save->ncfile);
                      }
                    }
                    else
                    {
                      if (grid_template == 0 || grid_template == 10 || grid_template == 40)
                      {
                        // COARDS convention only allows lat-lon, mercator and gaussian
                        save->dim_latlon = 1; //"COARDS", rectangular non-rotated grids
                      }
                      else if (grid_template == 20 || grid_template == 30)
                      {
                        // CF convention allows much more...
                        save->dim_latlon = 2; //"CF-1.0"; include here also rotated grids when becomes possible
                        gds = sec[3];
                        if (grid_template == 20)
                        {
                          dy = fabs(GDS_Polar_dy(gds));
                          dx = fabs(GDS_Polar_dx(gds));
                //      lov = GDS_Polar_lov(gds);
                //      lad = GDS_Polar_lad(gds);
                        }
                        else if (grid_template == 30)
                        {
                          dy = fabs(GDS_Lambert_dy(gds));
                          dx = fabs(GDS_Lambert_dx(gds));
                //      lov = GDS_Lambert_Lov(gds);
                //      lad = GDS_Lambert_Lad(gds); //etc.
                        }
                      }
                      else {
                        fprintf(stderr,"netcdf: doesn't support yet grid_template %d\n",grid_template);
                        // fatal_error_i("netcdf: doesn't support grid_template %d",grid_template);
                        save->dim_latlon = 2; //"CF-1.0"; include here also rotated grids when becomes possible
                      }
                      save->grid_template=grid_template;
                    }
                    /* end for grid template */
                    
                    if (save->dim_latlon > 1 && save->grads_compatible)
                      fatal_error_i("netcdf: non-COARDS netCDF is not GrADS v1.9b4 compatible,\n"
                                    "        unsupported grid_template=%d,\n"
                                    "        but possibly could be open by GrADS with valid ctl (data description) file",
                                    grid_template);
                
                    // To avoid problems in future: used occasionally are ndata (main), npnts, nx and ny (extern).
                    // For the eligible grid_templates ndata==npnts==nx*ny; does it needs to check it once more?
                
                    /*
                    What variable, levels we got?
                    f_lev for some templates return 0 (OK) and do not write nothing to level_buf
                    */
                    level_buf[0]=0;
                    
                    //TODO:data, mode
                    //err_code = f_lev(mode, sec, data, ndata, level_buf, local);
                    err_code = f_lev(0, sec, data, ndata, level_buf, NULL);
                //    if (strcmp(level_buf, "reserved")==0) return(0);
                    if (err_code || strlen(level_buf)==0 || strcmp(level_buf, "reserved")==0)
                      fatal_error("netcdf: undefined or unsupported (reserved?) level: %s",level_buf);
                
                	//TODO:mode
                    //ok=getName(sec, mode, NULL, name, desc, unit);
                    ok=getName(sec, 0, NULL, name, desc, unit);
                	
                
                #ifdef DEBUG_NC
                fprintf(stderr,"netcdf: Start processing of %s at %s\n", name, level_buf);
                #endif
                
                    if ( save->nc_nlev ) ndims = 4;  /* suppose 4D shape */
                    else                 ndims = 3;  /* 3D shape */
                
                    ndims = 3;
                
                    /* First check the 'ignore' keyword in the user defined vc (var conversion directives).
                     * Look for the "exact" matching of name and level
                     * in the user defined conversion table, then for 'any' level (*) */
                
                
                    /*
                     * deal with time
                     */
                    err_code = verftime(sec, &year, &month, &day, &hour, &minute, &second);
                    if(err_code) fatal_error("netcdf: can not get verftime","");
                
                    verf_utime = get_unixtime(year, month, day, hour, minute, second, &err_code);
                    if(err_code) fatal_error("netcdf: time [sec] is out of range for this OS","");
                
                    i = reftime(sec, &year, &month, &day, &hour, &minute, &second);
                    ref_utime = get_unixtime(year, month, day, hour, minute, second, &err_code);
                    if (err_code) fatal_error("netcdf: time out of range for presentation in sec on this system","");
                
                    time_ind=-1;
                    if (verf_utime+G2NC_TM_TOLERANCE < save->date0 )
                    { /* time is before date0 */
                      if (save->date0_type > 0 )   return 0; /* skip silently */
                      else if (save->initialized ) fatal_error("netcdf: input time before initial in file %s",save->ncfile);
                    }
                    if (save->time_step_type &&                   /* time_step is user def and */
                       (save->date0_type || save->initialized))   /* date0 is already defined */
                    {
                      time_ind = (int)((verf_utime - save->date0)/save->time_step+G2NC_TM_TOLERANCE);
                      if (fabs(save->date0+save->time_step*time_ind-verf_utime) > G2NC_TM_TOLERANCE)
                      {
                //        if (save->date0_type ) { /*not auto type, +-1*/
                
                           return 0; /* non-integer time index, skip silently */
                //        }
                //        else fatal_error("netcdf: input time do not time-aligned to initial and time step in file %s",save->ncfile);
                      }
                
                      
                      /* Check for too large gap in data */
                      if (( save->initialized && abs(save->time_ind-time_ind) > G2NC_TM_IND_GAP ) ||
                          (!save->initialized && save->date0_type > 0 && time_ind > G2NC_TM_IND_GAP ))
                      {
                        fatal_error("netcdf: too large gap in time index %s",save->ncfile);
                      }
                    }
                    /* end with time deal */
                
                    if ( !save->initialized )
                    {
                      save->nx = nx;
                      save->ny = ny;
                    }
                    
                    /* Do next check for each new field added to the netcdf file */
                    if (nx != save->nx || ny != save->ny )
                    {
                      fprintf(stderr,"netcdf: error processing %s at %s\n", name, level_buf);
                      fprintf(stderr,"netcdf: existing grid (nx*ny) %d x %d, new grid %d x %d\n",
                       save->nx,save->ny,nx,ny);
                      fatal_error("netcdf: grid size must be same for all variables","");
                    }
                    
                    /* work around z-dim:
                     * is this data eligible for treating as 4D?
                     * which level it is etc. Used code from Level.c */
                
                    fixed_surfaces(sec,&level_type1,&level_val1,&undef_val1,&level_type2,&level_val2,&undef_val2);
                
                #ifdef DEBUG_NC
                fprintf(stderr,"netcdf: ndims=%d, levt1=%d, levt2=%d level_val1*scale=%g\n",
                ndims,level_type1,level_type2, level_val1);
                #endif
                
                
                      /* code to make variable names legal */
                      varname_buf[0] = 0;
                      if (isdigit(name[0])) strcpy(varname_buf, "N");  // no names starting with digit
                      strcat(varname_buf, name);
                
                      if ( ndims == 3 )
                      {
                        strcat(varname_buf, "_");
                        strcat(varname_buf, level_buf);
                      }
                      delchars(varname_buf, ' ');
                      rep_chars(varname_buf, '-','_');
                      rep_chars(varname_buf, '.','_');
                      rep_chars(varname_buf, '+','_');
                      /* added more characters wne 5/09 */
                      rep_chars(varname_buf, '=','_');
                      rep_chars(varname_buf, '^','_');
                      rep_chars(varname_buf, '(','_');
                      rep_chars(varname_buf, ')','_');
                      rep_chars(varname_buf, '/','_');
                 
                    //}/* end if (rank == 0) */
                
                      
                    if ( !save->initialized )
                    {
                       // if(rank == 0){      
                            /* first record in new file */
                            if (save->date0_type <= 0)
                            {/* undef or alignment requested (was checked earlier) */
                                time_ind = 0; /* first record */
                                save->date0 = verf_utime;
                            }
                            else
                            {   
                                if (save->time_step_type == 0)
                                {/* step undefined (auto), but defined date0 */
                                    if (fabs(save->date0-verf_utime) > G2NC_TM_TOLERANCE )
                                    { /* first time is not user-defined start time date0 */
                                        time_ind = 1; /* pass first and write data as the second record */
                                        save->time_step = verf_utime - save->date0;
                                    }
                                }
                                else
                                    time_ind = (int)((verf_utime - save->date0)/(save->time_step)+G2NC_TM_TOLERANCE);
                              }
                             
                              //else it was already defined (know date0 and step)
                              save->time_ind = time_ind;
                              save->verf_utime = verf_utime;
                              // define NEW nc file, assume nx and ny of the 1st message hold for all messages...
                              // get some info for grid_mapping
                       // }/* end if rank == 0 */
                
                        /* TODO: send save */
                        /* TODO: send the ncfile */
                        //netcdf_func( nc_create(save->ncfile, NC_NETCDF4, &(save->ncid)) );
                        netcdf_func(nc_create_par(save->ncfile, NC_NETCDF4 | NC_MPIIO, MPI_COMM_WORLD, MPI_INFO_NULL, &(save->ncid)));
                        
                        /* TODO: send the dim_latlon */
                        put_nc_global_attr(save->ncid, save->dim_latlon, save->grid_template);
                
                        define_nc_dims(save->ncid, save->dim_latlon, &(save->time_dim), &(save->x_dim), 
                                    save->nx, &(save->y_dim), save->ny);
                
                        /* send dx, dy, ref_utime, lat, lon */
                        define_nc_dim_var(save->ncid, save->dim_latlon, &(save->time_dim), &(save->time_var), &(save->x_dim), 
                					&(save->y_dim), dx, dy,
                					save->verf_utime, ref_utime, save->time_step, save->time_step_type,
                					save->date0, save->time_ind, lat, lon);
                
                      save->initialized = 1;
                    }
                    else
                    { /* check data in open netcdf file */
                      tm_step = save->time_step;
                      time_ind = get_nc_time_ind(save->ncid, verf_utime,
                                    save->time_var, save->time_dim, &(save->time_ind),
                                    &(save->verf_utime), &tm_step,
                                    save->time_step_type, save->date0 );
                
                      if(time_ind < 0) fatal_error("netcdf: unresolved timing problem","");
                      if (save->grads_compatible)
                      {
                        if( tm_step > G2NC_TM_TOLERANCE )
                        {
                          if( save->time_step > G2NC_TM_TOLERANCE )
                          {
                            if (fabs(save->time_step-tm_step) > G2NC_TM_TOLERANCE)
                            {
                              fatal_error("netcdf: variable time stepping is not GrADS v1.9b4 compatible","");
                            }
                          }
                          else save->time_step = tm_step;
                        }
                      }
                
                      i = update_nc_ref_time(save->ncid, verf_utime, ref_utime,
                                           save->time_var, save->time_step_type, tm_step);
                   /*
                    * Check does existing lats lons in netcdf file are same
                    * as this of new field?
                    */
                      i = check_nc_latlon(save->ncid, save->y_dim, save->x_dim, save->dim_latlon);
                    }
                
                
                    //netcdf is open or created and defined, data do not rejected, go ahead...
                
                    /* Set chunking, shuffle, and deflate. */
                    shuffle = 1;
                    deflate = 1;
                    deflate_level = 1;
                
                    dimids[0] = save->time_dim;
                    chunks[0] = 1;
                
                 
                      dimids[1] = save->y_dim;
                      dimids[2] = save->x_dim;
                      /*chunks[2] = ny;
                      chunks[3] = nx;*/
                      chunks[1] = save->ny;
                      chunks[2] = save->nx;
                
                    ok = nc_inq_varid (save->ncid, varname_buf, &varid);
                    var_pack = G2NC_PACK_UNDEF;
                    scale_factor = 0.;
                    if (ok != NC_NOERR)
                    {
                      varid = -1; /* new variable, not in file yet */
                
                        if (save->nc_pack)
                      {
                        var_pack = save->nc_pack;
                        scale_factor = save->nc_pack_scale;
                        add_offset = save->nc_pack_offset;
                        valid_min = save->nc_valid_min;
                        valid_max = save->nc_valid_max;
                      }
                    }
                    else
                    {  /* same variable found in open netcdf file */
                      netcdf_func( nc_inq_vartype (save->ncid, varid, &var_type) );
                      /* Check existing variable definition in netcdf with requested */
                
                        if (nc_pack) var_pack = save->nc_pack;
                //      if ( var_type == NC_FLOAT ) var_type = 0;  //Jan 2007, vsm
                      if ( var_pack != G2NC_PACK_UNDEF && var_type != g2nc_pack2type(var_pack) )
                      {
                        fatal_error("netcdf: variable %s exists with other packing size",varname_buf);
                      }
                      netcdf_func( nc_inq_varndims (save->ncid, varid, &i) );
                      if ( i != ndims )
                      {
                        fprintf(stderr,"netcdf: ndims=%d in file, new ndims=%d\n",i,ndims);
                        fatal_error("netcdf: variable %s exists having different dimension",varname_buf);
                      }
                      test_dimids[0]=test_dimids[1]=test_dimids[2]=test_dimids[3]=-1;
                      netcdf_func( nc_inq_vardimid (save->ncid, varid, test_dimids) );
                      for ( i = 0; i < ndims; i++ )
                      {
                        if (test_dimids[i] != dimids[i])
                        {
                          fatal_error("netcdf: variable %s exists with different dimension shape",varname_buf);
                        }
                      }
                      /* packing information is taken from the open netcdf file */
                      if ( var_type == NC_BYTE || var_type == NC_SHORT )
                      {
                        ok = nc_get_att_float(save->ncid, varid, "scale_factor", &scale_factor);
                        if (ok == NC_NOERR)
                        {
                          ok = nc_get_att_float(save->ncid, varid, "add_offset", &add_offset);
                          if (ok == NC_NOERR) var_pack = g2nc_type2pack(var_type);
                        }
                        if (var_pack != g2nc_type2pack(var_type))
                          fatal_error("netcdf: wrong or absent packing info for SHORT or BYTE var=%s,\n"
                                      "        invalid netCDF file",varname_buf);
                      }
                      else if (var_type == NC_FLOAT)
                      {
                        // next attributes COULD present
                        ok = nc_get_att_float(save->ncid, varid, "valid_min", &valid_min);
                        if (ok == NC_NOERR)
                        {
                          ok = nc_get_att_float(save->ncid, varid, "valid_max", &valid_max);
                          if (ok == NC_NOERR) var_pack = G2NC_PACK_FLOAT; // will check the valid_range
                        }
                      }
                    }
                    if (var_pack == G2NC_PACK_BYTE && save->grads_compatible)
                      fatal_error("netcdf: byte packing is not GrADS v1.9b4 compatible, var=%s,\n"
                                  "        but such netCDF file still could be open by GrADS\n"
                                  "        with valid ctl (data description) file", varname_buf);
                
                //    if ( var_pack ) {
                      // Find max-min for checking of packing parameters
                      // vsm: From Jan 2007 version values that do not fit to provided valid_range
                      // are replaced by UNDEFINED
                    if ( scale_factor == 0. && (var_pack == G2NC_PACK_BYTE || var_pack == G2NC_PACK_SHORT) )
                    {
                      max = min = ok = 0;
                      //TODO:data
                      for (j = 0; j < ndata; j++)
                      {
                        if (!UNDEFINED_VAL(data[j]))
                        {
                          if (ok)
                          {
                            max = max > data[j] ? max : data[j];
                            min = min < data[j] ? min : data[j];
                          }
                          else
                          {
                            ok = 1;
                            max = min = data[j];
                          }
                        }
                      }
                    }
                    if (varid < 0)
                    { /* new variable, not in file yet */
                
                #ifdef DEBUG_NC
                fprintf(stderr,"netcdf: add new var=%s to output file %s\n",varname_buf,save->ncfile);
                #endif
                      netcdf_func( nc_redef(save->ncid) );
                
                      /* try to apply provided packing to all new variables */
                      if ( var_pack == G2NC_PACK_BYTE )
                      {
                        netcdf_func( nc_def_var (save->ncid, varname_buf, NC_BYTE, ndims, dimids, &varid) );
                        netcdf_func( nc_put_att_schar(save->ncid, varid, "_FillValue", NC_BYTE, 1, &bfill_value) );
                      }
                      else if ( var_pack == G2NC_PACK_SHORT )
                      {
                        netcdf_func( nc_def_var (save->ncid, varname_buf, NC_SHORT, ndims, dimids, &varid) );
                        netcdf_func( nc_put_att_short(save->ncid, varid, "_FillValue", NC_SHORT, 1, &sfill_value) );
                      }
                      else
                      { /* default case of unpacked float variables */
                        netcdf_func( nc_def_var (save->ncid, varname_buf, NC_FLOAT, ndims, dimids, &varid) );
                        netcdf_func( nc_put_att_float(save->ncid, varid, "_FillValue", NC_FLOAT, 1, &ffill_value) );
                      }
                //vsm: which 'short name' is correct for the NetCDF COARDS compliant file? 'name' or 'varname_buf'?
                //      netcdf_func( nc_put_att_text(save->ncid, varid, "short_name", strlen(name), name) );
                      netcdf_func( nc_put_att_text(save->ncid, varid, "short_name", strlen(varname_buf), varname_buf) );
                      netcdf_func( nc_put_att_text(save->ncid, varid, "long_name", strlen(desc), desc) );
                /*
                      lev_types[0]=level_type1;
                      lev_types[1]=level_type2;
                      netcdf_func( nc_put_att_int(save->ncid, varid, "grib2_lt", NC_INT, 2, lev_types) );
                */
                
                      netcdf_func( nc_put_att_text(save->ncid, varid, "level", strlen(level_buf), level_buf) );
                 
                      fix_units(unit,sizeof(unit));
                      netcdf_func( nc_put_att_text(save->ncid, varid, "units", strlen(unit), unit) );
                
                      if (save->dim_latlon > 1 )
                      {
                        str="longitude latitude";
                        netcdf_func( nc_put_att_text(save->ncid, varid, "coordinates", strlen(str), str) );
                      }
                      if ( var_pack == G2NC_PACK_BYTE || var_pack == G2NC_PACK_SHORT )
                      {
                        if ( scale_factor == 0.)
                        {
                          /* Auto-packing, center near 0 as signed char or short are used.
                             Try secure scaling for all next input fields: extend the range on +-10%... */
                          range = (max-min)*1.2;
                          add_offset = (float) (min+max)*0.5;
                          if ( var_pack == G2NC_PACK_BYTE )
                            scale_factor = (float) (range/(bfill_value - 2))*0.5;
                          else if ( var_pack == G2NC_PACK_SHORT )
                            scale_factor = (float) (range/(sfill_value - 2))*0.5;
                #ifdef DEBUG_NC
                fprintf(stderr,"netcdf: auto-packing, min=%lf, max=%lf, offset=%f, scale=%f, var=%s\n",
                min, max, add_offset, scale_factor, varname_buf);
                #endif
                        }
                        netcdf_func( nc_put_att_float(save->ncid, varid, "scale_factor", NC_FLOAT, 1, &scale_factor) );
                        netcdf_func( nc_put_att_float(save->ncid, varid, "add_offset", NC_FLOAT, 1, &add_offset) );
                      }
                      else if ( var_pack == G2NC_PACK_FLOAT )
                      {
                        netcdf_func( nc_put_att_float(save->ncid, varid, "valid_min", NC_FLOAT, 1, &valid_min) );
                        netcdf_func( nc_put_att_float(save->ncid, varid, "valid_max", NC_FLOAT, 1, &valid_max) );
                      }
                      // TODO: add this part will cause the nc file lose the variables
                	  //if (save->nc4)
                      //{
                        //netcdf_func( nc_def_var_chunking(save->ncid, varid, NC_CHUNKED, chunks) );
                        //netcdf_func( nc_def_var_deflate( save->ncid, varid, shuffle, deflate, deflate_level) );
                //        netcdf_func( nc_var_set_cache(save->ncid, varid, nx*ny);
                //        netcdf_func( nc_def_var_endian(save->ncid, varid, endian) );
                //        NC_ENDIAN_NATIVE,NC_ENDIAN_LITTLE,NC_ENDIAN_BIG
                      //}
                      netcdf_func( nc_enddef(save->ncid) );
                    }
                
                    // specify where to write new data portion - record size and location in 4D or 3D
                    start[0] = time_ind; count[0] = 1;
                    /*if ( ndims == 4 )
                    {
                      start[1] = level_ind; count[1] = 1;
                      start[2] = 0;         count[2] = ny;
                      start[3] = 0;         count[3] = nx;
                    }
                    else*/
                    {
                      start[1] = 0;  count[1] = ny;
                      start[2] = 0;  count[2] = nx;
                    }
                    dimlens[0] = save->ny;
                    dimlens[1] = save->nx;
                
                    set_hyperslab(&(count[1]), &(start[1]), dimlens, ndims-1);
                    nvar = count[1] * count[2];
                    offset = start[1] * save->nx;
                      
                    // pack data and write one time step
                    if ( var_pack == G2NC_PACK_BYTE || var_pack == G2NC_PACK_SHORT )
                    { /* get packing attributes from file */
                      netcdf_func( nc_get_att_float(save->ncid, varid, "scale_factor", &scale_factor) );
                      netcdf_func( nc_get_att_float(save->ncid, varid, "add_offset", &add_offset) );
                      if ( fabs(scale_factor) < 1e-20) fatal_error("netcdf: zero packing scale factor %s",varname_buf);
                
                      /*set_hyperslab(&(count[1]), &(start[1]), dimlens, ndims-1);
                      nvar = count[1] * count[2];
                      offset = start[1] * save->nx;*/
                      
                      if ( var_pack == G2NC_PACK_BYTE )
                      {
                        valid_min = -(bfill_value-2)*scale_factor + add_offset;
                        valid_max =  (bfill_value-2)*scale_factor + add_offset;
                        
                        bdata = (signed char*) malloc(nvar*sizeof(signed char));
                        if (!bdata) 
                            fatal_error("netcdf: %s","error doing malloc of bdata");
                        
                        for (j = 0; j < nvar; j++)
                        {
                          bdata[j] = (UNDEFINED_VAL(data[j+offset]) || data[j+offset] < valid_min || data[j+offset] > valid_max ) ?
                             bfill_value : (data[j+offset] - add_offset) / scale_factor;
                        }
                        netcdf_func( nc_put_vara_schar(save->ncid, varid, start, count, bdata) );
                        free(bdata);
                      }
                      else if (var_pack == G2NC_PACK_SHORT )
                      {
                        valid_min = -(sfill_value-2)*scale_factor + add_offset;
                        valid_max =  (sfill_value-2)*scale_factor + add_offset;
                        
                        sdata = (short*) malloc(nvar*sizeof(short));
                        if (!sdata) 
                            fatal_error("netcdf: %s","error doing malloc of sdata");
                            
                        for (j = 0; j < nvar; j++)
                        {
                          sdata[j] = (UNDEFINED_VAL(data[j+offset]) || data[j+offset] < valid_min || data[j+offset] > valid_max ) ?
                            sfill_value : (data[j+offset] - add_offset) / scale_factor;
                        }
                        netcdf_func( nc_put_vara_short(save->ncid, varid, start, count, sdata) );
                        free(sdata);
                      }
                    }
                    else
                    { /* not packed float values */
                      if (var_pack == G2NC_PACK_FLOAT)
                      { // check valid_range
                        fdata = (float*) malloc(nvar*sizeof(float));
                        if (!fdata) fatal_error("netcdf: %s","error doing malloc of fdata");
                        for (j = 0; j < nvar; j++)
                        {
                          fdata[j] = (UNDEFINED_VAL(data[j+offset]) || data[j+offset] < valid_min || data[j+offset] > valid_max ) ?
                            ffill_value : data[j+offset];
                        }
                        netcdf_func( nc_put_vara_float(save->ncid, varid, start, count, fdata) );
                        free(fdata);
                      }
                      else
                      {
                        netcdf_func( nc_put_vara_float(save->ncid, varid, start, count, &(data[offset])) );
                      }
                    }
                #ifdef DEBUG_NC
                fprintf(stderr,"netcdf: added var=%s to output file %s\n",varname_buf,save->ncfile);
                fprintf(stderr,"netcdf: varid=%d, time_ind=%d, lev_ind=%d, pack=%d\n",
                varid,time_ind,level_ind,var_pack);
                #endif
                    save->nid++;
                  
                  return 0;
                }
                
                /******************************************************************************************/
                static int check_nc_latlon( int ncid, int y_dim, int x_dim, int dim_latlon )
          16 -> {
                 /*
                  * Check does existing lat and lot definition in open netcdf file
                  * is consistent  with the new coming data?
                  *
                  * Sergey Varlamov
                  */
                  int i, nco_err;
                  size_t nyy, nxx;
                  double * test_ll, dd;
                  const double test_d=1e-6;
                  size_t start[2], count[2];
                  int lat_var, lon_var;
                
                #ifdef DEBUG_NC
                fprintf(stderr,"netcdf: step in check_nc_latlon\n");
                #endif
                
                  nco_err=0;
                  /* locate dimensions and corresponding variables with fixed names */
                
                  if (dim_latlon == 1) i = nx > ny ? nx:ny;
                  else i = nx*ny;
                
                  test_ll = (double*) malloc(i*sizeof(double));
                  if (!test_ll) fatal_error("netcdf:check_nc_latlon: %s","error doing malloc of test_ll");
                
                  // expect lat and lon dimension variables
                  netcdf_func( nc_inq_dimlen (ncid, x_dim, &nxx) );
                  netcdf_func( nc_inq_dimlen (ncid, y_dim, &nyy) );
                  netcdf_func( nc_inq_varid (ncid, "longitude", &lon_var) );
                  netcdf_func( nc_inq_varid (ncid, "latitude", &lat_var) );
                
                #ifdef DEBUG_NC
                fprintf(stderr,"netcdf:check_nc_latlon: x,lon,nx,nxx,y,lat,ny,nyy=%d %d %d %lu %d %d %d %lu\n",
                x_dim,lon_var,nx,(unsigned long)nxx,y_dim,lat_var,ny,(unsigned long)nyy);
                #endif
                
                  if (nyy != ny || nxx != nx){
                    nco_err+=2;
                  }
                  else if (dim_latlon == 1)
                  {
                      start[0] = 0; count[0] = nx;
                      netcdf_func( nc_get_vara_double(ncid, lon_var, start, count, test_ll) );
                      if (nx > 1) dd = 0.01*fabs(lon[1]-lon[0]);
                      else        dd = test_d*fabs(lon[0]);
                      for (i=0; i<nx ; i++)
                      {
                        if(fabs(lon[i]-test_ll[i]) > dd )
                        {
                          fprintf(stderr,"different grid (longitude) in existing netcdf!\n");
                          nco_err+=4;
                          break;
                        }
                      }
                #ifdef DEBUG_NC
                fprintf(stderr,"netcdf:check_nc_latlon: longitude=%lf %lf\n",
                test_ll[0],test_ll[nx-1]);
                #endif
                      start[0] = 0; count[0] = ny;
                      netcdf_func( nc_get_vara_double(ncid, lat_var, start, count, test_ll) );
                      /* use 1% of first step value as criteria */
                      if (ny > 1) dd = 0.01*fabs(lat[nx]-lat[0]); /* 'nx' here is not error, wgrib2 specifics! */
                      else        dd = test_d*fabs(lat[0]);      /* assumed tolerance */
                      for (i=0; i<ny ; i++)
                      {
                        if(fabs(lat[i*nx]-test_ll[i]) > dd )
                        {
                          fprintf(stderr,"different grid (latitude) in existing netcdf!\n");
                          nco_err+=8;
                          break;
                        }
                      }
                #ifdef DEBUG_NC
                fprintf(stderr,"netcdf:check_nc_latlon: latitude=%lf %lf\n",
                test_ll[0],test_ll[ny-1]);
                #endif
                  }
                  else
                  {
                      start[0] = 0; count[0] = ny;
                      start[1] = 0; count[1] = nx;
                      netcdf_func( nc_get_vara_double(ncid, lat_var, start, count, test_ll) );
                      /* use 1% of first step value as criteria */
                      if (ny > 1) dd = 0.01*fabs(lat[nx]-lat[0]); /* 'nx' here is not error, wgrib2 specifics! */
                      else        dd = test_d*fabs(lat[0]);      /* assumed tolerance */
                      for (i=0; i<nx*ny ; i++)
                      {
                        if(fabs(lat[i]-test_ll[i]) > dd )
                        {
                          fprintf(stderr,"different grid (latitude) in existing netcdf!\n");
                          nco_err+=16;
                          break;
                        }
                      }
                #ifdef DEBUG_NC
                fprintf(stderr,"netcdf:check_nc_latlon: latitude=%lf %lf\n",
                test_ll[0],test_ll[ny-1]);
                #endif
                      start[0] = 0; count[0] = ny;
                      start[1] = 0; count[1] = nx;
                      netcdf_func( nc_get_vara_double(ncid, lon_var, start, count, test_ll) );
                      if (nx > 1) dd = 0.01*fabs(lon[1]-lon[0]);
                      else        dd = test_d*fabs(lon[0]);
                      for (i=0; i<nx*ny ; i++)
                      {
                        if(fabs(lon[i]-test_ll[i]) > dd )
                        {
                          fprintf(stderr,"different grid (longitude) in existing netcdf!\n");
                          nco_err+=32;
                          break;
                        }
                      }
                #ifdef DEBUG_NC
                fprintf(stderr,"netcdf:check_nc_latlon: longitude=%lf %lf\n",
                test_ll[0],test_ll[nx-1]);
                #endif
                  }
                  free(test_ll);
                
                  if (nco_err)
                  {
                    fprintf(stderr,"*** Error appending data to existing netcdf file ***\n");
                    fprintf(stderr,"*** Existing vise input dimensions [y,x]: [%lu, %lu]:[%d, %d] ***\n",
                    (unsigned long)nyy,(unsigned long)nxx,ny,nx);
                    fatal_error_i("netcdf:check_nc_latlon: dimension error: %d",nco_err);
                  }
                  return nco_err;
                }
                
                /******************************************************************************************/
                static int update_nc_ref_time(int ncid, double verf_utime, double ref_utime,
                                       int time_var, int time_step_type, double time_step)
          16 -> {
                /*
                  Update time attributes if necessary and possible;
                  nc_ref_time is reference time value,
                  nc_ref_time_type is the reference time type:
                     0 - undefined
                     1 - analyses, all for the same reference date, could be succeded by forecasts
                     2 - analyses for different reference date/time (time serie)
                     3 - forecasts from the same reference date/time
                     For the type 0 or 2 nc_ref_time keeps first input field reference date/time,
                     could be misleading if not date0 field is coming first...
                  Sergey Varlamov
                */
                  int ok, update_rt, update_ts;
                  double nc_ref_time, nc_time_step;
                  int nc_ref_time_type;
                  char * str;
                  char ref_date[50];
                
                #ifdef DEBUG_NC
                fprintf(stderr,"netcdf: step in update_nc_ref_time\n");
                #endif
                  str = "";
                  update_rt = 1;
                  nc_ref_time=0;
                  ok = nc_get_att_double(ncid, time_var, "reference_time", &nc_ref_time);
                  if (ok != NC_NOERR) update_rt = 0; /* attribute do not exists, could be with update of file from older wgrib2 version */
                
                  nc_ref_time_type=0;
                  ok = nc_get_att_int(ncid, time_var, "reference_time_type", &nc_ref_time_type);
                  if (ok != NC_NOERR || nc_ref_time_type <= 0) update_rt = 0;
                
                  update_ts = 0;
                  if (time_step_type == 0)
                  { /* try to update only for "auto" case, skip if step is user-defined */
                    nc_time_step=-1;  /* variable step, do not update */
                    ok = nc_get_att_double(ncid, time_var, "time_step", &nc_time_step);
                    if (ok == NC_NOERR && nc_time_step > -G2NC_TM_TOLERANCE) update_ts = 1;
                  }
                #ifdef DEBUG_NC
                fprintf(stderr,
                "netcdf:update_nc_ref_time: ref_time(f,c)=%.1lf %.1lf ref_time_type=%d time_step(f,c)=%.1lf %.1lf\n",
                nc_ref_time, ref_utime,nc_ref_time_type,nc_time_step,time_step);
                fprintf(stderr,"netcdf:update_nc_ref_time: update_rt=%d update_ts=%d\n",update_rt, update_ts);
                #endif
                  if ( !update_rt && !update_ts ) return 1;
                
                  if (update_rt)
                  {/* exists, value is defined - check it against new and,
                      if it is not consistent - modify type */
                    update_rt = 0;
                    /* string for type 0 */
                    str = "kind of product unclear, reference date is variable, min found reference date is given";
                    switch (nc_ref_time_type)
                    {
                    case 1: /* 1 - analyses, all for the same date, could be succeded by forecasts */
                      if ( fabs(nc_ref_time - ref_utime) > G2NC_TM_TOLERANCE &&
                           fabs(ref_utime - verf_utime) < G2NC_TM_TOLERANCE )
                      { /* change to analyses for different ref_time */
                        nc_ref_time_type = 2;
                        str = "analyses, reference date is variable, min found reference date is given";
                        update_rt = 1;
                      }
                      else if (fabs(nc_ref_time - ref_utime) < G2NC_TM_TOLERANCE &&
                               fabs(ref_utime - verf_utime) > G2NC_TM_TOLERANCE)
                      { /* possibly it is first forecast after analyses */
                        nc_ref_time_type = 3;
                        str = "forecasts or accumulated (including analyses), reference date is fixed"; /*including analyses*/
                        update_rt = 1;
                      }
                      else if (fabs(nc_ref_time - ref_utime) > G2NC_TM_TOLERANCE &&
                               fabs(ref_utime - verf_utime) > G2NC_TM_TOLERANCE)
                      { /* forecast for different reference time */
                        nc_ref_time_type = 0;
                        update_rt = 1;
                      }
                      break;
                    case 2: /*2 - analyses, but for different reference date/time */
                      if (fabs(ref_utime - verf_utime) > G2NC_TM_TOLERANCE)
                      { /* mix, change type to undefined */
                        nc_ref_time_type = 0;
                        update_rt = 1;
                      }
                      break;
                    case 3: /* 3 - forecasts from the same reference date/time */
                      if (fabs(nc_ref_time - ref_utime) > G2NC_TM_TOLERANCE)
                      { /* mix, change type to undefined */
                        nc_ref_time_type = 0;
                        update_rt = 1;
                      }
                      break;
                    }
                  }
                  if (update_ts )
                  {
                    update_ts = 0;
                    if (fabs(nc_time_step) < G2NC_TM_TOLERANCE && time_step > G2NC_TM_TOLERANCE)
                    { /* attribute value is uninitialized (0), get valid value */
                      nc_time_step = time_step;
                      update_ts = 1;
                    }
                    else if (nc_time_step > G2NC_TM_TOLERANCE && time_step > G2NC_TM_TOLERANCE &&
                             fabs(nc_time_step - time_step) > G2NC_TM_TOLERANCE)
                    {
                      nc_time_step = -1; /* variable time step, mark it as undefined */
                      update_ts = 1;
                    }
                  }
                #ifdef DEBUG_NC
                fprintf(stderr,"netcdf:update_nc_ref_time: update_rt=%d update_ts=%d\n",update_rt, update_ts);
                #endif
                  if (update_rt || update_ts)
                  {
                    netcdf_func( nc_redef(ncid) );
                    if (update_rt)
                    {
                      if (ref_utime < nc_ref_time) /* try to keep in file latest data reference time */
                      {
                        netcdf_func( nc_put_att_double(ncid, time_var, "reference_time", NC_DOUBLE, 1, &ref_utime) );
                        get_unixdate(ref_utime, ref_date);
                        netcdf_func( nc_put_att_text(ncid, time_var, "reference_date", strlen(ref_date), ref_date) );
                      }
                      netcdf_func( nc_put_att_int(ncid, time_var, "reference_time_type", NC_INT, 1, &nc_ref_time_type) );
                      netcdf_func( nc_put_att_text(ncid, time_var, "reference_time_description", strlen(str), str) );
                    }
                    if (update_ts)
                    {
                      netcdf_func( nc_put_att_double(ncid, time_var, "time_step", NC_DOUBLE, 1, &nc_time_step) );
                    }
                    netcdf_func( nc_enddef(ncid) );
                  }
                  return 0;
                }
                
                /******************************************************************************************/
                static int get_nc_time_ind(int ncid, double verf_utime, int time_var, int time_dim,
                                    int * time_ind, double * last_verf_time,
                                    double * time_step, int time_step_type, double date0 )
          16 -> {
                 /*
                  * Compare provided verf_utime with this in open netcdf file and return
                  * corresponding index for time dimension. If new value exceeds existing -
                  * extend UNLIMITED time dimension writing new entry point(s).
                  * Negative value is for errors.
                  * Sergey Varlamov
                  */
                  int t_ind, i, j;
                  double *wtime, ttime;
                  size_t index[1], start[1], count[1], ntt;
                
                #ifdef DEBUG_NC
                fprintf(stderr,"netcdf: step in get_nc_time_ind\n");
                #endif
                  if (*time_ind < 0)
                  { /* time dim is undefined yet */
                    *last_verf_time = verf_utime-1;
                    *time_ind = -1;
                  }
                  if(fabs(verf_utime - (*last_verf_time)) < G2NC_TM_TOLERANCE)
                  {
                    return (*time_ind); /* same as before, already defined */
                  }
                  /*
                  Get the number of records written so far
                  */
                  netcdf_func( nc_inq_dimlen (ncid, time_dim, &ntt) );
                  if (time_step_type)
                  { /* user-defined, fixed, non-zero */
                    i = (int)((verf_utime - date0)/(*time_step) + G2NC_TM_TOLERANCE);
                #ifdef DEBUG_NC
                fprintf(stderr,"netcdf:get_nc_time_ind: fixed time step, time_ind(r,i)=%.2lf %d ntt=%lu\n",
                (verf_utime - date0)/(*time_step), i, ntt);
                #endif
                    if (fabs(date0+(*time_step)*i-verf_utime) > G2NC_TM_TOLERANCE)
                    {
                      return (-1); /* non-integer index */
                    }
                    /*
                    Extend file if needed
                    */
                    if (i > ntt-1)
                    { /* generate new time values */
                      for (j=ntt-1; j <= i; j++)
                      {
                        index[0] = j;
                        ttime = date0 + (*time_step)*j;
                        netcdf_func( nc_put_var1_double(ncid, time_var, index, &ttime) );
                      }
                    }
                    *time_ind = i;
                    *last_verf_time = verf_utime;
                    return i;
                  }
                  /* auto time stepping; could be irregular time-spaced data */
                  index[0] = ntt-1;
                  netcdf_func( nc_get_var1_double(ncid, time_var, index, &ttime) );
                
                  if(verf_utime > ttime + G2NC_TM_TOLERANCE)
                  {/* write new time entry point */
                    t_ind = ntt;
                    *time_ind = ntt;
                    *time_step = verf_utime - ttime;
                    *last_verf_time = verf_utime;
                    index[0] = ntt;
                    netcdf_func( nc_put_var1_double(ncid, time_var, index, last_verf_time) );
                  }
                  else
                  { /* verf_utime <= ttime */
                    t_ind = -1;
                    wtime = (double *) malloc(ntt*sizeof(double));
                    if (!wtime) fatal_error("netcdf:get_nc_time_ind: %s",
                        "error doing malloc of wtime");
                
                    start[0] = 0; count[0] = ntt;
                    netcdf_func( nc_get_vara_double(ncid, time_var, start, count, wtime) );
                
                    for (i = ntt-1; i >= 0; i--)
                    {
                      if (fabs(wtime[i]-verf_utime) < G2NC_TM_TOLERANCE)
                      {
                        t_ind = i;
                        break;
                      }
                    }
                    free(wtime);
                    if (t_ind >= 0)
                    {
                      *time_ind = t_ind;
                      *last_verf_time = verf_utime;
                    }
                  }
                #ifdef DEBUG_NC
                fprintf(stderr,"netcdf:get_nc_time_ind: variable time step, time_ind=%d ntt=%lu\n",
                t_ind, ntt);
                #endif
                
                  return t_ind;
                }
                
                #endif


Top 10 Lines:

     Line      Count

      113         17
      725         16
      859         16
      997         16

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

       65   Total number of line executions
    10.83   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/geo.c:
                /******************************************************************************************
                 Copyright (C) 2005-2006  Karl Pfeiffer
                 This file is part of wgrib2 and is distributed under terms of the GNU General Public License 
                 For details see, Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, 
                    Boston, MA  02110-1301  USA
                  mods made Wesley Ebisuzaki
                  4/2006 Bug found by Naoya Suda (lambert2ll) Thanks
                  10/2009 Bug found by Jerry Stueve (mercator) Thanks
                */
                
                /*
                 *  kdp 2005-08-22
                 *
                 *  Routines supporting the -geo option
                 *
                 * 1/2007 some cleanup M. Schwarb
                 * 1/2008 lat and lon changed from float to double, polar can use LatD != 60 SV
                 * 2/2008 vsm added LatD for lambert conformal
                 * 2/2008 lambertll uses earth_radius as specified in code table 3.2
                 * 2/2008 vsm fix lambert conformal
                 * 2/2009 wne fix mercator
                 * 6/2010 wne sec3_grid creates new sec3 and lat-lon values,
                 *	changed (projection)2ll so that it reads gdt, not external nx, ny, npnts
                 * need to check if all scan modes are handled
                 */
                #include <stdio.h>
                #include <stdlib.h>
                #include <math.h>
                
                #include "grb2.h"
                #include "wgrib2.h"
                #include "fnlist.h"
                
                /* M_PI, M_PI_2, M_PI_4, and M_SQRT2 are not ANSI C but are commonly defined */
                /* values from GNU C library version of math.h copyright Free Software Foundation, Inc. */
                
                #ifndef M_PI
                #define M_PI           3.14159265358979323846  /* pi */
                #endif
                #ifndef M_PI_2
                #define M_PI_2         1.57079632679489661923  /* pi/2 */
                #endif
                #ifndef M_PI_4
                #define M_PI_4         0.78539816339744830962  /* pi/4 */
                #endif
                #ifndef M_SQRT2
                #define M_SQRT2        1.41421356237309504880  /* sqrt(2) */
                #endif
                
                extern double *lat, *lon;
                extern int  nx, ny;
                extern int *variable_dim;
                extern enum output_order_type output_order;
                
                // static double toradians(double x) { return x * (M_PI/180.0); }
     1478594 -> static double todegrees(double x) { return x * (180.0/M_PI); }
                
       ##### -> int regular2ll(unsigned char **sec, double **lat, double **lon) {
                 
                    int basic_ang, sub_ang;
                    double units, dlat, dlon, lat1, lat2, lon1, lon2;
                    double e, w, n, s, dx, dy;
                 
                    int i, j;
                    unsigned int k;
                    double *llat, *llon;
                    unsigned char *gds;
                    int nnx, nny, nres, nscan;
                    unsigned int nnpnts;
                
                    get_nxny(sec, &nnx, &nny, &nnpnts, &nres, &nscan);
                    gds = sec[3];
                
                    if (nny == -1) {
                        fprintf(stderr,"Sorry code does not handle variable ny yet\n");
                        return 0;
                    }
                
                    if ((*lat = (double *) malloc(nnpnts * sizeof(double))) == NULL) {
                        fatal_error("regular2ll memory allocation failed","");
                    }
                    if ((*lon = (double *) malloc(nnpnts * sizeof(double))) == NULL) {
                        fatal_error("regular2ll memory allocation failed","");
                    }
                
                    /* now figure out the grid coordinates mucho silly grib specification */
                
                    basic_ang = GDS_LatLon_basic_ang(gds);
                    sub_ang = GDS_LatLon_sub_ang(gds);
                    if (basic_ang != 0) {
                        units = (double) basic_ang / (double) sub_ang;
                    }
                    else {
                        units = 0.000001;
                    }
                
                    dlat = GDS_LatLon_dlat(gds) * units;
                    dlon = GDS_LatLon_dlon(gds) * units;
                    lat1 = GDS_LatLon_lat1(gds) * units;
                    lat2 = GDS_LatLon_lat2(gds) * units;
                    lon1 = GDS_LatLon_lon1(gds) * units;
                    lon2 = GDS_LatLon_lon2(gds) * units;
                
                    if (lon1 < 0.0 || lon2 < 0.0) fatal_error("BAD grid definition lon < zero","");
                    if (lon1 > 360.0 || lon2 > 360.0) fatal_error("BAD grid definition lon >= 360","");
                    if (lat1 < -90.0 || lat2 < -90.0 || lat1 > 90.0 || lat2 > 90.0) fatal_error("BAD grid definition lat","");
                
                    /* find S latitude and dy */
                    if (GDS_Scan_y(nscan)) {
                        s = lat1;
                        n = lat2;
                    }
                    else {
                        s = lat2;
                        n = lat1;
                    }
                    if (s > n) fatal_error("lat-lon grid: lat1 and lat2 inconsistent with scan order","");
                
                    dy = (n - s) / (nny - 1);
                    if (nres & 64) { /* lat increment is valid */
                        if (fabs(dy - dlat) > 0.001) fatal_error("lat-lon grid: dlat is inconsistent","");
                    }
                
                    /* find W latitude and dx */
                
                    if ( GDS_Scan_row_rev(nscan) && (nny % 2 == 0) && ((nres & 32) == 0) ) {
                         fatal_error("grib GDS ambiguity","");
                    }
                
                    if (GDS_Scan_x(nscan)) {
                        w = lon1;
                        e = lon2;
                        if (GDS_Scan_row_rev(nscan) && ((nres & 32) == 0)) {
                            e = lon1 + (nnx-1) * dlon;
                        }
                    } else {
                        w = lon2;
                        e = lon1;
                        if (GDS_Scan_row_rev(nscan) && ((nres & 32) == 0)) {
                            w = lon1 - (nnx-1) * dlon;
                        }
                    }
                
                    if (e <= w) e += 360.0;
                    if (e-w > 360.0) e -= 360.0;
                    if (w < 0) {
                        w += 360.0;
                        e += 360.0;
                    }
                
                    /* lat-lon should be in a WE:SN order */
                
                    llat = *lat;
                    if (nnx >= 0) {        /* regular grid */
                        for (j = 0; j < nny; j++) {
                            for (i = 0; i < nnx; i++) {
                                *llat++ = s + j*dy;
                            }
                        }
                    }
                    else {                /* quasi-regular grid */
                        for (j = 0; j < nny; j++) {
                            for (i = 0; i < variable_dim[j];  i++) {
                                *llat++ = s + j*dy;
                            }
                        }
                    }
                
                    llon = *lon;
                    if (nnx >= 0) {                /* regular grid */
                        dx = (e-w) / (nnx-1);
                        if (nres & 128) { /* lon increment is valid */
                            if (fabs(dx - dlon) > 0.001) fatal_error("lat-lon grid: dlon is inconsistent","");
                        }
                        for (i = 0; i < nnx; i++) {
                            llon[i] = w + i*dx >= 360.0 ? w + i*dx - 360.0 : w + i*dx;
                        }
                        for (k = nnx; k < nnpnts; k++) {
                            llon[k] = llon[k-nnx];
                        }
                    }
                    else {                        /* quasi-regular grid */
                        for (j = 0; j < nny; j++) {
                            dx = (e-w) / (variable_dim[j]-1);
                            for (i = 0; i < variable_dim[j]; i++) {
                                *llon++ = w + i*dx >= 360.0 ? w + i*dx - 360.0: w + i*dx;
                            }
                        }
                    }
                    return 0;
                } /* end regular2ll() */ 
                
                /* adapted from iplib */
                
       ##### -> int polar2ll(unsigned char **sec, double **llat, double **llon) {
                    
                    double *lat, *lon;
                    unsigned char *gds;
                
                    double dx, dy, orient, de, de2, dr, tmp, xp, yp, h, lat1, lon1, dr2;
                    double di, dj, LatD;
                    int ix, iy;
                    int nnx, nny, nres, nscan;
                    unsigned int nnpnts;
                
                    get_nxny(sec, &nnx, &nny, &nnpnts, &nres, &nscan);
                
                    gds = sec[3];
                
                    if (nnx == -1 || nny == -1) {
                        fprintf(stderr,"Sorry code does not handle variable nx/ny yet\n");
                        return 0;
                    }
                
                    if ((*llat = (double *) malloc(nnpnts * sizeof(double))) == NULL) {
                        fatal_error("polar2ll memory allocation failed","");
                    }
                    if ((*llon = (double *) malloc(nnpnts * sizeof(double))) == NULL) {
                        fatal_error("polar2ll memory allocation failed","");
                    }
                    lat = *llat;
                    lon = *llon;
                
                
                    /* based on iplib */
                
                    lat1 = GDS_Polar_lat1(gds) * (M_PI/180);
                    lon1 = GDS_Polar_lon1(gds);
                    orient = GDS_Polar_lov(gds);
                    LatD = GDS_Polar_lad(gds);
                
                    lon1 *= (M_PI/180.0);
                    orient *= (M_PI/180.0);
                
                    dy  = GDS_Polar_dy(gds);
                    dx  = GDS_Polar_dx(gds);
                
                    h = 1.0;
                    if (GDS_Polar_sps(gds)) {
                	h = -1.0;
                	/* added 12/19/2008 WNE sps checkout */
                	orient -= M_PI;
                    }
                
                    if (! (GDS_Scan_x(nscan))) dx = -dx;
                    if (! (GDS_Scan_y(nscan))) dy = -dy;
                
                    /* 60 probably becomes something else in grib2 */
                    /* vsm: from comment to grib2 polar template:
                    "Grid length is in units of 10-3 m at the latitude specified by LaD"
                     do use GDS_Polar_lad(gds) instead of 60?
                     Do use fabs for southern hemisphere?
                    */ 
                
                    de = (1.0 + sin(fabs(LatD)*(M_PI/180.0))) * radius_earth(sec);
                    dr = de * cos(lat1) / (1 + h*sin(lat1));
                
                    xp=-h*sin(lon1-orient)*dr/dx;
                    yp= cos(lon1-orient)*dr/dy;
                
                    de2 = de*de;
                    for (iy = 0; iy < nny; iy++) {
                        for (ix = 0; ix < nnx; ix++) {
                            di = (ix - xp) * dx;
                            dj = (iy - yp) * dy;
                            dr2 = di*di + dj*dj;
                            if (dr2 < de2*1e-6) {
                                *lon++ = 0.0;
                                *lat++ = h*90.0;
                            } else {
                                tmp = (orient+h*atan2(di,-dj))*(180.0/M_PI);
                                if (tmp < 0.0) tmp += 360.0;
                                if (tmp > 360.0) tmp -= 360.0;
                                *lon++ = tmp;
                                *lat++ = h*asin((de2-dr2)/(de2+dr2))*(180.0/M_PI);
                            }
                        }
                    }
                    return 0;
                }
                
                
           1 -> int lambert2ll(unsigned char **sec, double **llat, double **llon) {
                
                
                    double n;
                    double *lat, *lon;
                
                    double dx, dy, lat1r, lon1r, lon2d, lon2r, latin1r, latin2r;
                    double lond, latd, d_lon;
                    double f, rho, rhoref, theta, startx, starty;
                    int i,j,m, nnx, nny, nres, nscan;
                    double x, y, tmp;
                    unsigned char *gds;
                    double latDr;
                    double earth_radius;
                    unsigned int nnpnts;
                
                    get_nxny(sec, &nnx, &nny, &nnpnts, &nres, &nscan);
                
                    earth_radius = radius_earth(sec);
                    gds = sec[3];
                    dy      = GDS_Lambert_dy(gds);
                    dx      = GDS_Lambert_dx(gds);
                    lat1r   = GDS_Lambert_La1(gds) * (M_PI / 180.0);
                    lon1r   = GDS_Lambert_Lo1(gds) * (M_PI / 180.0);
                    lon2d   = GDS_Lambert_Lov(gds);
                    lon2r   = lon2d * (M_PI / 180.0);
                    latin1r = GDS_Lambert_Latin1(gds) * (M_PI/180.0);
                    latin2r = GDS_Lambert_Latin2(gds) * (M_PI/180.0);
                
                //  fix for theta start value crossing 0 longitude
                //    if ((lon1r - lon2r) > 0) lon2r = lon2r + 2*M_PI;
                
                
                //
                // Latitude of "false origin" where scales are defined.
                // It is used to estimate "reference_R", rhoref.
                // Often latDr == latin1r == latin2r and non-modified code is true and works fine.
                // But could be different if intersection latitudes latin1r and latin2r are different.
                // Usually latDr must be latin1r <=  latDr <= latin2r, other could be strange.
                //
                    latDr = GDS_Lambert_LatD(gds) * (M_PI/180.0);
                
                
                    if (lon1r < 0) fatal_error("bad GDS, lon1r < 0.0","");
                
                    if ( fabs(latin1r - latin2r) < 1E-09 ) {
                        n = sin(latin1r);
                    }
                    else {
                        n = log(cos(latin1r)/cos(latin2r)) / 
                        log(tan(M_PI_4 + latin2r/2.0) / tan(M_PI_4 + latin1r/2.0));
                    }
                  
                    f = (cos(latin1r) * pow(tan(M_PI_4 + latin1r/2.0), n)) / n;
                  
                    rho = earth_radius * f * pow(tan(M_PI_4 + lat1r/2.0),-n);
                    // old rhoref = earth_radius * f * pow(tan(M_PI_4 + latin1r/2.0),-n);
                    rhoref = earth_radius * f * pow(tan(M_PI_4 + latDr/2.0),-n);
                
                    // 2/2009 .. new code
                    d_lon = lon1r - lon2r;
                    if (d_lon > M_PI) d_lon -= 2*M_PI;
                    if (d_lon < -M_PI) d_lon += 2*M_PI;
                
                    theta = n * d_lon; 
                    // 2/2009 theta = n * (lon1r - lon2r); 
                
                
                    startx = rho * sin(theta);
                    starty = rhoref - rho * cos(theta);
                
                    if (nnx <= 0 || nny <= 0) {
                        fprintf(stderr,"Sorry code does not handle variable nx/ny yet\n");
                        return 0;
                    }
                
                    if ((*llat = (double *) malloc(nnpnts * sizeof(double))) == NULL) {
                        fatal_error("lambert2ll memory allocation failed","");
                    }
                    if ((*llon = (double *) malloc(nnpnts * sizeof(double))) == NULL) {
                        fatal_error("lambert2ll memory allocation failed","");
                    }
                    lat = *llat;
                    lon = *llon;
                
                    m = 0;
                    y = starty;
                    for (j = 0; j < nny; j++) {
                      y = starty + j*dy;
                      tmp = rhoref - y;
                      for (i = 0; i < nnx; i++) {
                        x = startx + i*dx;
                        theta = atan(x / tmp); 
                        rho = sqrt(x * x + tmp*tmp);
                        rho = n > 0 ? rho : -rho;
                        lond = lon2d + todegrees(theta/n);
                        latd = todegrees(2.0 * atan(pow(earth_radius * f/rho,1.0/n)) - M_PI_2);
                        if ( lond >= 360.0) lond = lond - 360.0;
                        if ( lond < 0.0) lond = lond + 360.0;
                        lon[m] = lond;
                        lat[m] = latd;
                        m++;
                      }
                    } 
                    return 0;
                } /* end lambert2ll() */
                
       ##### -> int mercator2ll(unsigned char **sec, double **lat, double **lon) {
                
                    double dx, dy, lat1, lat2, lon1, lon2;
                    double *llat, *llon;
                    int i, j;
                    unsigned int k;
                    double dlon, circum;
                
                    double n,s,e,w,tmp;
                    unsigned char *gds;
                
                    int nnx, nny, nres, nscan;
                    unsigned int nnpnts;
                
                    get_nxny(sec, &nnx, &nny, &nnpnts, &nres, &nscan);
                    gds = sec[3];
                
                    dy     = GDS_Mercator_dy(gds);
                    dx     = GDS_Mercator_dx(gds);
                    lat1 = GDS_Mercator_lat1(gds);
                    lat2 = GDS_Mercator_lat2(gds);
                    lon1 = GDS_Mercator_lon1(gds);
                    lon2 = GDS_Mercator_lon2(gds);
                
                    if (lon1 < 0.0 || lon2 < 0.0 || lon1 > 360.0 || lon2 > 360.0) fatal_error("BAD GDS lon","");
                    if (lat1 < -90.0 || lat2 < -90.0 || lat1 > 90.0 || lat2 > 90.0) fatal_error("BAD GDS lat","");
                
                    if (GDS_Mercator_ori_angle(gds) != 0.0) {
                        fprintf(stderr,"cannot handle non-zero mercator orientation angle %f\n",
                                GDS_Mercator_ori_angle(gds));
                        return 0;
                    }
                
                    if (nnx == -1 || nny == -1) {
                        fprintf(stderr,"Sorry code does not handle variable nx/ny yet\n");
                        return 0;
                    }
                
                    if ((*lat = (double *) malloc(nnpnts * sizeof(double))) == NULL) {
                        fatal_error("mercator2ll memory allocation failed","");
                    }
                    if ((*lon = (double *) malloc(nnpnts * sizeof(double))) == NULL) {
                        fatal_error("mercator2ll memory allocation failed","");
                    }
                
                    /* now figure out the grid coordinates mucho silly grib specification */
                
                    /* find S and N latitude */
                    if (GDS_Scan_y(nscan)) {
                        s = lat1;
                        n = lat2;
                    }
                    else {
                        s = lat2;
                        n = lat1;
                    }
                    if (s > n) fatal_error("Mercator grid: lat1 and lat2","");
                
                    /* find W and E longitude */
                
                    if ( ((nscan & 16) == 16) && (nny % 2 == 0) && ((nres & 32) == 0) ) {
                         fatal_error("grib GDS ambiguity","");
                    }
                
                    if ( ((nscan & 16) == 16) && (nny % 2 == 0) ) {
                         fatal_error("more code needed to decode GDS","");
                    }
                
                    if (GDS_Scan_x(nscan)) {
                        w = lon1;
                        e = lon2;
                    } else {
                        w = lon2;
                        e = lon1;
                    }
                    if (e <= w) e += 360.0;
                
                
                    llat = *lat;
                    llon = *lon;
                
                    dlon = (e-w) / (nnx-1);
                    circum = 2.0 * M_PI * radius_earth(sec) * cos(GDS_Mercator_latD(gds) * (M_PI/180.0));
                    dx = dx * 360.0 / circum;
                
                    // dlon should be almost == to dx
                    // replace dx by dlon to get end points to match
                
                    if (dx != 0.0) {
                	if (fabs(dx-dlon) / fabs(dx) < 0.01) dx = dlon;
                    }
                
                
                    s = log(tan((45+s/2)*M_PI/180));
                    n = log(tan((45+n/2)*M_PI/180));
                    dy = (n - s) / (nny - 1);
                
                    for (j = 0; j < nny; j++) {
                        tmp = (atan(exp(s+j*dy))*180/M_PI-45)*2;
                        for (i = 0; i < nnx; i++) {
                            *llat++ = tmp;
                        }
                    }
                
                    for (j = 0; j < nnx; j++) {
                        llon[j] = w + j*dx >= 360.0 ?  w + j*dx - 360.0 : w + j*dx;
                    }
                    for (k = nnx; k < nnpnts; k++) {
                        llon[k] = llon[k-nnx];
                    }
                    return 0;
                } /* end mercator2ll() */
                
                
                /*  kdp 2005-08-22
                 *  
                 *  Code for computing Gaussian latitudes was adapted from
                 *  the wonderful gauss2lats.m Matlab program from Tom Holt.
                 *  The code gauss2lats.m also works quite well with Octave.
                 *
                 *  Note that the algorithms used here require a 1-based
                 *  array vice the typical 0-based array.  The points are
                 *  mapped correctly to the (lat,lon) arrays as zero-based.
                 *
                 * Note: adapted from an NCAR fortran program by Tom Holt
                 */
       ##### -> double gord(int n, double x) {
                  
                  double colat = acos(x);
                  double c1 = M_SQRT2;
                  int i;
                  
                  double fn = (double) n;
                  double ang = fn * colat;
                  double s1 =  0.0;
                  double c4 =  1.0;
                  double a  = -1.0;
                  double b  =  0.0;
                  double fi;
                
                  for (i=1; i <= n; i++) {
                    c1 = c1 * sqrt(1.0 - 1.0/(4.0*i*i));
                  } 
                  
                  for (i = 0; i <= n; i = i + 2) {
                    if ( i == n ) { c4 = 0.5 * c4; }
                    s1  = s1 + c4*cos(ang);
                    a   = a + 2.0;
                    b   = b + 1.0;
                    fi = (double) i;
                    ang = colat*(fn - fi - 2.0); 
                    c4 = (a*(fn-b+1.0)/(b*(fn+fn-a)))*c4;
                  }
                  
                  return ( s1 * c1 );
                  
                } /* end gord() */
                
                
       ##### -> double *gauss2lats(int nlat, double *ylat) {
                  
                  const double xlim = 1.0E-7;
                  
                  double *cosc  = (double *) malloc(sizeof(double) * (nlat + 1));
                  double *sinc  = (double *) malloc(sizeof(double) * (nlat + 1));
                  double *colat = (double *) malloc(sizeof(double) * (nlat + 1));
                  
                  int nzero = (nlat / 2);
                  
                  int i;
                  double fi = nlat;
                  double fi1 = fi + 1.0;
                  double a = fi * fi1/sqrt(4.0*fi1*fi1 - 1.0);
                  double b = fi1 * fi/sqrt(4.0*fi*fi - 1.0);
                
                    double g, gm, gp, gt, delta, d;
                
                  for (i = 1; i <= nzero; i++) {
                    cosc[i] = sin((i - 0.5)*M_PI/nlat + M_PI*0.5);
                  }
                  
                  for (i = 1; i <= nzero; i++) {
                    g = gord(nlat, cosc[i]);
                    gm = gord(nlat - 1, cosc[i]);
                    gp = gord(nlat + 1, cosc[i]);
                    gt = (cosc[i]*cosc[i] - 1.0)/(a * gp - b * gm);
                    delta = g*gt;
                    cosc[i] = cosc[i] - delta;
                    
                    while ( fabs(delta) > xlim ) {
                      g = gord(nlat,cosc[i]);
                      gm = gord(nlat - 1, cosc[i]);
                      gp = gord(nlat + 1, cosc[i]);
                      gt = (cosc[i]*cosc[i] - 1.0)/(a * gp - b * gm);
                      delta = g*gt;
                      cosc[i] = cosc[i] - delta;
                      
                    } /* end while */
                    
                  } /* end for */
                  
                  for (i = 1; i <= nzero; i++) {
                    colat[i] = acos(cosc[i]);
                    sinc[i] = sin(colat[i]);
                  }
                  
                  /*
                   * ... deal with equator if odd number of points
                   */
                  if ( ( nlat % 2) != 0 ) {
                    i = nzero + 1;
                    cosc[i] = 0.0;
                    d = gord(nlat - 1, cosc[i]);
                    d = d*d*fi*fi;
                    colat[i] = M_PI * 0.5;
                    sinc[i] = 1.0;
                  } /* end if() */
                  
                  /*
                   *  ... deal with southern hemisphere by symmetry
                   */
                  for (i = nlat - nzero + 1; i <= nlat; i++) {
                    cosc[i]  = -cosc[nlat + 1 - i];
                    colat[i] = M_PI - colat[nlat + 1 - i];
                    sinc[i]  = sinc[nlat + 1 - i];
                  } /* end for(i) */
                  
                  for (i = 1; i <= nlat; i++) {
                    ylat[i-1] = todegrees(acos(sinc[i]));
                    if ( i > (nlat / 2) ) ylat[i-1] = -ylat[i-1];
                    /* change from N-S to S-N */
                    ylat[i-1] = -ylat[i-1];
                  }
                
                  free(cosc);
                  free(sinc);
                  free(colat);
                  
                  return ylat;
                  
                } /* end gauss2lats() */
                
                
       ##### -> int gauss2ll(unsigned char **sec, double **llat, double **llon) {
                 
                 
                    int nlat; /* in grib, number of latitudes must be even! */
                  
                    double dx, e, w, lat1, lon1, lat2, lon2, *ylat;
                    double units;
                    double *lat, *lon;
                    int basic_ang, sub_ang;
                    int i,j,n;
                    unsigned int k;
                    unsigned char *gds;
                
                    int nnx, nny, nres, nscan;
                    unsigned int nnpnts;
                
                    get_nxny(sec, &nnx, &nny, &nnpnts, &nres, &nscan);
                
                    gds = sec[3];
                    nlat = 2 * GDS_Gaussian_nlat(gds);
                
                    /* figure out angle units */
                
                    basic_ang = GDS_Gaussian_basic_ang(gds);
                    sub_ang = GDS_Gaussian_sub_ang(gds);
                    units = basic_ang == 0 ? 0.000001 : (double) basic_ang / (double) sub_ang;
                
                    lat1 = GDS_Gaussian_lat1(gds) * units;
                    lat2 = GDS_Gaussian_lat2(gds) * units;
                    lon1 = GDS_Gaussian_lon1(gds) * units;
                    lon2 = GDS_Gaussian_lon2(gds) * units;
                
                    if (lon1 < 0.0 || lon2 < 0.0 || lon1 > 360.0 || lon2 > 360.0) fatal_error("BAD GDS lon","");
                    if (lat1 < -90.0 || lat2 < -90.0 || lat1 > 90.0 || lat2 > 90.0) fatal_error("BAD GDS lat","");
                
                    if (nny == -1) {
                        fprintf(stderr,"Sorry code does not handle variable ny yet\n");
                        return 0;
                    }
                
                    if (nny != nlat) {
                       fatal_error("nx != nlat .. need to fix code to handle this case","");
                    }
                    if ((*llat = (double *) malloc(nnpnts * sizeof(double))) == NULL) {
                        fatal_error("gauss2ll memory allocation failed","");
                    }
                    if ((*llon = (double *) malloc(nnpnts * sizeof(double))) == NULL) {
                        fatal_error("gauss2ll memory allocation failed","");
                    }
                    lat = *llat;
                    lon = *llon;
                
                    /* do latitudes first */
                 
                    ylat = (double *) malloc(sizeof(double) * nlat);
                
                    gauss2lats(nlat, ylat);
                
                    n = 0;
                    if (nnx >= 0) {        /* regular grid */
                        for (j = 0; j < nny; j++) {
                            for (i = 0; i < nnx; i++) {
                                lat[n++] = ylat[j];
                            }
                        }
                    }
                    else {                /* quasi regular grid */
                        for (j = 0; j < nny; j++) {
                            for (i = 0; i < variable_dim[j];  i++) {
                                lat[n++] = ylat[j];
                            }
                        }
                    }
                
                    free(ylat); 
                
                    /* now for the longitudes */
                  
                    if (GDS_Scan_x(nscan)) {
                        e = lon1;
                        w = lon2;
                    }
                    else {
                        e = lon2;
                        w = lon1;
                    }
                    if (e > w) w += 360.0;
                    if (e < 0.0) {
                        e += 360.0;
                        w += 360.0;
                    }
                    if (e >= 360.0) {
                        e -= 360.0;
                        w -= 360.0;
                    }
                
                    if (nnx >= 0) {
                        dx = (w-e) / (nnx-1);
                        for (j = 0; j < nnx; j++ ) {
                            lon[j] = e + (dx * j) >= 360.0 ?  e + (dx * j) - 360.0 : e + (dx * j);  
                        }
                        for (k = nnx; k < nnpnts; k++) {
                            lon[k] = lon[k-nnx];
                        }
                    }
                    else {
                        n = 0;
                        for (j = 0; j < nny; j++) {
                            dx = (w-e) / (variable_dim[j]-1);
                            for (i = 0; i < variable_dim[j]; i++) {
                                lon[n++] = e + (dx * i) >= 360.0 ?  e + (dx * i) - 360.0 : e + (dx * i);
                            }
                        }
                    }
                    return 0;
                } /* end gauss2ll() */
                
                
                /* find the closest grid point to (plat, plon) */
                
                /* this code needs to be rewritten. too slow */
                
                
                
                /* closest_init:  location of grid point in x-y-z space, assume r=1 */ 
                
                static double *x = NULL, *y = NULL, *z = NULL;
                
                
       ##### -> int closest_init(unsigned char **sec) {
                
                   unsigned int i, nnpts;
                   double s, c;
                   int grid_type;
                
                   // if lat-lon grid .. insert code here
                   grid_type = code_table_3_1(sec);
                
                   if (grid_type == 0 && nx > 0 && ny > 0 && output_order == wesn) return latlon_init(sec, nx, ny);
                
                   nnpts = GB2_Sec3_npts(sec);
                   if (x) {
                        free(x);
                        free(y);
                        free(z);
                        x = y = z = NULL;
                    }
                    if (lat && lon) {
                        x = (double *) malloc(nnpts * sizeof(double));
                        y = (double *) malloc(nnpts * sizeof(double));
                        z = (double *) malloc(nnpts * sizeof(double));
                        if (x == NULL || y == NULL || z == NULL) fatal_error("memory allocation closest_init","");
                
                        s = z[0] = sin(lat[0] * (M_PI / 180.0));
                        c = sqrt(1.0 - s * s);
                        x[0] = c * cos(lon[0] * (M_PI / 180.0));
                        y[0] = c * sin(lon[0] * (M_PI / 180.0));
                
                        for (i = 1; i < nnpts; i++) {
                            if (lat[i] != lat[i-1]) {
                                s = sin(lat[i] * (M_PI / 180.0));
                                c = sqrt(1.0 - s * s);
                            }
                            z[i] = s;
                            x[i] = c * cos(lon[i] * (M_PI / 180.0));
                            y[i] = c * sin(lon[i] * (M_PI / 180.0));
                        }
                    }
                    return 0;
                }
                
       ##### -> int closest(unsigned char **sec, double plat, double plon) {
                
                    unsigned int i, j, nnpts;
                    int grid_type;
                    double t, xx, yy, zz, small;
                
                    // if lat-lon grid .. insert code here
                    grid_type = code_table_3_1(sec);
                    if (grid_type == 0 && nx > 0 && ny > 0 && output_order == wesn) return latlon_closest(sec, plat, plon);
                
                    nnpts = GB2_Sec3_npts(sec);
                    if (x == NULL || nnpts <= 0) return -1;
                
                    zz = sin(plat * (M_PI / 180.0));
                    t = sqrt(1.0 - zz*zz);
                    xx = t * cos(plon * (M_PI / 180.0));
                    yy = t * sin(plon * (M_PI / 180.0));
                
                    small = (x[0]-xx)*(x[0]-xx)+(y[0]-yy)*(y[0]-yy)+(z[0]-zz)*(z[0]-zz);
                    j = 0;
                
                    for (i = 1; i < nnpts; i++) {
                        t = (x[i]-xx)*(x[i]-xx)+(y[i]-yy)*(y[i]-yy)+(z[i]-zz)*(z[i]-zz);
                        if (t < small) {
                            small = t;
                            j = i;
                        }
                    }
                    return j;
                }


Top 10 Lines:

     Line      Count

       56    1478594
      283          1

Execution Summary:

       10   Executable lines in this file
       10   Lines executed
   100.00   Percent of the file executed

  1478595   Total number of line executions
147859.50   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/cname.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                
                #include "wgrib2.h"
                #include "grb2.h"
                
                
                
                extern struct gribtab_s gribtab[];
                
                static struct gribtab_s *search_gribtab(struct gribtab_s *gribtab, unsigned char **sec);
                
                #ifdef USE_TIGGE
                extern int tigge;
                extern struct gribtab_s tigge_gribtab[];
                #endif
                /*
                 * get the name information
                 *
                 * if inv_out, name, desc, unit == NULL, not used
                 *
                 * v1.0 Wesley Ebisuzaki 2006
                 * v1.1 Wesley Ebisuzaki 4/2007 netcdf support
                 * v1.2 Wesley Ebisuzaki 4/2007 multiple table support
                 */
                
                
          17 -> int getName(unsigned char **sec, int mode, char *inv_out, char *name, char *desc, char *unit) {
                
                    int discipline, center, mastertab, localtab, parmcat, parmnum;
                    struct gribtab_s *p;
                
                    p = NULL;
                
                #ifdef USE_TIGGE
                    if (tigge) p = search_gribtab(tigge_gribtab, sec);		/* tigge is default table */
                #endif
                    if (p == NULL) p = search_gribtab(gribtab, sec);
                #ifdef USE_TIGGE
                    /* if undefined and a tigge file */
                    if (p == NULL && !tigge && (code_table_1_3(sec) == 4 || code_table_1_3(sec) == 5)) p = search_gribtab(tigge_gribtab, sec);
                #endif
                
                    if (p) {
                        if (name) strcpy(name, p->name);
                	if (desc) strcpy(desc, p->desc);
                	if (unit) strcpy(unit, p->unit);
                
                	if (inv_out) {
                	    sprintf(inv_out, "%s", p->name);
                	    inv_out += strlen(inv_out);
                            if (mode) sprintf(inv_out," %s [%s]", p->desc, p->unit);
                        }
                   }
                   else {
                        discipline = GB2_Discipline(sec);
                        center = GB2_Center(sec);
                        mastertab = GB2_MasterTable(sec);
                        localtab = GB2_LocalTable(sec);
                        parmcat = GB2_ParmCat(sec);
                        parmnum = GB2_ParmNum(sec);
                
                        if (name) sprintf(name,"var%d_%d_%d",discipline,parmcat,parmnum);
                	if (desc) strcpy(desc,"desc");
                	if (unit) strcpy(unit,"unit");
                
                	if (inv_out) {
                            if (parmnum < 192) {
                                sprintf(inv_out,"var discipline=%d master_table=%d parmcat=%d parm=%d", 
                                  discipline, mastertab, parmcat, parmnum);
                            }
                            else {
                	        sprintf(inv_out,"var discipline=%d center=%d local_table=%d parmcat=%d parm=%d",
                                  discipline, center, localtab, parmcat, parmnum);
                            }
                	}
                   }
                   return 0;
                }
                
                /*
                 * search the grib table
                 */
                
          17 -> static struct gribtab_s *search_gribtab(struct gribtab_s *p, unsigned char **sec){
                
                    int discipline, center, mastertab, localtab, parmcat, parmnum;
                
                    discipline = GB2_Discipline(sec);
                    center = GB2_Center(sec);
                    mastertab = GB2_MasterTable(sec);
                    localtab = GB2_LocalTable(sec);
                    parmcat = GB2_ParmCat(sec);
                    parmnum = GB2_ParmNum(sec);
                
                    // if (mastertab == 0) mastertab = 1;
                    if (mastertab >= 0 && mastertab <= 5) mastertab = 1;
                
                    for (; p->disc >= 0; p++) {
                        if (parmnum < 192) {
                            if (discipline == p->disc && (mastertab == p->mtab || p->mtab == -1) &&
                                parmcat == p->pcat && parmnum == p->pnum) {
                                return p;
                            }
                        }
                        else {
                            if (discipline == p->disc && center == p->cntr &&
                                localtab == p->ltab &&
                                parmcat == p->pcat && parmnum == p->pnum) {
                                return p;
                                break;
                            }
                        }
                   }
                   return NULL;
                }
                


Top 10 Lines:

     Line      Count

       29         17
       86         17

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

       34   Total number of line executions
    17.00   Average executions per line


*** File /home/chen/Downloads/pGrib2nc/grib2nc/addtime.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include <stddef.h>
                #include <string.h>
                #include <math.h>
                #include "wgrib2.h"
                #include "CodeTable4_4.h"
                
                #define  FEB29   (31+29)
                static int monthjday[12] = {
                        0,31,59,90,120,151,181,212,243,273,304,334};
                
       ##### -> static int leap(int year) {
                	if (year % 4 != 0) return 0;
                	if (year % 100 != 0) return 1;
                	return (year % 400 == 0);
                }
                
                
                /*
                    add_time:  adds a positive value to a time code
                    public domain 2006: wesley ebisuzaki
                    1/2007 cleanup M. Schwarb, W. Ebisuzaki
                    1/2006 removed floor(), case where floor(24/24.0) == 0
                    some day should allow +/- dtime (not needed for this application
                 */
                
                int add_time(int *year, int *month, int *day, int *hour, int *minute, int *second, 
          17 ->    unsigned int dtime, int unit) {
                
                    int y, m, d, h, mm, s, jday, i;
                
                    y = *year;
                    m = *month;
                    d = *day;
                    h = *hour;
                    mm = *minute;
                    s = *second;
                
                    if (unit == 255 || unit == -1) return 0;	// no valid time unit
                    if (dtime == 0xffffffff) return 0;		// missing dtime
                
                    if (unit == YEAR) {
                	*year = y + dtime;
                	return 0;
                    }
                    if (unit == DECADE) {
                	*year =  y + (10 * dtime);
                	return 0;
                    }
                    if (unit == CENTURY) {
                	*year = y + (100 * dtime);
                	return 0;
                    }
                    if (unit == NORMAL) {
                	*year = y + (30 * dtime);
                	return 0;
                    }
                    if (unit == MONTH) {
                /*
                        if (dtime < 0) {
                           i = (-dtime) / 12 + 1;
                           y -= i;
                           dtime += (i * 12);
                        }
                */
                	dtime += (m - 1);
                	*year = y + (dtime / 12);
                	*month = 1 + (dtime % 12);
                	return 0;
                    }
                    if (unit == SECOND) {
                	s += dtime;
                	// dtime = floor(s/60.0);
                	dtime =  s / 60;
                	*second = s - dtime*60;
                	if (dtime == 0) return 0;
                	unit = MINUTE;
                    }
                    if (unit == MINUTE) {
                	mm += dtime;
                	// dtime = floor(mm/60.0);
                	dtime = mm /60;
                	*minute = mm - dtime*60;
                	if (dtime == 0) return 0;
                	unit = HOUR;
                    }
                    if (unit == HOUR3) {
                	dtime *= 3;
                	unit = HOUR;
                    }
                    if (unit == HOUR6) {
                	dtime *= 6;
                	unit = HOUR;
                    }
                    if (unit == HOUR12) {
                	dtime *= 12;
                	unit = HOUR;
                    }
                    if (unit == HOUR) {
                	h += dtime;
                	// dtime = floor(h/24.0);
                	dtime = h / 24;
                	*hour = h - dtime*24;
                	if (dtime == 0) return 0;
                	unit = DAY;
                    }
                
                    /* this is the hard part */
                
                    if (unit == DAY) {
                	/* set m and day to Jan 0, and readjust dtime */
                	jday = d + monthjday[m-1];
                	if (leap(y) && m > 2) jday++;
                        dtime += jday;
                /*
                        while (dtime < 0) {
                            y--;
                	    dtime += 365 + leap(y);
                        }
                */
                	/* one year chunks */
                	while (dtime > 365 + leap(y)) {
                	    dtime -= (365 + leap(y));
                	    y++;
                	}
                
                	/* calculate the month and day */
                
                	if (leap(y) && dtime == FEB29) {
                	    m = 2;
                	    d = 29;
                	}
                	else {
                	    if (leap(y) && dtime > FEB29) dtime--;
                	    for (i = 11; monthjday[i] >= dtime; --i);
                	    m = i + 1;
                	    d = dtime - monthjday[i];
                	}
                	*year = y;
                	*month = m;
                	*day = d;
                	return 0;
                   }
                   fprintf(stderr,"add_time: undefined time unit %d\n", unit);
                   return 1;
                }
                
                /*
                   This routine reads year/month/day.../second byte code and saves it in variables
                 */
                
          17 -> int get_time(unsigned char *p, int *year, int *month, int *day, int *hour, int *minute, int *second) {
                    *year = (p[0] << 8) | p[1];
                    p += 2;
                    *month = (int) *p++;
                    *day = (int) *p++;
                    *hour = (int) *p++;
                    *minute = (int) *p++;
                    *second = (int) *p;
                    return 0;
                }
                
                /*
                   inverse of get_time .. save time code in PDS
                 */
                
       ##### -> int save_time(int year, int month, int day, int hour, int minute, int second, unsigned char *p) {
                
                    *p++ = (unsigned char) (year >> 8) & 255;
                    *p++ = (unsigned char) year & 255;
                    *p++ = (unsigned char) month;
                    *p++ = (unsigned char) day;
                    *p++ = (unsigned char) hour;
                    *p++ = (unsigned char) minute;
                    *p++ = (unsigned char) second;
                    return 0;
                }
                
                /*
                   compare two time codes: return -1 : 0 : 1
                 */
                
                int cmp_time(
                int year0, int month0, int day0, int hour0, int minute0, int second0, 
       ##### -> int year1, int month1, int day1, int hour1, int minute1, int second1) {
                
                	if (year0 < year1) return -1;
                	if (year0 > year1) return 1;
                	if (month0 < month1) return -1;
                	if (month0 > month1) return 1;
                	if (day0 < day1) return -1;
                	if (day0 > day1) return 1;
                	if (hour0 < hour1) return -1;
                	if (hour0 > hour1) return 1;
                	if (minute0 < minute1) return -1;
                	if (minute0 > minute1) return 1;
                	if (second0 < second1) return -1;
                	if (second0 > second1) return 1;
                	return 0;
                }
                


Top 10 Lines:

     Line      Count

       29         17
      153         17

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

       34   Total number of line executions
     6.80   Average executions per line
